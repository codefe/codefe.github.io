{"sta":1,"data":{"subTitle":"Puppeteer实践指南之网页转PDF","content":"<h3>一、背景</h3><p>开发工作中，需要实现网页生成 PDF 的功能，生成的 PDF 需上传至服务端，将 PDF 地址作为参数请求外部接口，这个转换过程及转换后的 PDF 不需要在前端展示给用户。\n<br>\n<br><h3>二、技术选型\n</h3>该功能不需要在前端展示给用户，为节省客户端资源，选择在服务端实现网页生成 PDF 的功能。\n<br>\n<br>Puppeteer\n<br>Puppeteer 是一个 Node 库，它提供了高级 API 来通过 DevTools 协议控制 Chrome 或 Chromium。\n<br>\n<br>在浏览器中手动执行的大多数操作都可以使用 Puppeteer 完成，比如：\n<br>\n<br><blockquote>生成页面的屏幕截图和 PDF；<br>\n爬取 SPA 并生成预渲染的内容（即 SSR）；<br>\n自动进行表单提交，UI 测试，键盘输入等；<br>\n创建最新的自动化测试环境。使用最新的 JavaScript 和浏览器功能，直接在最新版本的 Chrome 中运行测试；<br>\n捕获时间线跟踪网站，以帮助诊断性能问题；<br>\n测试 Chrome 扩展程序。\n</blockquote>从上可见，Puppeteer 可以实现在Node 端生成页面的 PDF 功能。\n<br>\n<br><h3>三、实现步骤\n</h3><h4>安装\n</h4>进入项目，安装 puppeteer 到本地。</p><blockquote>$ npm install -g cnpm --registry=https://registry.npm.taobao.org<br>\n$ cnpm i puppeteer --save</blockquote><p>注意还有另一个版本的 puppeteer, 就是 puppeteer-core, 使用 puppeteer-core 需注意本地有可连接的浏览器，且安装的 puppeteer-core 版本与打算连接的浏览器兼容。连接本地浏览器方法如下：</p><pre>const browser = await puppeteer.launch({ \n  executablePath: '/path/to/Chrome' \n});</pre><p>本项目需要部署至服务端，因此选择安装的是 puppeteer。</p><h4>生成浏览器</h4><pre>const browser = await puppeteer.launch({\n    headless: true,\n    args: ['--no-sandbox', '--font-render-hinting=medium']\n  })</pre><p>headless 代表无头模式，生成的浏览器在后端打开，前端不会有展示。</p><blockquote>小建议：本地调试时，建议设置 headless: false，可以启动完整版本的浏览器，直接在浏览器窗口查看内容。</blockquote><p><h4>打开新页面\n</h4>生成浏览器后，在浏览器中打开新页面。</p><blockquote>const page = await browser.newPage()</blockquote><p><h4>跳转到指定页面\n</h4>跳转至要生成 PDF 的页面。</p><pre>await page.goto(`${baseURL}/article/${id}`, {\n    timeout: 60000,\n    waitUntil: 'networkidle2', // networkidle2 会一直等待，直到页面加载后不存在 2 个以上的资源请求，这种状态持续至少 500 ms\n  })</pre><p>timeout 是最长的加载时间，默认 30s，网页加载时间长的情况下，建议将 timeout 值改大，防止超时报错。\n<br>\n<br>waitUntil 表示页面加载到什么程度可以开始生成 PDF 或其他操作了，当网页需加载的图片资源较多时，建议设置为 networkidle2，有以下值可选：<br><blockquote>load：当 load 事件触发时；<br>\ndomcontentloaded： 当 DOMContentLoaded 事件触发时；<br>\nnetworkidle0： 页面加载后不存在 0 个以上的资源请求，这种状态持续至少 500 ms；<br>\nnetworkidle2： 页面加载后不存在 2 个以上的资源请求，这种状态持续至少 500 ms。\n</blockquote><h4>指定路径，生成pdf\n</h4>上述指定的页面加载完成后，将该页面生成 PDF。</p><pre>const ext = '.pdf'\nconst key = randomFilename(title, ext)\nconst _path = path.resolve(config.uploadDir, key)\nawait page.pdf({ path: _path, format: 'a4' })</pre><p>path 表示将 PDF 保存到的文件路径，如果未提供路径，PDF 将不会保存至磁盘。</p><blockquote>小建议：不管 PDF 是不是需要保存到本地，建议在调试的时候都设置一个path，方便查看生成的 PDF 的样式，检查是否有问题。</blockquote><p>format 表示 PDF 的纸张格式，a4 尺寸为 8.27 英寸 x 11.7 英寸，是传统的打印尺寸。</p><p>注意：目前仅支持headless: true 无头模式下生成 PDF</p><p><h4>关闭浏览器\n</h4>所有操作完成后，关闭浏览器，节约性能。</p><blockquote>await browser.close()</blockquote><p><h3>四、难点\n</h3><h4>图片懒加载\n</h4>由于需生成 PDF 的页面是文章类型的页面，包含大量图片，且图片引入了懒加载，导致生成的 PDF 会带有很多懒加载兜底图</p><p>解决方法是跳转到页面后，将页面滚动到底部，所有图片资源都会得到请求，waitUntil 设置为 networkidle2，图片就能加载成功了。</p><pre>await autoScroll(page) // 因为文章图片引入了懒加载，所以需要把页面滑动到最底部，保证所有图片都加载出来\n\n/**\n * 控制页面自动滚动\n * */\nfunction autoScroll (page) {\n  return page.evaluate(() =&gt; {\n    return new Promise&lt;void&gt;(resolve =&gt; {\n      let totalHeight = 0\n      const distance = 100\n      // 每200毫秒让页面下滑100像素的距离\n      const timer = setInterval(() =&gt; {\n        const scrollHeight = document.body.scrollHeight\n        window.scrollBy(0, distance)\n        totalHeight += distance\n        if (totalHeight &gt;= scrollHeight) {\n          clearInterval(timer)\n          resolve()\n        }\n      }, 200)\n    })\n  })\n}</pre><p>这里用到了 page.evaluate() 方法，用来控制页面操作，比如使用内置的 DOM 选择器、使用 window 方法等等。\n<br>\n<br><h4>CSS 打印样式\n</h4>根据 官网 说明，page.pdf() 生成 PDF 文件的样式是通过 print css media 指定的，因此可以通过 css 来修改生成的 PDF 的样式，以本文需求为例，生成的 PDF 需要隐藏头部、底部，以及其他和文章主体无关的部分，代码如下：</p><pre>@media print {\n  .other_info,\n  .authors,\n  .textDetail_comment,\n  .detail_recTitle,\n  .detail_rec,\n  .SuspensePanel {\n    display: none !important;\n  }\n\n  .Footer,\n  .HeaderSuctionTop {\n    display: none;\n  }\n}</pre><p><h4>登录态\n</h4>由于存在一部分文章不对外部用户公开，需要鉴权用户身份，符合要求的用户才能看到文章内容，因此跳转到指定文章页后，需要在生成的浏览器窗口中注入登录态，符合条件的登录用户才能看到这部分文章的内容。\n<br>\n<br>采用注入 cookie 的方式来获取登录态，使用 page.evaluate() 设置 cookie，代码如下：</p><pre>async function simulateLogin (page, cookies, domain) {\n  return await page.evaluate((sig, sess, domain) =&gt; {\n    let date = new Date()\n    date = new Date(date.setDate(date.getDate() + 1))\n    let expires = ''\n    expires = `; expires=${date.toUTCString()}`\n    document.cookie = `koa:sess.sig=${sig}${expires}; domain=${domain}; path=/`\n    document.cookie = `koa:sess=${sess}=${expires}; domain=${domain}; path=/` // =是这个cookie的value\n    document.cookie = `is_login=true${expires}; domain=${domain}; path=/`\n  }, cookies['koa:sess.sig'], cookies['koa:sess'], domain)\n}\n\n\nawait simulateLogin(page, cookies, config.domain.split('//')[1])</pre><p>小建议：Puppeteer 也有自带的 api 实现 cookie 注入，如 page.setCookie({name: name, value: value})，但是我用这个方式注入没能获取到登录态，没有找到具体原因，建议还是直接用我上面这个方法来注入 cookie，注意除 name 和 value外，expires、domain、path 也需要配置。</p><p><h3>Docker 部署 Puppeteer\n</h3>根据上文操作，本地已经可以成功将页面生成 PDF 了，本地体验没问题后，需要部署到服务端给到测试、上线。\n<br>\n<br>没有修改 Dockerfile 时，部署后发现错误</p><p>官网有给 Docker 配置说明 可以参考，最终实践可用的 ubuntu 系统的 Dockerfile 如下：</p><pre>FROM  is.jd.com/o2athena/ubuntu-nvm-multimedia\n\nENV TIMEZONE=Asia/Shanghai\nENV NODE_PATH=/usr/lib/node_modules\nENV PUPPETEER_DOWNLOAD_HOST=https://storage.googleapis.com.cnpmjs.org\n\n# 复制仓库到 /app\n# node_modules/* 和 /web/* 不会复制\nWORKDIR /app\n\nCOPY . .\n\n# 安装 puppeteer 依赖\nRUN apt-get update &amp;&amp; \\\n    apt-get install -y libgbm-dev &amp;&amp; \\\n    apt-get install gconf-service libasound2 libatk1.0-0 libatk-bridge2.0-0 libc6 libcairo2 libcups2 libdbus-1-3 libexpat1 libfontconfig1 libgcc1 libgconf-2-4 libgdk-pixbuf2.0-0 libglib2.0-0 libgtk-3-0 libnspr4 libpango-1.0-0 libpangocairo-1.0-0 libstdc++6 libx11-6 libx11-xcb1 libxcb1 libxcomposite1 libxcursor1 libxdamage1 libxext6 libxfixes3 libxi6 libxrandr2 libxrender1 libxss1 libxtst6 ca-certificates fonts-liberation libappindicator1 libnss3 lsb-release xdg-utils wget build-essential libcairo2-dev libpango1.0-dev libjpeg-dev libgif-dev librsvg2-dev -y &amp;&amp; \\\n    apt-get install -y fonts-ipafont-gothic fonts-wqy-zenhei fonts-thai-tlwg fonts-kacst fonts-freefont-ttf --no-install-recommends\n\nRUN ln -snf /usr/share/zoneinfo/$TIMEZONE /etc/localtime \\\n  &amp;&amp; echo $TIMEZONE &gt; /etc/timezone \\\n  &amp;&amp; apt-get update \\\n  &amp;&amp; apt-get install -y tzdata\n\n# 安装依赖\nRUN . $NVM_DIR/nvm.sh \\\n  &amp;&amp; nvm install 13 \\\n  &amp;&amp; nvm use 13 \\\n  &amp;&amp; npm install --production --registry=http://registry.m.jd.com\n\nENTRYPOINT . $NVM_DIR/nvm.sh \\\n  &amp;&amp; nvm use 13 \\\n  &amp;&amp; chmod +x /app/start.sh \\\n  &amp;&amp; /app/start.sh \\\n  &amp;&amp; sleep 9999d</pre><p>只需要重点关注 安装 puppeteer 依赖 部分即可。</p><blockquote>注意：在 v1.18.1 之前，Puppeteer 至少需要 Node v6.4.0。从 v1.18.1 到 v2.1.0 的版本都依赖于 Node 8.9.0+。从 v3.0.0 开始，Puppeteer 开始依赖于 Node 10.18.1+。配置 Dockerfile 时也需要注意服务端的 node 版本。</blockquote><p><h3>五、总结\n</h3>本文讲述了实现在 Node 端将网页生成 PDF 文件的完整过程，总结为以下 3 点：\n<br>\n<br>技术选型，根据需求场景选择合适的手段实现功能；\n<br>阅读&nbsp;<a href=\"https://pptr.dev/\" target=\"_blank\">官方文档</a>&nbsp;，快速过一遍文档才能少遇到些坑；\n<br>破解难点，使用一个未使用的工具，会遇到没有解决过的难题，遇招拆招吧 ^ ^。\n<br>参照<a href=\"https://github.com/jiaozitang/puppeteerPdfDemo\" target=\"_blank\">Demo</a>&nbsp;源码 可快速上手上述功能，希望本文能对你有所帮助，感谢阅读❤️</p><p><br></p><p><br></p>"}}