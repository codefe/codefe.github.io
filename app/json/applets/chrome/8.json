{"sta":1,"data":{"subTitle":"通过 background scripts 管理事件","content":"<h3>一、描述</h3><p>扩展程序是基于事件的程序，用于修改或增强 Chrome 浏览体验。<br>Event 是浏览器触发器，例如导航到新页面、删除书签或关闭选项卡。<br>扩展程序在后台脚本中监视这些事件，然后对指定的指令作出反应。<br>后台运行的页面会在需要的时候再去加载， 不需要的时候会进行卸载，一些事件的例子包括：<br>扩展程序第一次安装或者是更新成新版本的时候\n<br>后台页面正在监听事件，并且需要调度这个事件\n<br>前台的脚本或者是其他的扩展对后台脚本发送了消息\n<br>这个扩展程序中的其他页面比如 popup 页面，调用了 runtime.getBackgroundPage API\n<br>后台页面挂载之后，只需要执行操作（比如调用 Chrome API 或者发出网络请求），后台页面就会一直运行。此外，在关闭所有可见视图和所有消息端口之前，不会写在后台页面，需要注意的是，打开视图不会导致加载 event page，只会阻止它在加载后关闭。<br>有效的后台脚本会保持休眠状态，知道它们监听到有消息 fire，并且对指定的指令做出反应然后卸载。\n<br>\n<br><h3>二、注册后台脚本\n</h3>后台脚本在 manifest 的 background 字段中注册，可以注册多个后台脚本，会放在 background.scripts 字段下面，同时 persistent 应该指定为 false。<br>示例：</p><pre>{\n  \"name\": \"Awesome Test Extension\",\n  ...\n  \"background\": {\n    \"scripts\": [\"background.js\"],\n    \"persistent\": false\n  },\n  ...\n}</pre><p>我们可以为模块化代码注册多个后台脚本：</p><pre>{\n     \"name\": \"Awesome Test Extension\",\n     ...\n     \"background\": {\n       \"scripts\": [\n         \"backgroundContextMenus.js\",\n         \"backgroundOmniBox.js\",\n         \"backgroundOauth.js\"\n       ],\n       \"persistent\": false\n     },\n     ...\n   }</pre><p>保持后台脚本 active 状态的唯一场景是扩展程序使用 chrome.webRequest API 来拦截或者修改网络请求， webRequest API 和非持久性后台页面不兼容。\n<br>\n<br>如果扩展程序正在使用持久性后台页面，可以参照 后台脚本迁移指南 来切换成非持久性后台页面。\n<br>\n<br><h3>三、初始化扩展程序的时机\n</h3>监听 runtime.onInstalled 事件以便于在安装的时候初始化扩展程序，使用这个事件可以设置状态或者一次性初始化，比如上下文菜单。\n<br>\n</p><pre>chrome.runtime.onInstalled.addListener(() =&gt; {\n    chrome.contextMenus.create({\n        \"id\": \"testMenus\",\n        \"title\": \"test Context Menu\",\n        \"contexts\": [\"selection\"]\n    });\n});</pre><p><h3>四、监听事件\n</h3>围绕扩展所依赖的事件去构造后台脚本，定义功能相关事件，允许后台脚本处于休眠状态，直到触发这些事件的时候，并且能够防止扩展缺少重要触发器。<br>必须在页面开始的时候就注册监听器。</p><pre>// 下面将会在创建书签的时候触发\nchrome.bookmarks.onCreated.addListener(() =&gt; {\n    // ...\n});</pre><p>事件监听器不能异步注册，否则不会正确的被触发，比如你不能在一个扩展 onInstalled 触发的时候注册监听器：</p><pre>chrome.runtime.onInstalled.addListener(function() {\n    // ERROR! Events must be registered synchronously from the start of\n    // the page.\n    chrome.bookmarks.onCreated.addListener(function() {\n      // do something\n    });\n  });</pre><p>扩展程序同时可以通过 removeListener 从后台脚本中删除侦听器，如果删除了某个事件的所有监听者， chrome 不会加载这个 active 事件的扩展程序的后台脚本。</p><pre>chrome.runtime.onMessage.addListener(function(message, sender, reply) {\n      chrome.runtime.onMessage.removeListener(event);\n  });</pre><p><h3>五、事件过滤\n</h3>使用支持事件过滤器的 API 来限制扩展程序关心场景的监听器。如果扩展程序正在监听 tabs.onUpdated 事件，需要使用带油过滤器的 webNavigation.onCompleted 事件，因为标签 API 不支持过滤器。&nbsp;<br></p><pre>chrome.webNavigation.onCompleted.addListener(function() {\n      alert(\"This is my favorite website!\");\n  }, {url: [{urlMatches : 'https://www.google.com/'}]});</pre><p><h3>六、事件监听器响应时间\n</h3>触发器是在事件触发之后去触发相应的功能，如果要对事件做出反应，需要在监听事件内部构件所需要的逻辑。</p><pre>chrome.runtime.onMessage.addListener((message, callback) =&gt; {\n    if (message.data == \"setAlarm\") {\n        chrome.alarms.create({ delayInMinutes: 5 })\n    } else if (message.data == \"runLogic\") {\n        chrome.tabs.executeScript({ file: 'logic.js' });\n    } else if (message.data == \"changeColor\") {\n        chrome.tabs.executeScript(\n            { code: 'document.body.style.backgroundColor=\"orange\"' });\n    };\n});</pre><p><h3>七、卸载 background scripts\n</h3>数据应当定期存储，以便于在没有收到 onSuspend 的情况下扩展程序 crash 的时候不会丢失重要的信息，可以使用 storage API 来解决这个问题。&nbsp;<br></p><p>&nbsp;<span style=\"background-color: rgb(241, 241, 241); font-family: &quot;Lucida Console&quot;, Consolas, Monaco; white-space: pre-wrap;\">chrome.storage.local.set({variable: variableInformation});</span><br></p><p>如果扩展程序使用 message passing，需要确保关闭所有的端口，在所有消息端口关闭之前，后台脚本不会卸载。<br>可以通过监听 runtime.Port.onDisconnect 事件，能够知道打开的端口什么时候关闭，使用 runtime.Port.disconnect 可以手动关闭这些端口。</p><pre>chrome.runtime.onMessage.addListener(function(message, callback) {\n    if (message == 'hello') {\n      sendResponse({greeting: 'welcome!'})\n    } else if (message == 'goodbye') {\n      chrome.runtime.Port.disconnect();\n    }\n  });</pre><p>通过监查看扩展程序何时出现在任务管理器已经什么时候从任务管理器中消息，能够知道后台脚本的生命周期。</p><p><img src=\"/app/json/applets/chrome/imgs/10.jpg\" style=\"max-width:100%;\"></p><p>点击 chrome 菜单，然后选择更多工具，打开任务管理器。</p><p>几秒钟不活动后，后台脚本会自行卸载。如果需要最后一分钟清理，需要监听 runtime.onSuspend 事件。</p><pre>chrome.runtime.onSuspend.addListener(function() {\n    console.log(\"Unloading.\");\n    chrome.browserAction.setBadgeText({text: \"\"});\n  });</pre><p>但是，依赖于 runtime.onSuspend，应该优先考虑持久化数据。<br>它不允许进行尽可能多的清理操作，并且在发生 crash 时无法提供帮助。</p><p><br></p><p><br></p>"}}