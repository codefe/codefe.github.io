{"sta":1,"data":{"subTitle":"用户界面与用户交互","content":"<h3>一、设计准则</h3><p>扩展程序的用户界面的设计准则是有目的性和最小型。这和扩展程序本身的设计准则是一样的，UI 应该增强体验而不会分散注意力。\n<br>\n<br><h3>二、在所有页面上都能使用扩展程序\n</h3>多数情况下，扩展程序正常调用时，可以使用 browser_action 配置一些行为\n<br>\n<br><h4>1、注册 browser_action\n</h4>browser_action 是在 manifest 中注册的：&nbsp;<br></p><pre>{\n    \"name\": \"My Awesome browser_action Extension\",\n    ...\n    \"browser_action\": {\n      ...\n    }\n    ...\n  }</pre><p>声明 browser_action 能够使工具栏的图标变成彩色，成为激活状态，用户能够使用这个扩展程序。\n<br>\n<br><h4>2、增加一个 badge\n</h4>badge 在浏览器图标顶部显示最多四个字符的彩色横幅。<br>它们只能由在其 manifest 中声明 browser_action 中使用。<br>badge 能够说明当前扩展的状态，下面的这个水滴示例说明已经成功设置了某种操作 ON 为开启状态，并且在扩展程序没有任何动作的时候，不会显示任何内容。&nbsp;<br></p><p><img src=\"/app/json/applets/chrome/imgs/11.jpg\" style=\"max-width:100%;\"></p><p>通过调用 chrome.browserAction.setBadgeBackgroundColor 设置 badge 的文本，调用 chrome.browserAction.setBadgeText 设置 banner 的颜色。\n<br>在 background.js 中写入下面的代码：</p><pre>chrome.browserAction.setBadgeText({text: 'ON'});\nchrome.browserAction.setBadgeBackgroundColor({color: '#4688F1'});</pre><p>最终效果：</p><p><img src=\"/app/json/applets/chrome/imgs/12.jpg\" style=\"max-width:100%;\"></p><p>需要注意的是，browser_action 和 page_action 并不能共存，只能存在一个<br>比如这里的完整 manifest 是：</p><pre>{\n    \"name\": \"Getting Started Example\",\n    \"version\": \"1.0\",\n    \"description\": \"Build an Extension!\",\n    \"permissions\": [\"storage\", \"declarativeContent\", \"activeTab\"],\n    \"background\": {\n      \"scripts\": [\"background.js\"],\n      \"persistent\": false\n    },\n    \"browser_action\":{\n        \"badge\": \"images/badge_off_example.png\"\n    },\n    \"icons\": {\n        \"16\": \"images/get_started16.png\",\n        \"32\": \"images/get_started32.png\",\n        \"48\": \"images/get_started48.png\",\n        \"128\": \"images/get_started128.png\"\n    },\n    \"manifest_version\": 2\n  }</pre><p><h3>三、在某些页面上激活扩展程序\n</h3>通过配置 page_action 可以选择在某些条件的页面中才能激活扩展程序（比如 react-devtool 和 vue-devtool 是这种类型）\n<br>\n<br><h4>1、声明 page_action\n</h4>manifest 中的 page_action 字段：</p><pre>{\n    \"name\": \"My Awesome page_action Extension\",\n    ...\n    \"page_action\": {\n      ...\n    }\n    ...\n  }</pre><p>声明 page_action 仅在扩展程序可供用户使用时才会着色图标，否则将以灰色显示。\n<br>\n<br><h4>2、定义扩展程序激活的条件\n</h4>可以通过在后台脚本中使用 runtime.onInstalled 这个事件监听中调用 chrome.declarativeContent，定义扩展程序可用规则。\n<br>\n<br>如果满足条件的话，可以调用 declarativeContent.showPageAction() 激活扩展程序。</p><pre>chrome.runtime.onInstalled.addListener(() =&gt; {\n    // 当 url 变更的时候，首先移除所有的规则\n    chrome.declarativeContent.onPageChanged.removeRules(undefined, () =&gt; {\n        // 增加新规则\n        chrome.declarativeContent.onPageChanged.addRules([\n            {\n                // 规则的条件是 URL 中包含 ptbird\n                conditions: [\n                    new chrome.declarativeContent.PageStateMatcher({\n                        pageUrl: { urlContains: 'ptbird' }\n                    })\n                ],\n                 // 如果负责规则进行的动作\n                 actions: [ new chrome.declarativeContent.ShowPageAction() ]\n            }\n        ])\n    })\n});</pre><p>上面插件调用之后，会发现，只有当我的页面跳转到 包含 ptbird 的页面的时候，才能激活扩展程序。\n<br>\n<br><h4>3、激活或禁用扩展程序\n</h4>使用 page_action 的扩展程序能够通过 pageAction.show 和 pageAction.hide 动态的激活和禁用。<br>当一个扩展程序依赖页面的内容或者其他页面相关的元素的时候，你是无法声明规则来预测使用哪些页面条件这个时候，就可以用到上面两个 API&nbsp;<br></p><pre>chrome.runtime.onMessage.addListener(function(req, sender) {\n    chrome.storage.local.set({'address': req.address})\n    chrome.pageAction.show(sender.tab.id);\n    chrome.pageAction.setTitle({tabId: sender.tab.id, title: req.address});\n  });</pre><p><h3>四、提供扩展程序的图标\n</h3>扩展程序至少需要一个图标来。提供 PNG 格式的图标有最佳的视觉效果，但 WebKit 支持的任何格式（包括BMP，GIF，ICO和JPEG）都可以使用。\n<br>\n<br><h4>1、指定工具栏的图标\n</h4>设定工具栏的图标在 manifest 中的 browser_action 或 page_action 下的 default_icon 字段中注册。\n<br>\n<br>可以同时设定多种尺寸，最小是 16x16 的，图标应该是正方形的，如果没有提供，chrome 会提供一个默认的图标。&nbsp;<br></p><pre>{\n    \"name\": \"My Awesome page_action Extension\",\n    ...\n    \"page_action\": {\n      \"default_icon\": {\n        \"16\": \"extension_toolbar_icon16.png\",\n        \"32\": \"extension_toolbar_icon32.png\"\n      }\n    }\n    ...\n  }</pre><p><h4>2、创建并且注册其他图标\n</h4>其他的图标是在 manifest 的 icons 中设置的，尺寸包含了下面几种：16x16，32x32, 48x48, 128x128&nbsp;<br></p><pre>{\n    \"name\": \"My Awesome Extension\",\n    ...\n    \"icons\": {\n      \"16\": \"extension_icon16.png\",\n      \"32\": \"extension_icon32.png\",\n      \"48\": \"extension_icon48.png\",\n      \"128\": \"extension_icon128.png\"\n    }\n    ...\n  }</pre><p><h3>五、其他 UI 特性\n</h3><h4>1、popup\n</h4>弹出窗口是一个HTML文件，当用户单击工具栏图标时，该文件将显示在特殊窗口中。<br>弹出窗口与网页的工作方式非常相似; 它可以包含 stylesheet 和 脚本标记的链接，但不允许内联 JavaScript。<br>popup 是在 manifest 中的 browser_action 或者是 page_action 中定义的：\n<br>\n</p><pre>\"browser_action\":{\n        \"default_popup\": \"popup.html\"\n},</pre><p>同时 popup 页面可以通过调用 browserAction.setPopup 和 pageAction.setPopup 来设置<br>比如实现一个 chrome 官方的水滴的例子：<br>popup.html</p><pre>&lt;html&gt;\n    &lt;head&gt;\n      &lt;title&gt;Water Popup&lt;/title&gt;\n      &lt;style&gt;\n        button {\n          width: 100%;\n          border:1px solid #FF5000;\n          background-color: #F2F2F2;\n          margin-top: 3px;\n        }\n      &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;img src='./images/badge_off_example.png' id='hydrateImage'&gt;\n        &lt;button id='sampleSecond' value='0.1'&gt;Sample Second&lt;/button&gt;\n        &lt;button id='15min' value='15'&gt;15 Minutes&lt;/button&gt;\n        &lt;button id='30min' value='30'&gt;30 Minutes&lt;/button&gt;\n        &lt;button id='cancelAlarm'&gt;Cancel Alarm&lt;/button&gt;\n     &lt;script src=\"popup.js\"&gt;&lt;/script&gt;\n    &lt;/body&gt;\n  &lt;/html&gt;</pre><p><img src=\"/app/json/applets/chrome/imgs/13.jpg\" style=\"max-width:100%;\"></p><p><h4>2、Tooltip\n</h4>tooltip 可以在鼠标悬停在浏览器图标上的时候，使用工具提示向用户提供简短说明\n<br>tooltip 可以在 browser_action 或者 page_action 上配置 default_title 字段：</p><p>&nbsp;<span style=\"background-color: rgb(241, 241, 241); font-family: &quot;Lucida Console&quot;, Consolas, Monaco; white-space: pre-wrap;\">{</span><br></p><pre>  \"name\": \"Tab Flipper\",\n   ...\n    \"browser_action\": {\n      \"default_title\": \"Press Ctrl(Win)/Command(Mac)+Shift+Right/Left to flip tabs\"\n    }\n  ...\n }</pre><p><img src=\"/app/json/applets/chrome/imgs/14.png\" style=\"max-width:100%;\"></p><p>tooltup 可以通过 browserAction.setTitle 和 pageAction.setTitle 设置</p><pre>chrome.browserAction.onClicked.addListener(function(tab) {\n    chrome.browserAction.setTitle({tabId: tab.id, title: \"You are on tab:\" + tab.id});\n  });</pre><p><h4>3、Omnibox\n</h4>通过可以通过 omnibox 多功能框调用扩展程序的功能，可以在 manifest 中设置 omnibox 来配置，多功能框新标签搜索示例扩展使用 \"nt\" 作为关键字。</p><pre>{\n    \"name\": \"Omnibox New Tab Search\",\n    ...\n    \"omnibox\": { \"keyword\" : \"nt\" },\n    \"default_icon\": {\n      \"16\": \"newtab_search16.png\",\n      \"32\": \"newtab_search32.png\"\n    }\n    ...\n  }</pre><p>当用户在多功能框中键入 nt 时，它会激活扩展程序。\n<br>要向用户发出此信号，它会将提供的 16x16 灰色图标，并将其包含在扩展名旁边的多功能框中。\n<br>\n<br><h4>4、Context Menu\n</h4>通过在 manifest 中配置 \"contextMenus\" 权限来添加新的上下文菜单选项。&nbsp;<br></p><p>&nbsp;<span style=\"background-color: rgb(241, 241, 241); font-family: &quot;Lucida Console&quot;, Consolas, Monaco; white-space: pre-wrap;\">{</span><br></p><pre>    \"name\": \"Global Google Search\",\n    ...\n    \"permissions\": [\"contextMenus\", \"storage\"],\n  }</pre><p>然后通过在后台脚本中调用 contextMenus.create 来创建上下文菜单。这应该在 runtime.onInstalled 监听器事件下完成。</p><pre>// 创建上下文菜单\nconst kLocales = {\n    'com.au': 'Australia',\n    'com.br': 'Brazil',\n    'ca': 'Canada',\n    'cn': 'China',\n    'fr': 'France',\n    'it': 'Italy',\n    'co.in': 'India',\n    'co.jp': 'Japan',\n    'com.ms': 'Mexico',\n    'ru': 'Russia',\n    'co.za': 'South Africa',\n    'co.uk': 'United Kingdom'\n  };\nchrome.runtime.onInstalled.addListener(() =&gt; {\n    for (let key of Object.keys(kLocales)) {\n        chrome.contextMenus.create({\n            id: key,\n            title: kLocales[key],\n            type: 'normal',\n            contexts: ['selection'],\n        });\n    }\n});</pre><p>所谓上下文菜单是与内容有关的，比如上面的代码中，当你选中了一个文字之后， 右击，就会出现我们自定义的上下文菜单。<br>当扩展程序包含多个上下文菜单时，Google Chrome会自动将其折叠为单个父菜单。</p><p><img src=\"/app/json/applets/chrome/imgs/15.jpg\" style=\"max-width:100%;\"></p><p><h4>5、Commands\n</h4>扩展程序可以定义特殊的命令并将它们绑定到快捷键中。<br>可以在 manifest 中的 commands 字段注册。</p><pre>{\n    \"name\": \"Tab Flipper\",\n    ...\n    \"commands\": {\n      \"flip-tabs-forward\": {\n        \"suggested_key\": {\n          \"default\": \"Ctrl+Shift+Right\",\n          \"mac\": \"Command+Shift+Right\"\n        },\n        \"description\": \"Flip tabs forward\"\n      },\n      \"flip-tabs-backwards\": {\n        \"suggested_key\": {\n          \"default\": \"Ctrl+Shift+Left\",\n          \"mac\": \"Command+Shift+Left\"\n        },\n        \"description\": \"Flip tabs backwards\"\n      }\n    }\n    ...\n  }</pre><p>commands 可用于提供新的或替代的浏览器快捷方式，可以使用快捷键直接打开扩展程序。\n<br>\n<br><h4>6、Override Pages\n</h4>扩展程序可以覆盖并替换历史记录、包含自定义HTML文件的新标签页或书签网页。<br>popup，它可以包含专门的逻辑和样式，但不允许内联 JavaScript。<br>单个扩展程序仅限于覆盖三个可能页面中的一个。<br>在 manifest 的 chrome_url_overrides 字段下注册覆盖页面。</p><pre>{\n    \"name\": \"Awesome Override Extension\",\n    ...\n\n    \"chrome_url_overrides\" : {\n      \"newtab\": \"override_page.html\"\n    },\n    ...\n  }</pre><p>覆盖这些页面时，newtab 字段应替换为 bookmarks 或 history。\n<br>\n<br>override_page.html</p><pre>&lt;html&gt;\n   &lt;head&gt;\n    &lt;title&gt;New Tab&lt;/title&gt;\n   &lt;/head&gt;\n   &lt;body&gt;\n      &lt;h1&gt;Hello World&lt;/h1&gt;\n    &lt;script src=\"logic.js\"&gt;&lt;/script&gt;\n   &lt;/body&gt;\n  &lt;/html&gt;</pre><p><br></p>"}}