{"sta":1,"data":{"subTitle":"chrome.history 控制浏览器历史","content":"<h3>一、描述</h3><p>使用 chrome.history API可以操作浏览器访问过的页面记录。<br>可以在浏览器的历史记录中添加，删除和查询URL<br>权限申请：<br><blockquote> \"permissions\": [\"history\"],\n</blockquote>history API 通过 transition type 来描述浏览器如何在特定的访问中跳转到某个 URL，比如，如果用户通过单击另一页面上的链接来访问的页面，则 transition API 是 link\n<br>\n<br>下面是对每个 transition type 的描述：<br><blockquote>link: 通过点击一个链接跳转到页面<br>\ntyped：用户在浏览器地址栏中输入了一个地址，打开页面<br>\nauto_bookmark： 通过菜单项进入页面（比如通过 UI 中的一个菜单）<br>\nauto_subframe：子框架导航。这是在非顶级框架中自动加载的任何内容。例如，如果一个页面包含多个广告的 frame，则这些广告网址具有此 transition 类型。用户可能甚至没有意识到这些页面中的内容是一个单独的框架，因此可能不关心URL<br>\nmanual_subframe：对于用户明确请求的子 frame 导航，并在后/前列表中生成新的导航条目。显式请求的 frame 可能比自动加载的 frame 更重要，因为用户可能关心所请求的 frame 加载的事实。<br>\ngenerated：用户通过在地址栏中键入并选择一个看起来不像 URL 的条目来到达页面。例如，匹配可能包含Google搜索结果页的网址，但用户可能会将其显示为 \"搜索Google for ...\"，这些与键入的 URL 并不完全相同，因为用户没有键入或查看目标URL。<br>\nauto_toplevel： 页面在命令行中指定或是浏览器的起始页面。<br>\nform_submit：用户在表单中填写值并提交。注意，在某些情况下，比如表单使用 javascript 提交内容时 - 提交表单不会有这个 transition type<br>\nreload：用户通过单击重新加载按钮或在地址栏中按Enter键重新加载页面。会话还原和重新打开关闭选项卡也使用这个 transition type<br>\nkeyword：该 URL 是从默认搜索提供程序以外的可替换关键字生成的。<br>\nkeyword_generated： 对应于为关键字生成的访问，和 keyword 差不多\n</blockquote><h3>二、属性说明\n</h3><h4>1、TransitionType\n</h4>说明在上面，可取值如下：<br><blockquote>\"link\", \"typed\", \"auto_bookmark\", \"auto_subframe\", \"manual_subframe\", \"generated\", \"auto_toplevel\", \"form_submit\", \"reload\", \"keyword\", or \"keyword_generated\"\n</blockquote><h4>2、HistoryItem</h4></p><p>封装浏览器历史查询的结果的对象\n<br>\n</p><table border=\"0\" width=\"100%\" cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><th><span style=\"font-weight: normal;\">属性</span>&nbsp;</th><th><span style=\"font-weight: normal;\">描述</span>&nbsp;</th></tr><tr><td>&nbsp;id</td><td>&nbsp;item 唯一 id</td></tr><tr><td>&nbsp;url</td><td>&nbsp;用户跳转的 url</td></tr><tr><td>&nbsp;title</td><td>&nbsp;页面最近一次加载的标题</td></tr><tr><td>&nbsp;lastVisitTime</td><td>&nbsp;上次加载此页面时的时间戳</td></tr><tr><td>&nbsp;visitCount</td><td>&nbsp;用户到页面的次数</td></tr><tr><td>&nbsp;typedCount</td><td>&nbsp;用户通过输入 URL 地址到这个页面的次数，见上面的 typed</td></tr></tbody></table><p><h4>3、VisitItem\n</h4>封装的访问 URL 的对象</p><table border=\"0\" width=\"100%\" cellpadding=\"0\" cellspacing=\"0\"><tbody><tr><th><span style=\"font-weight: normal;\">属性</span>&nbsp;</th><th><span style=\"font-weight: normal;\">描述</span>&nbsp;</th></tr><tr><td>&nbsp;id</td><td>&nbsp;history 的 id</td></tr><tr><td>&nbsp;visitId</td><td>&nbsp;访问的 id</td></tr><tr><td>&nbsp;visitTime</td><td>&nbsp;访问时间，时间戳</td></tr><tr><td>&nbsp;referringVisitId</td><td>&nbsp;referrer 的 visit id</td></tr><tr><td>&nbsp;transition</td><td>&nbsp;transition type</td></tr></tbody></table><p><h3>三、方法使用\n</h3><h4>1、chrome.history.search(object query, function callback)\n</h4>在历史记录中搜索与查询匹配的每个页面的上次访问记录<br>注意 query 参数，text 字段是必不可少的，但是 text 可以留空，相当于一个 keyword</p><p>&nbsp;<span style=\"background-color: rgb(241, 241, 241); font-family: &quot;Lucida Console&quot;, Consolas, Monaco; white-space: pre-wrap;\">const query = {</span></p><pre>        text: ''\n    };\n    chrome.history.search(query, (res) =&gt; {\n        console.log(res);\n    })</pre><p>下面代码中我取出前三条然后绘制在 chrome 扩展页面中</p><pre>const query = {\n    text: ''\n};\nchrome.history.search(query, (res) =&gt; {\n    const arr = res.slice(0,3).map((item) =&gt; {\n        return item\n    });\n    let htm = '';\n    arr.forEach(element =&gt; {\n        htm += `&lt;p&gt;&lt;a href=\"${element.url}\"&gt;${element.title}&lt;a/&gt;&lt;/p&gt;`;\n    });\n    document.querySelector('#scroll').innerHTML = htm;\n})</pre><p><h4>2、chrome.history.getVisits(object details, function callback)\n</h4>检索某个 URL 的访问信息</p><p>&nbsp;<span style=\"background-color: rgb(241, 241, 241); font-family: &quot;Lucida Console&quot;, Consolas, Monaco; white-space: pre-wrap;\">const details = {</span></p><pre>    url: 'http://ptbird.cn'\n};\nchrome.history.getVisits(details, (res) =&gt; {\n    const arr = res.slice(0,3).map((item) =&gt; {\n        return item\n    });\n    let htm = '';\n    arr.forEach(element =&gt; {\n        htm += `&lt;p&gt;transition: ${element.transition}&lt;/p&gt;`;\n    });\n    document.querySelector('#scroll').innerHTML = htm;\n})</pre><p><h4>3、chrome.history.addUrl(object details, function callback)\n</h4>使用 transition type link 向历史记录中添加一条记录</p><p>&nbsp;<span style=\"background-color: rgb(241, 241, 241); font-family: &quot;Lucida Console&quot;, Consolas, Monaco; white-space: pre-wrap;\">onst details = {</span></p><pre>    url: 'http://ptbird.cn/chrome_extensions_aaa_2-s_as'\n};\nchrome.history.addUrl(details, (res) =&gt; {\n    console.log(res);\n})</pre><p><h4>4、chrome.history.deleteUrl(object details, function callback)\n</h4>从历史记录中删除所有出现的给定URL</p><pre>const details = {\n    url: 'http://ptbird.cn/chrome_extensions_aaa_2-s_as'\n};\nchrome.history.deleteUrl(details, (res) =&gt; {\n    console.log(res);\n})</pre><p>结果可以发现，我删除了历史记录后，再去查找就找不到了</p><p><h4>5、chrome.history.deleteRange(object range, function callback)\n</h4>从历史记录中删除指定日期范围内的所有项目。除非所有访问都在此范围内，否则页面不会从历史记录中删除。</p><pre>const startTime = Date.now() - 50000;\nconst endTime = Date.now();\nconst query = {\n    startTime,\n    endTime\n};\nchrome.history.deleteRange(query, (res) =&gt; {\n    console.log(res);\n})</pre><p><h4>6、chrome.history.deleteAll(function callback)\n</h4>删除历史记录中的所有项目。</p><pre>chrome.history.deleteAll((res) =&gt; {\n       console.log(res);\n    })</pre><p><br></p><p><br></p>"}}