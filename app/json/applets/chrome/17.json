{"sta":1,"data":{"subTitle":"运行时脚本 content scripts","content":"<h3>一、描述</h3><p>content scripts 实际上是可以在网页的上下文中使用的 scripts，通过使用 DOM，能够读取浏览器访问的当前网页的详细信息，并且能够将信息传递到他们之上的扩展程序中。\n<br>\n<br><h3>二、content scripts 的功能\n</h3>content scripts 脚本可以通过和扩展程序消息传递来访问它们的 parent extension（还是英文表述清楚一些）使用的 chrome 的 API。<br>它们还可以使用 chrome.runtime.getURL() 方法访问扩展程序文件的 URL, 并且使用与其他 URL 相同的结果。&nbsp;<br></p><pre>//Code for displaying &lt;extensionDir&gt;/images/myimage.png:\n  var imgURL = chrome.runtime.getURL(\"images/myimage.png\");\n  document.getElementById(\"someImage\").src = imgURL;</pre><p>除此之外，内容脚本还可以使用如下的 chrome 的 API</p><pre>i18n\nstorage\nruntime\n\nconnect\ngetManifest\ngetURL\nid\nonConnect\nonMessage\nsendMessage</pre><p>除了上面的 API 之外，内容脚本无法直接访问其他的 API\n<br>\n<br><h3>三、独立的运行环境\n</h3>content scripts 有一个独立的运行环境，内容脚本可以在其本身的 js 环境作变动，不会与页面和其他的内容脚本冲突。<br>一个扩展程序可以在 web 网页中运行，其代码类似于下面示例：</p><pre>&lt;html&gt;\n    &lt;button id=\"mybutton\"&gt;click me&lt;/button&gt;\n    &lt;script&gt;\n      var greeting = \"hello, \";\n      var button = document.getElementById(\"mybutton\");\n      button.person_name = \"Bob\";\n      button.addEventListener(\"click\", function() {\n        alert(greeting + button.person_name + \".\");\n      }, false);\n    &lt;/script&gt;\n  &lt;/html&gt;</pre><p>当然，也可以单独抽离出 content script，然后注入进去：</p><pre>var greeting = \"hola, \";\n  var button = document.getElementById(\"mybutton\");\n  button.person_name = \"Roberto\";\n  button.addEventListener(\"click\", function() {\n    alert(greeting + button.person_name + \".\");\n  }, false);</pre><p>环境隔离原则，不允许内容脚本、扩展程序和忘了访问其他人创建的任何变量或者功能，这也使内容脚本能够启用网页无法访问的功能。\n<br>\n<br><h3>四、注入脚本\n</h3>内容脚本可以以编程方式或声明性方式注入。\n<br>\n<br><h4>1、通过编程方式注入\n</h4>对需要在特定场合运行的内容脚本，可以使用编程注入。\n<br>\n<br>如果要注入编程内容脚本，需要在 manifest 中提供 activeTab 的权限。这将授予对 active 的站点主机的安全访问权限以及对选项卡的临时访问权限，从而使内容脚本能够在当前 active 选项卡上运行，无需指定跨域权限。&nbsp;<br></p><pre>{\n    \"name\": \"My extension\",\n    ...\n    \"permissions\": [\n      \"activeTab\"\n    ],\n    ...\n  }</pre><p>content script 能够通过代码的形式直接被注入</p><pre>chrome.runtime.onMessage.addListener(\n    function(message, callback) {\n      if (message == \"changeColor\"){\n        chrome.tabs.executeScript({\n          code: 'document.body.style.backgroundColor=\"orange\"'\n        });\n      }\n   });</pre><p>当然你也可以注入整个 js 文件：</p><pre>chrome.runtime.onMessage.addListener(\n    function(message, callback) {\n      if (message == \"runContentScript\"){\n        chrome.tabs.executeScript({\n          file: 'contentScript.js'\n        });\n      }\n   });</pre><p><h4>2、声明式的注入\n</h4>声明式注入可以指定在某个页面上运行内容脚本。<br>声明式注入的方式是在 manifest 文件中的 content_scripts 字段下面注册：&nbsp;<br></p><pre>{\n \"name\": \"My extension\",\n ...\n \"content_scripts\": [\n   {\n     \"matches\": [\"http://*.nytimes.com/*\"],\n     \"css\": [\"myStyles.css\"],\n     \"js\": [\"contentScript.js\"]\n   }\n ],\n ...\n}</pre><p>声明可以是一个列表，列表的每个元素一般会使用下面几个字段： matches、css、js、match_about_blank。<br>其中 matches 可以匹配在符合条件的页面中注入 content scripts，更多的匹配规则可以在https://developer.chrome.com/extensions/match_patterns 找到。 matches 这个字段是必须要传入的<br>css 是可选字段，注入一个 css 样式列表，在页面渲染或者DOM显示之前，会依次按照顺序注入。<br>js 是可选字段，注入 js 列表，是按照数组顺序依次注入。<br>match_about_blank，bool 类型，是否需要对 about:blank 页面进行注入，默认是 false。\n<br>\n<br><h4>3、排除条件匹配或全局匹配\n</h4>上面说了 content_scripts 的每个匹配项都有一个 matches 来符合这个匹配条件，但是除此之外，我们可能需要更加复杂的条件，比如出去某个符合条件的字段，这样的相关的字段包括：exclude_matches 、 include_globs、exclude_globs<br>只要 URL 不匹配 exclude_matches 或 exclude_globs 模式，这个条件下如果 URL 匹配任何 matches 模式和任何 include_globs 模式，则内容脚本将注入页面。<br>由于 matches 属性是必需的，因此 exclude_matches，include_globs 和 exclude_globs 只能用于限制受影响的页面。<br>举例说明 exclude_matches：<br>比如一个扩展程序将内容脚本注入 http://www.xxx.com/health ，但不会注入 http://www.xxx.com/business 的匹配模式可以这么写：&nbsp;<br></p><pre>{\n  \"name\": \"My extension\",\n  ...\n  \"content_scripts\": [\n    {\n      \"matches\": [\"http://*.xxx.com/*\"],\n      \"exclude_matches\": [\"*://*/*business*\"],\n      \"js\": [\"contentScript.js\"]\n    }\n  ],\n  ...\n}</pre><p>\n<br>而 glob 属性则是更加灵活的语法，和 matches 是不同的，可以接受的 glob 字符串是可能包含 通配符 星号（*）和问号（?）的 URL,星号（*）匹配任何长度的任何字符串，包括空字符，而问号（？）匹配任何的单个字符。\n<br>\n<br>举例说明，glob http://???.example.com/foo* 能够匹配下面两个链接：<br><blockquote>http:// www.example.com/foo/ bar<br>\nhttp:// the.example.com/foo/\n</blockquote>但是他不能匹配下面3个地址：<br><blockquote>http:// my .example.com/foo/bar<br>\nhttp:// example .com/foo/<br>\nhttp://www.example.com/foo  \n</blockquote>因此在下面的 manifest 配置中 能够将内容脚本注入到 http:/www.xxx.com/ arts /index.html 和 http://www.xxx.com/ jobs /index.html，但是不会注入到 http://www.xxx.com/ sports /index.html：</p><pre>{\n  \"name\": \"My extension\",\n  ...\n  \"content_scripts\": [\n    {\n      \"matches\": [\"http://*.xxx.com/*\"],\n      \"include_globs\": [\"*xxx.com/???s/*\"],\n      \"js\": [\"contentScript.js\"]\n    }\n  ],\n  ...\n}</pre><p><h4>4、runtime\n</h4>将 JavaScript 文件注入网页时，由 run_at 字段控制，而默认的值是 document_idle，不过如果需要的话也可以指定为 document_start 和 document_end。</p><p>&nbsp;<span style=\"background-color: rgb(241, 241, 241); font-family: &quot;Lucida Console&quot;, Consolas, Monaco; white-space: pre-wrap;\">{</span><br></p><pre>  \"name\": \"My extension\",\n  ...\n  \"content_scripts\": [\n    {\n      \"matches\": [\"http://*.xxx.com/*\"],\n      \"run_at\": \"document_idle\",\n      \"js\": [\"contentScript.js\"]\n    }\n  ],\n  ...\n}</pre><p>\n<br>document_idle: 首选值，能够在 document_end 和 window.onload 结束之后立即注入内容脚本\n<br>document_start：在 css 之后，在任何的 DOM 渲染或者 js 脚本之前注入\n<br>document_end: document 完成之后，但是在图像和帧动画之前注入\n<br><h4>5、指定 frame\n</h4>在 content_scripts 的 all_frames 配置成 true 可以将 content scripts 注入到所有的 frame 中。<br>默认值是 false，只能注册到最顶部的 frame 中&nbsp;<br></p><p>&nbsp;<span style=\"background-color: rgb(241, 241, 241); font-family: &quot;Lucida Console&quot;, Consolas, Monaco; white-space: pre-wrap;\">{</span></p><pre>  \"name\": \"My extension\",\n  ...\n  \"content_scripts\": [\n    {\n      \"matches\": [\"http://*.xxx.com/*\"],\n      \"all_frames\": true,\n      \"js\": [\"contentScript.js\"]\n    }\n  ],\n  ...\n}</pre><p>\n<br><h3>五、嵌入页面的通信\n</h3>虽然内容脚本的执行环境和托管它们的页面彼此隔离，但它们共享对页面 DOM 的访问。<br>如果页面希望与内容脚本通信，或者通过内容脚本与扩展通信，则必须通过共享 DOM 进行通信。<br>可以使用 window.postMessage 完整一个 example：<br>contentscript.js</p><pre>var port = chrome.runtime.connect();\n\nwindow.addEventListener(\"message\", function(event) {\n  // We only accept messages from ourselves\n  if (event.source != window)\n    return;\n\n  if (event.data.type &amp;&amp; (event.data.type == \"FROM_PAGE\")) {\n    console.log(\"Content script received: \" + event.data.text);\n    port.postMessage(event.data.text);\n  }\n}, false);</pre><p>example.html</p><pre>document.getElementById(\"theButton\").addEventListener(\"click\",\n    function() {\n  window.postMessage({ type: \"FROM_PAGE\", text: \"Hello from the webpage!\" }, \"*\");\n}, false);</pre><p>非扩展程序页面页面 example.html将消息发给自己。内容脚本拦截并检查此消息，然后将其发布到扩展程序的进程。<br>通过这种方式，页面建立了与扩展程序的通信线路，这个方式也可以反过来。\n<br>\n<br><h3>六、安全性保证\n</h3>虽然隔离环境提供了一层保护，但使用内容脚本可能会在扩展程序和网页中产生漏洞。如果内容脚本从单独的网站接收内容（例如创建 XMLHttpRequest ），请在注入之前小心过滤 XSS 攻击。仅通过 HTTPS 进行通信，以避免“中间人”攻击。<br>务必过滤恶意网页。例如，以下模式是危险的：</p><pre>var data = document.getElementById(\"json-data\")\n// WARNING! Might be evaluating an evil script!\nvar parsed = eval(\"(\" + data + \")\")\n\nvar elmt_id = ...\n// WARNING! elmt_id might be \"); ... evil script ... //\"!\nwindow.setTimeout(\"animate(\" + elmt_id + \")\", 200);</pre><p>\n\n</p><p>应该使用不执行脚本的更安全的 API：</p><pre>var data = document.getElementById(\"json-data\")\n// JSON.parse does not evaluate the attacker's scripts.\nvar parsed = JSON.parse(data);\n\n\nvar elmt_id = ...\n// The closure form of setTimeout does not evaluate scripts.\nwindow.setTimeout(function() {\n  animate(elmt_id);\n}, 200);</pre><p><br></p><p><br></p>"}}