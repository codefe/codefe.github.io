{"sta":1,"data":{"subTitle":"chrome.storage 本地存储","content":"<h3>一、描述</h3><p>在扩展程序中本地存储数据可以通过 chrome.storage API 实现，和 web 中的 localstorage 在某些方面是有区别的，chrome.storage 已经做了优化。<br><h4>与 localStorage 的区别：</h4>用户数据可以与 chrome 自动同步（通过 storage.sync）,只要用户登录了 chrome 账号，则能够全量同步浏览器\n<br>扩展程序的脚本能够直接访问用户的数据，不需要通过 background js\n<br>即使使用 split 隐身行为，也可以保留用户的扩展程序设置\n<br>异步批量读写操作，比阻塞和串行的 localStorage 更快\n<br>用户数据可以存储对象（localStorage 是将对象 string 到字符串中）\n<br>可以读取管理员为扩展配置的企业策略（使用带有模式的 storage.managed 做 schema）\n<br><h3>二、权限申请\n</h3>如果要使用 chrome.storage 则需要在 manifest 的 permissions 申请：</p><pre>{\n        \"name\": \"My extension\",\n        ...\n        \"permissions\": [\n          \"storage\"\n        ],\n        ...\n      }</pre><p><h3>三、local 与 sync 的使用不同\n</h3>使用 storage.sync 时，如果用户启用了同步，则存储的数据将自动同步到用户登录的任何 Chrome 浏览器。\n<br>\n<br>当 Chrome 处于离线状态时，Chrome 会在本地存储数据。下次浏览器在线时，Chrome 会同步数据。即使用户禁用同步，storage.sync 仍然可以工作。在这种情况下，它的行为与 storage.local 相同。\n<br>\n<br>storage.managed 是只读的<br>存储是未加密的，不能存储机密信息\n<br>\n<br><h4>1、chrome.storage.sync\n</h4>如果需要将存储的内容同步到所有登录了同一账号的 chrome 浏览器中，可以通过 chrome.storage.sync：&nbsp;<br></p><pre>// popup.js\nbutton.onclick = () =&gt; {\n    chrome.storage.sync.set({key: 'value11'}, () =&gt; {\n        console.log('set successed!');\n    });\n}\n\nbutton2.onclick = () =&gt; {\n    chrome.storage.sync.get('key', (res) =&gt; {\n        console.log(res);\n    });\n}</pre><p>结果示例：</p><p><img src=\"/app/json/applets/chrome/imgs/32.jpg\" style=\"max-width:100%;\"></p><h4>2、chrome.storage.local</h4><pre>button3.onclick = () =&gt; {\n    chrome.storage.local.set({key: \"value local\"}, function() {\n        console.log('Value is set to ' + value);\n    });\n\n    chrome.storage.local.get(['key'], function(result) {\n        console.log('Value currently is ' + result.key);\n    });\n}</pre><p>结果示例：</p><p><img src=\"/app/json/applets/chrome/imgs/33.jpg\" style=\"max-width:100%;\"></p><p><h3>四、存储限制\n</h3>chrome.storage 的存储是有限制的，类似一个管道。\n<br>\n<br>当管道满了之后，就会排队，因此可能无法继续存储。\n<br>\n<br><h3>五、使用示例及存储对象变更监听\n</h3>存储内容变更之后，是能够监听到事件的，比如我做了下面的存储。</p><pre>const text = textarea.value;\n    chrome.storage.local.set({'textValue': text}, function() {\n        console.log('Value is ' + text);\n    });</pre><p>可以通过如下监听：</p><pre>chrome.storage.onChanged.addListener(function(changes, namespace) {\n        for (var key in changes) {\n          var storageChange = changes[key];\n          console.log('Storage key \"%s\" in namespace \"%s\" changed. ' +\n                      'Old value was \"%s\", new value is \"%s\".',\n                      key,\n                      namespace,\n                      storageChange.oldValue,\n                      storageChange.newValue);\n        }\n      });</pre><p><h3>六、API 示例\n</h3>set 和 get 上面已经有了，不重复<br>remove 和 get 两个方法均支持 单个参数或者是数组形式的参数<br><h4>1、remove</h4></p><pre>button6.onclick = () =&gt; {\n    chrome.storage.local.remove('textValue', function() {\n        console.log('remove ');\n    });\n}</pre><h4>2、clear</h4><pre>button7.onclick = () =&gt; {\n    chrome.storage.local.clear(function() {\n        console.log('remove all ');\n    });\n}</pre><p><br></p><p><br></p>"}}