{"sta":1,"data":{"subTitle":"消息传递","content":"<p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"></divcourier></p><h3>一次简单的请求</h3><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\">如果仅需要给你自己的扩展的另外一部分发送一个消息（可选的是否得到答复），你可以简单地使用chrome.extension.sendRequest()或者chrome.tabs.sendRequest()方法。这个方法可以帮助你传送一次JSON序列化消息从content&nbsp;script到扩展，反之亦然。如果接受消息的一方存在的话，可选的回调参数允许处理传回来的消息。<br></divcourier></p><p><divcourier new',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"></divcourier></p><p>sendRequest() 是Chrome33之前的API，33之后还是使用sendMessage()吧。</p><p>1. 内容脚本发送消息到扩展程序</p><pre>chrome.extension.sendMessage({hello: \"Cissy\"}, function(response) {\n    console.log(response.farewell);\n});</pre><p>2. 扩展程序发送消息到内容脚本</p><pre>chrome.tabs.sendMessage(tab.id, {hello: \"Cissy\"}, function(response) {\n    console.log(response.farewell);\n});</pre><p>3. 接收消息</p><p>chrome.extension.sendMessage()向扩展内的其它监听者发送一条消息。此消息发送后会触发扩展内每个页面的chrome.extension.onMessage()事件。</p><h3>长时间的保持连接</h3><p><h4>background 和 popup\n</h4>同一个Extension的Extension Page（包括background、popup、tab、infobar、notification）都是运行在同一个进程中的，所以background 和 popup 之间可以直接相互调用对方的方法，不需要消息传递。</p><p>1. popup调用background中变量或方法</p><pre>var bg = chrome.extension.getBackgroundPage();//获取background页面\nconsole.log(bg.a);//调用background的变量或方法。</pre><p>2. background调用popup中变量或方法</p><pre>var pop = chrome.extension.getViews({type:'popup'});//获取popup页面\nconsole.log(pop[0].b);//调用第一个popup的变量或方法。</pre><p>这里要注意一定要指明type,如果没有指定，则获取Background Page之外的所有Extension Page的window对象 。(｡•ˇ‸ˇ•｡)这个地方真的纠结好久。然后就是background是一个运行在扩展进程中的HTML页面。它在你的扩展的整个生命周期都存在，而popup是在你点击了图标之后才存在，所以，在获取popup变量时，请确认popup已打开。</p><h4>background 和 content</h4><p>持续长时间的保持会话需要在content script和扩展建立一个长时间存在的通道。当建立连接，两端都有一个Port 对象通过这个连接发送和接收消息。</p><p>1. 内容脚本发送消息到扩展程序</p><pre>var bac = chrome.extension.connect({name: \"ConToBg\"});//建立通道，并给通道命名\nbac.postMessage({hello: \"Cissy\"});//利用通道发送一条消息。</pre><p>2. 扩展程序发送消息到内容脚本</p><p>扩展程序发送消息到内容脚本与前面类似，但需要指定哪个标签需要连接</p><pre>chrome.tabs.onUpdated.addListener(function(tabId, changeInfo, tab) {//获取当前Tab\n    var cab = chrome.tabs.connect(tabId, {name: \"BgToCon\"});//建立通道，指定tabId，并命名\n    cab.postMessage({ hello: \"Cissy\"});//利用通道发送一条消息。\n}</pre><p>3. 接收消息</p><p>为了处理正在等待的连接，需要用chrome.extension.onConnect 事件监听器，对于content script或者扩展页面，这个方法都是一样的</p><pre>chrome.extension.onConnect.addListener(function(bac) {//监听是否连接，bac为Port对象\n    bac.onMessage.addListener(function(msg) {//监听是否收到消息，msg为消息对象\n        console.log(msg.hello);\n    })\n})</pre><p><br></p><p><br></p><p><br></p>"}}