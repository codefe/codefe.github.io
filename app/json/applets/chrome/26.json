{"sta":1,"data":{"subTitle":"chrome.downloads 通过程序控制下载","content":"<h3>一、说明及权限申请</h3><p>chrome.downloads API 能够通过扩展程序以编程的方式启动、监听或者是搜索下载相关的信息以及下载具体文件。<br>权限申请：<br><blockquote> \"permissions\": [ \"downloads\"],\n</blockquote><h3>二、属性及其值\n</h3><h4>1、FilenameConflictAction\n</h4>文件名冲突的处理方式，Enum 类型，可选值包括 uniquify、overwrite、prompt：<br><blockquote>uniquify：如果冲突了在文件后缀的前面加上计数，比如 filename1.jpg, filename2.jpg<br>\noverwrite: 新文件覆盖旧的文件<br>\nprompt：用户会受到一个 dialog 确认操作\n</blockquote><h4>2、InterruptReason\n</h4>表示文件下载中断的原因：<br><blockquote>\"FILE_FAILED\", \"FILE_ACCESS_DENIED\", \"FILE_NO_SPACE\", \"FILE_NAME_TOO_LONG\", \"FILE_TOO_LARGE\", \"FILE_VIRUS_INFECTED\", \"FILE_TRANSIENT_ERROR\", \"FILE_BLOCKED\", \"FILE_SECURITY_CHECK_FAILED\", \"FILE_TOO_SHORT\", \"FILE_HASH_MISMATCH\", \"FILE_SAME_AS_SOURCE\", \"NETWORK_FAILED\", \"NETWORK_TIMEOUT\", \"NETWORK_DISCONNECTED\", \"NETWORK_SERVER_DOWN\", \"NETWORK_INVALID_REQUEST\", \"SERVER_FAILED\", \"SERVER_NO_RANGE\", \"SERVER_BAD_CONTENT\", \"SERVER_UNAUTHORIZED\", \"SERVER_CERT_PROBLEM\", \"SERVER_FORBIDDEN\", \"SERVER_UNREACHABLE\", \"SERVER_CONTENT_LENGTH_MISMATCH\", \"SERVER_CROSS_ORIGIN_REDIRECT\", \"USER_CANCELED\", \"USER_SHUTDOWN\", or \"CRASH\"\n</blockquote><h4>3、DangerType\n</h4>可选值：<br><blockquote>\"file\", \"url\", \"content\", \"uncommon\", \"host\", \"unwanted\", \"safe\", or \"accepted\"\n</blockquote><blockquote>file: 下载的文件名是可疑的<br>\nurl：已知下载的 URL 是恶意的<br>\ncontent：已知下载的内容是恶意的<br>\nuncommon：下载的 URL 可能是危险的，一般不会选择下载<br>\nhost：从一个恶意主机下载文件<br>\nunwanted：下载的文件不受欢迎或者是不安全的，能够更改计算机的配置等<br>\nsafe：下载的文件已知没有危险<br>\naccepted: 用户同意下载危险软件\n</blockquote><h4>4、State\n</h4>Enum 可选值：<br><blockquote>\"in_progress\", \"interrupted\", or \"complete\"\n</blockquote><blockquote>in_progress: 正在从服务端接受数据中<br>\ninterrupted: 下载中断，出现错误<br>\ncomplete: 下载成功且已经完成\n</blockquote><h3>三、方法\n</h3><h4>1、chrome.downloads.download(object options, function callback)\n</h4>通过一个 URL 下载文件，如果使用的是 HTTP[S] 会将主机的 cookie 带上去。如果同时指定了 filename 和 saveAs，会显示 另存为 的对话框，并且使用指定的文件名进行填充。<br>如果下载成功，会使用新的 DownloadItem 的 download 调用回调。<br>如果开始下载时出错，则将使用 downloadId = undefined 调用会掉， runtime.lastError 将包含描述性字符串。<br>错误信息不保证向后兼容，因此扩展程序不能去解析这个错误信息。<br>下面是最简单的调用方式，初次之外，还可以指定 filename、conflictAction 或者是 method 等等\n<br>\n<br>方法调用：</p><pre>btn1.onclick = () =&gt; {\n    const url = document.querySelector('#url').value;\n    const options = {\n        url\n    }\n    chrome.downloads.download(options, (res) =&gt; {\n        console.log(res);\n    })\n};</pre><p>结果示例：<br>可以发现每次默认的文件名冲突就是通过加 counter 的方式解决的</p><p><img src=\"/app/json/applets/chrome/imgs/43.jpg\" style=\"max-width:100%;\"></p><p><h4>2、chrome.downloads.search(object query, function callback)\n</h4>查找可供下载的对象，如果参数 query 是空对象，则会查找所有能够下载的对象，如果只需要获取特定的可下载对象，可以通过设置 id 参数。<br>如果要查找大量项目，可以通过 orderBy:['-startTime'] 设置每页的项目数，并且将 startedAfter 设置为最后一页中最后一项的 startTime。</p><p>代码示例：</p><pre>btn2.onclick = () =&gt; {\n    const options = { }\n    chrome.downloads.search(options, (res) =&gt; {\n        console.log(res);\n    })\n};</pre><p>结果：</p><p><img src=\"/app/json/applets/chrome/imgs/44.jpg\" style=\"max-width:100%;\"></p><p>如果只是查询 zip 结尾的文件：</p><pre>btn2.onclick = () =&gt; {\n    const options = {\n        finalUrlRegex: '.zip$'\n     }\n    chrome.downloads.search(options, (res) =&gt; {\n        console.log(res);\n    })\n};</pre><p>结果：</p><p><img src=\"/app/json/applets/chrome/imgs/45.jpg\" style=\"max-width:100%;\"></p><p><h4>3、chrome.downloads.pause(integer downloadId, function callback)\n</h4>暂停下载，如果请求成功，则下载处于暂停状态。否则 runtime.lastError 包含错误消息。如果下载未激活，请求将失败。</p><pre>chrome.downloads.pause(id, (res) =&gt;{\n            console.log(res);\n        });</pre><p><h4>4、chrome.downloads.resume(integer downloadId, function callback)\n</h4>恢复暂停的下载。如果请求成功，则下载正在进行且取消暂停。否则 runtime.lastError 包含错误消息。如果下载未激活，请求将失败。\n<br>扩展程序选项更多\n<br>\n<br><h4>5、chrome.downloads.cancel(integer downloadId, function callback)\n</h4>取消下载。运行回调时，下载将被取消，完成，中断或不再存在。</p><p><br></p><p><br></p>"}}