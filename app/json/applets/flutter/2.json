{"sta":1,"data":{"subTitle":"StatelessWidget与StatefulWidget的选择","content":"<p>状态是在构建widget时可以同步读取的信息，或者在widget的生命周期中可能更改的信息，在Flutter中如果要管理状态需要用到 StatefulWidget。</p><p><h3>一. 什么是StatelessWidget？\n</h3>\n<br>Flutter中的StatelessWidget是一个不需要状态更改的widget - 它没有要管理的内部状态。<br>当您描述的用户界面部分不依赖于对象本身中的配置信息以及widget的BuildContext 时，无状态widget非常有用。<br><blockquote>AboutDialog, CircleAvatar和 Text 都是StatelessWidget的子类。</blockquote></p><p><br>无状态widget的build方法通常只会在以下三种情况调用:<br><blockquote>将widget插入树中时<br>\n当widget的父级更改其配置时<br>\n当它依赖的InheritedWidget发生变化时\n</blockquote>\n<br><h3>二. 什么是StatefulWidget？\n</h3>\n<br>StatefulWidget 是可变状态的widget。 使用setState方法管理StatefulWidget的状态的改变。调用setState告诉Flutter框架，某个状态发生了变化，Flutter会重新运行build方法，以便应用程序可以应用最新状态。\n<br>\n<br>状态是在构建widget时可以同步读取的信息可能会在widget的生命周期中发生变化。确保在状态改变时及时通知状态 变化是widget实现者的责任。当widget可以动态更改时，需要使用StatefulWidget。 例如, 通过键入表单或移动滑块来更改widget的状态. 或者, 它可以随时间变化 - 或者数据推送更新UI<br><blockquote>Checkbox, Radio, Slider, InkWell, Form, 和 TextField 都是有状态的widget，也是StatefulWidget的子类。\n</blockquote>\n<br><h3>三. 在设计widget时，需要考虑以下几点。\n</h3>\n<br>1. 确定widget应该使用StatefulWidget还是StatelessWidget\n<br>\n<br>在Flutter中，widget是有状态的还是无状态的 - 取决于是否 他们依赖于状态的变化\n<br>\n<br> -. 如果用户交互或数据改变导致widget改变，那么它就是有状态的。\n<br> -. 如果一个widget是最终的或不可变的，那么它就是无状态。\n<br>\n<br>2. 确定哪个对象管理widget的状态（对于StatefulWidget）\n<br>在Flutter中，管理状态有三种主要方式：\n<br><blockquote> -. 每个widget管理自己的状态<br>\n -. 父widget管理widget的状态<br>\n -. 混合搭配管理的方法\n</blockquote>\n<br>如何决定使用哪种方式时，可以参考以下原则：<br><blockquote> -. 如果所讨论的状态是用户数据，例如复选框的已选中或未选中状态，或滑块的位置，则状态最好由父widget管理；<br>\n -. 如果widget的状态取决于动作，例如动画，那么最好是由widget自身来管理状态；<br>\n -. 如有还是不确定谁管理状态，请让父widget管理子widget的状态；\n</blockquote>\n<br><h3>四.StatelessWidget与StatefulWidget的选择</h3></p><p>1. 优先选择StatelessWidget。\n<br>2. 对于需要Widget自行维护状态，而这个状态又不需要暴露给父Widget的，使用StatefulWidget。其中状态定义在State中，而非StatefulWidget中。\n<br>3. 父Widget传给子Widget数据，有两种情况：\n<br>&nbsp; &nbsp; --. 父Widget同时传入数据更新函数。当子Widget操作数据更新时，调用此函数。父Widget必须是StatefulWidget。\n<br>&nbsp; &nbsp; --. 子Widget自行维护数据的更新和显示。子Widget必须是StatefulWidget。</p><p><h4>方式一: 父Widget负责数据更新维护\n</h4>首先定义父Widget：</p><pre>class ParentWidget extends StatefulWidget { \n    @override \n    _ParentWidgetState createState() =&gt; new _ParentWidgetState(); \n}  \nclass _ParentWidgetState extends State&lt;ParentWidget&gt; { \n    bool _active = false;    \n    void updateValue(bool newValue) { \n        setState(() { _active = newValue; }); \n    } \n    @override   \n    Widget build(BuildContext context) { \n        return ChildWidget(active: _active, parentUpdate: updateValue,); \n    } \n}</pre><p>然后定义子Widget：</p><pre>class ChildWidget extends StatefulWidget {   \n    bool active;   \n    Function parentUpdate;    \n    ChildWidget({Key key, this.active: false, @required this.parentUpdate}) : super(key: key);    \n    _ChildWidgetState createState() =&gt; new _ChildWidgetState(); \n}  \nclass _ChildWidgetState extends State&lt;ChildWidget&gt; {   \n    @override   \n    Widget build(BuildContext context) {     \n        return new Column(\n            children: [ \n                Text(widget.active ? 'Active' : 'Inactive'), \n                RaisedButton( \n                    child: Text('change active'),  \n                    onPressed: () { \n                        widget.parentUpdate(!widget.active); \n                    }, \n                )\n            ],\n        );\n    }\n}</pre><p>如上。父Widget将数据和更新函数同时传给了子Widget。子Widget的显示依赖于该数据。\n<br>当对子Widget进行操作，需要更改显示内容时，子Widget调用父Widget的更新函数即可。父Widget对数据更改并触发更新。子Widget判定可复用，然后用新的Widget数据更新自身。于是子Widget的显示得以更新。\n<br>\n<br><h4>方式二: 子Widget负责数据更新维护\n</h4>首先定义父Widget：</p><pre>class ParentWidget extends StatelessWidget {   \n    ParentWidget({Key key}) : super(key: key);    \n    final bool active;    \n    @override   \n    Widget build(BuildContext context) {     \n        return ChildWidget( active: active, );   \n    } \n}</pre><p>然后定义子Widget：</p><pre>class ChildWidget extends StatefulWidget {   \n    bool active;    \n    ChildWidget({Key key, this.active: false}) : super(key: key);    \n    _ChildWidgetState createState() =&gt; new _ChildWidgetState(); \n}  \nclass _ChildWidgetState extends State&lt;ChildWidget&gt; {   \n    @override   \n    Widget build(BuildContext context) {     \n        return new Column( children: [\n            Text(widget.active ? 'Active' : 'Inactive'),\n            RaisedButton(child: Text('change active'), \n                onPressed: () { \n                    setState(() { widget.active = !widget.active; });\n                }\n            )       \n        ]); \n    } \n}</pre><p>如上。父Widget将数据传给了子Widget。子Widget的显示依赖于该数据。\n<br>当对子Widget进行操作，需要更改显示内容时，子Widget调用自身的更新函数来修改数据值。\n<br>在此情形下，父Widget可以是StatelessWidget/StatefulWidget。\n<br>注意上面直接用widget.xx来使用/修改数据。对于父Widget传入的数据，推荐使用此方式，而不是在State中再次定义一个变量来再次接收。\n<br>\n<br><h4>StatefulWidget的维护方式选择\n</h4>对于上面两种方式，对应不同的需求场景。通常来说：<br></p><blockquote>1. 若父Widget的数据影响到多个子Widget，即某个子Widget修改了数据后，多个子Widget都会同步更新，那么必须让父Widget来维护数据更新，也就是上面方式一。<br>\n2. 若父Widget的数据只影响到单个子Widget，也就是说子Widget修改了数据后，只有自身会更新，那么推荐子Widget自行维护，也就是上面方式二。</blockquote><p>对逻辑而言，两种方式都可以实现更改父Widget中数据的目的。区别在于更改数据后，谁负责将这个改动体现在界面上。\n<br>通常来说，2是最常见的。且2中父Widget可以是StatelessWidget/StatefulWidget。常规开发推荐使用2。\n<br>若不得不采用1，则父Widget必须是StatefulWidget，因为要提供修改函数。</p><p><br></p><p>\n\n<br></p>"}}