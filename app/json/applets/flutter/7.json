{"sta":1,"data":{"subTitle":"基于 Isolate 在后台处理网络请求数据","content":"<h3>一、Islote</h3><p>Dart 应用一般都是单线程运行的，这就可能导致一些隐藏问题，比如当你的数据处理时间特别长的时候，用户体验上可能就会出现问题。<br>Native 本身是可以进行多线程进行一些操作，Flutter 中封装了 Isolate 来进行线程调度<br>Isolate 在 native 开发使用的包是 import '_isolates_io.dart'，在 web 开发中使用的是 _isolates_web<br>并且 Isolate 提供了 computed 方法，用于将数据与 callback 结合</p><pre>/// Spawn an isolate, run `callback` on that isolate, passing it `message`, and\n/// (eventually) return the value returned by `callback`.\nfinal _ComputeImpl compute = _isolates.compute;</pre><p>也就是说通过 compute 方法，可以将数据抛给一个方法去处理，并且在后台执行</p><pre>compute(callback, data)</pre><p><h3>二、使用 Islote 处理网络请求的数据\n</h3><h4>1、http 请求数据\n</h4>这里请求了 网易新闻的一个 json</p><pre>http.Response response = await client.get(\n      'https://3g.163.com/photocenter/api/list/0001/00AP0001,3R710001,4T8E0001/30/100.json');\nprint(response.body)</pre><p>首先我们拿到了数据，如果这个时候直接处理，我们可能采用的方式是：</p><pre>Future&lt;List&lt;Photo&gt;&gt; _fetchPhotos(http.Client client) async {\n     http.Response res =\n         await client.get('https://3g.163.com/photocenter/api/list/0001/00AP0001,3R710001,4T8E0001/30/100.json');\n     List list = json.decode(res.body);\n     return list.map((item) {\n       return Photo.fromJson(item);\n     }).toList();\n   }</pre><p>上面这种方式明显是阻塞的，并且如果我们要渲染占位图，就需要使用 state 控制占位图的渲染\n<br>\n<br><h4>2、使用 compute 在后台处理数据\n</h4>为了方便数据的处理，创建一个 callback 方法：</p><pre>class Photo {\n  final String thumbnailUrl;\n\n  Photo({this.thumbnailUrl});\n\n  factory Photo.fromJson(Map&lt;String, dynamic&gt; data) {\n    return Photo(\n      thumbnailUrl: data['tcover'] as String,\n    );\n  }\n}\n\nList&lt;Photo&gt; generatorPhoto(String body) {\n  List list = json.decode(body);\n  return list.map&lt;Photo&gt;((item) =&gt; Photo.fromJson(item)).toList();\n}</pre><p>上面代码中 Photo Class 用来处理单个图片，将数据抽出来<br>而 generatorPhoto 方法则是将网络请求 decode 之后，在遍历处理数据。<br>准备好 callback 之后，就可以将数据丢给 callback</p><pre>Future&lt;List&lt;Photo&gt;&gt; _fetchPhotos(http.Client client) async {\n  http.Response response = await client.get(\n      'https://3g.163.com/photocenter/api/list/0001/00AP0001,3R710001,4T8E0001/30/100.json');\n  return compute(generatorPhoto, response.body);\n}</pre><p>return compute(generatorPhoto, response.body); 会将 generatorPhoto 处理完的数据返回，当然 _fetchPhoto 这个方法依旧是异步的\n<br>\n<br><h4>3、异步渲染数据\n</h4>上面处理之后， _fetchPhotos 返回的仍然是异步结果，在 Widget 中不能直接在 builder 渲染组件，需要通过异步渲染。<br>FutureBuilder 构造函数如下：</p><pre>const FutureBuilder({\n    Key key,\n    this.future,\n    this.initialData,\n    @required this.builder,\n  })</pre><p>this.future 的声明如下：</p><pre>/// The asynchronous computation to which this builder is currently connected,\n  /// possibly null.\n  ///\n  /// If no future has yet completed, including in the case where [future] is\n  /// null, the data provided to the [builder] will be set to [initialData].\n  final Future&lt;T&gt; future;</pre><p>future 是异步处理的结果，结果可能是 null，builder 是渲染 Widget 的处理逻辑<br>builder 接受两个参数，除了默认的 builder 会接收的 context 上下文数据外，还接收 snapshot 参数。<br>其中 future 的结果都是从 snapshot 中获取，snapshot 的类型其实是 AsyncSnapshot.<br>AsyncSnapshot 其实有几种状态，分别代表数据数据的进度：<br><blockquote>AsyncSnapshot.ConnectionState.none<br>\nAsyncSnapshot.ConnectionState.waiting<br>\nAsyncSnapshot.ConnectionState.active<br>\nAsyncSnapshot.ConnectionState.done\n</blockquote>而 AsyncSnapshot 本身提供了 hasData 和 hasError 两个属性快速判断是否有错误或者数据，提供了 error 和 data 快速获取数据或者错误信息。<br>因此 builder 中逻辑如下：</p><pre>@override\n  Widget build(BuildContext context) {\n    return FutureBuilder&lt;List&lt;Photo&gt;&gt;(\n      future: _fetchPhotos(http.Client()),\n      builder: (context, snapshot) {\n        if (snapshot.hasError) {\n          print(snapshot.error);\n        }\n        if (snapshot.hasData) {\n          return PhotoListView(list: snapshot.data);\n        } else {\n          return Center(child: CircularProgressIndicator());\n        }\n      },\n    );\n  }</pre><p>首先通过 snapshot.hasError 判断是否有错误，如果存在错误，或者直接渲染错误页。<br>如果有数据，渲染真正的 Widget，否则渲染一个 loading UI<br><h4>4、PhotoListView UI Widget\n</h4>这个比较简单，就是一个 GridView：</p><pre>class PhotoListView extends StatelessWidget {\n  final List&lt;Photo&gt; list;\n\n  PhotoListView({Key key, this.list}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return GridView.builder(\n      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(\n        crossAxisCount: 2,\n      ),\n      itemCount: list.length,\n      itemBuilder: (context, i) {\n        return Image.network(list[i].thumbnailUrl);\n      },\n    );\n  }\n}</pre><h3>三、效果：</h3><p><img src=\"/app/json/applets/flutter/imgs/1.gif\" style=\"max-width:100%;\"></p><p><br></p><p><br></p><p><br></p>"}}