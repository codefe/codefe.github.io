{"sta":1,"data":{"subTitle":"io 文件读写及实现持久化数据计数","content":"<h3>一、path_provider</h3><p>path_provider 是 flutter 提供的用于进行文件存储的 package\n<br>\n<br>本质上是封装了 Android 和 iOS Native 方法去进行读写磁盘，读写分为两种场景：<br><blockquote>临时文件夹<br>\n应用的Documents 目录\n</blockquote>临时文件夹在执行系统的清空缓存时会清空掉该文件夹，documents 目录则是随着应用创建而创建，只有在删除应用时，才会清空这个目录。<br>临时文件夹在 iOS 上对用的是 NSCachesDirectory 在 Android 对用的是 getCacheDir()<br>而 Documents 目录在 iOS 对应的是 NSDocumentDirectory ，在 Android 上对应的是 AppData 目录<br>本身 package_provider 提供了三个方法分别获取不同的文件路径<br><h4>1、getTemporaryDirectory\n</h4>获取设备上的临时目录，也就是上面提到的 临时文件夹<br><h4>2、getApplicationDocumentsDirectory\n</h4>获取应用的 document 目录<br><h4>3、getExternalStorageDirectory\n</h4>这个方法可以修改顶级存储也就是系统级别的存储路径，但是只有在 android 上生效，因为 iOS 的 sandbox Application 执行特性，不允许修改顶级存储。<br>因此如果在 iOS 上使用会抛出异常<br>使用这个方法需要额外注意\n<br>\n<br><h3>二、使用 path_provider 的 getApplicationDocumentsDirectory\n</h3>无论是获取临时 cache 路径还是 documents 文件夹，都是异步的方法，并且返回的都是 Directory　类型<br>Directory 是一个抽象类，其中实现了 get 属性 path:</p><pre>@pragma(\"vm:entry-point\")\nabstract class Directory implements FileSystemEntity {\n  /**\n   * Gets the path of this directory.\n   */\n  String get path;</pre><p>因此返回的 Directory 需要通过 Directory.path 拿到具体的路径\n<br>\n<br><h4>1、获取文件夹路径\n</h4>最终我们要在 document 中访问一个文件，首先需要知道路径是什么，因此每次我们都需要调用 await getApplicationDocumentsDirectory() 拿到文件夹的路径。<br>这里通过 一个 get 属性 _localPath 获取，本质上还是每次调用方法获取数据，当然可以通过属性判断是否存在值，还是异步方法返回</p><pre>Future&lt;String&gt; get _localPath async {\n    final directory = await getApplicationDocumentsDirectory();\n    print(directory.path);\n    return directory.path;\n  }</pre><p><h4>2、获取文件实例\n</h4>一个文件总是通过 File() 创建出实例来，File 的工厂方法如下：</p><pre>@pragma(\"vm:entry-point\")\n  factory File(String path) {\n    final IOOverrides overrides = IOOverrides.current;\n    if (overrides == null) {\n      return new _File(path);\n    }\n    return overrides.createFile(path);\n  }</pre><p>但我们拿到文件路径之后，就可以通过 File 拿到文件实例，然后通过文件实例做其他事情。<br>下面代码中，首先通过一个 _file存储数据，如果 _file 并不是 File 类型，在通过 File('$path/counter.txt') 实例化文件实例</p><pre>Future&lt;File&gt; get _localFile async {\n    if (_file is File) {\n      return _file;\n    } else {\n      final String path = await _localPath;\n      _file = File('$path/counter.txt');\n      return _file;\n    }\n  }</pre><p><h4>3、读取文件内容\n</h4>读取文件的内容。首先需要拿到文件实例，然后 File 提供了两种读取形式，分别是 readAsBytes 和 readAsString，表示字节读取和字符串读取。<br>每种读取形式包含了异步和同步方法，分别是：<br><blockquote>readAsBytes<br>\nreadAsBytesSync<br>\nreadAsString<br>\nreadAsStringSync\n</blockquote>下面的方法中，读取内容作为字符串，并且将其转成 int 类型：</p><pre>_initCounter() async {\n    final File file = await _localFile;\n    final String res = await file.readAsString();\n    setState(() {\n      _counter = int.parse(res ?? 0);\n    });\n  }</pre><p><h4>4、写入文件内容\n</h4>同样的写入文件内容也提供了 字节和字符串两种形式，并且提供了同步和异步<br><blockquote>writeAsBytes<br>\nwriteAsBytesSync<br>\nwriteAsString<br>\nwriteAsStringSync\n</blockquote>下面方法中，讲一个 int 类型数据，转成 String 然后写入到文件中</p><pre>_saveCounter() async {\n    final File file = await _localFile;\n    file.writeAsString(_counter.toString());\n  }</pre><p><h3>三、文件读写实践\n</h3>基于文件存储，创建一个计数应用<br><h4>1、首页进行路由导航\n</h4>如果没有任何持久化数据的策略，每次进去 counter 都是置空，这并不是我们期望的结果，这里刻意做了个首页的导航</p><pre>class HomeDemo extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: OutlineButton(\n        child: Text('go to counter'),\n        onPressed: () =&gt; {\n          Navigator.of(context).push(MaterialPageRoute(builder:(context) =&gt; CounterDemo()))\n        },\n      ),\n    );\n  }\n}</pre><h4>2、一个页面承载 counter 计数示例</h4><pre>class CounterDemo extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('counter')\n      ),\n      body: FileIODemo()\n    );\n  }\n}</pre><h4>3、最终持久化计数示例的实现</h4><pre>class FileIODemo extends StatefulWidget {\n  FileIODemo({Key key}) : super(key: key);\n\n  _FileIODemoState createState() =&gt; _FileIODemoState();\n}\n\nclass _FileIODemoState extends State&lt;FileIODemo&gt; {\n  int _counter = 0;\n  File _file;\n\n  _FileIODemoState() {\n    _initFile();\n  }\n  @override\n  void initState() {\n    super.initState();\n    _initCounter();\n  }\n\n  _initCounter() async {\n    final File file = await _localFile;\n    final String res = await file.readAsString();\n    setState(() {\n      _counter = int.parse(res ?? 0);\n    });\n  }\n\n  _initFile() async {\n    _file = await _localFile;\n  }\n\n  Future&lt;String&gt; get _localPath async {\n    final directory = await getApplicationDocumentsDirectory();\n    print(directory.path);\n    return directory.path;\n  }\n\n  Future&lt;File&gt; get _localFile async {\n    if (_file is File) {\n      return _file;\n    } else {\n      final String path = await _localPath;\n      _file = File('$path/counter.txt');\n      return _file;\n    }\n  }\n  _saveCounter() async {\n    final File file = await _localFile;\n    file.writeAsString(_counter.toString());\n  }\n\n\n  @override\n  Widget build(BuildContext context) {\n    return Column(\n      children: &lt;Widget&gt;[\n        SizedBox(height: 20),\n        Row(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: &lt;Widget&gt;[\n            Text(_counter.toString()),\n          ],\n        ),\n        SizedBox(height: 20),\n        Row(\n          mainAxisAlignment: MainAxisAlignment.spaceAround,\n          children: &lt;Widget&gt;[\n            RaisedButton(\n              child: Text('-'),\n              onPressed: () {\n                setState(() {\n                  _counter -= 1;\n                  _saveCounter();\n                });\n              },\n            ),\n            RaisedButton(\n              child: Text('+'),\n              onPressed: () {\n                setState(() {\n                  _counter += 1;\n                  _saveCounter();\n                });\n              },\n            ),\n          ],\n        )\n      ],\n    );\n  }\n}</pre><p><br></p><p><br></p><p>\n<br></p>"}}