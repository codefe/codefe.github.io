{"sta":1,"data":{"subTitle":"基于 shared_preferences 进行持久化键值存储","content":"<h3>一、shared_preferences 插件</h3><p>shared_preferences 是 Flutter 提供的 key-value 存储插件，能够将数据持久化到磁盘中。<br>在 iOS 上封装的是 NSUserDefault 在 android 上封装的是 SharedPreferences<br>如果要使用，需要在 pubspec.yaml 中添加 shared_preferences 依赖<br><blockquote>  shared_preferences: ^0.5.3+1\n</blockquote><h3>二、使用 shared_preferences\n</h3><h4>1、获取实例\n</h4>要使用 shared_preferences 需要首先拿到 instance，提供了 getInstance() 方法：&nbsp;<br></p><pre>static Future&lt;SharedPreferences&gt; getInstance() async {\n    if (_instance == null) {\n      final Map&lt;String, Object&gt; preferencesMap =\n          await _getSharedPreferencesMap();\n      _instance = SharedPreferences._(preferencesMap);\n    }\n    return _instance;\n  }</pre><p>方法是异步的，因此在使用的时候也需要异步获取</p><pre>void _getInstance() async {\n    _prefs = await SharedPreferences.getInstance();\n  }</pre><p>如果需要在 StatefulWidget 中使用，可以在 initState 中或者构造函数拿到并且初始化</p><pre>_PreferencesDemoState() {\n    _key = 'name';\n    _value = 'postbird-value';\n    _getInstance();\n  }</pre><p><h4>2、存储数据\n</h4>SharedPreferences 提供了 setInt、setBool、setString 和 setStringList 等方法，用来设置特定类型的数据，而本身这些方法是基于 _setValue 这个私有方法实现的，最终通过 involeMethod(set$valueType) 调用 native 方法</p><pre>Future&lt;bool&gt; _setValue(String valueType, String key, Object value) {\n    final Map&lt;String, dynamic&gt; params = &lt;String, dynamic&gt;{\n      'key': '$_prefix$key',\n    };\n    if (value == null) {\n      _preferenceCache.remove(key);\n      return _kChannel\n          .invokeMethod&lt;bool&gt;('remove', params)\n          .then&lt;bool&gt;((dynamic result) =&gt; result);\n    } else {\n      _preferenceCache[key] = value;\n      params['value'] = value;\n      return _kChannel\n          .invokeMethod&lt;bool&gt;('set$valueType', params)\n          .then&lt;bool&gt;((dynamic result) =&gt; result);\n    }\n  }</pre><p>存储数据：</p><pre>void _savePressedHandle() {\n    _value = DateTime.now().toString();\n    _prefs.setString(_key, _value);\n    print(_prefs);\n    Scaffold.of(context).hideCurrentSnackBar();\n    Scaffold.of(context).showSnackBar(SnackBar(content: Text('set succssed')));\n  }</pre><p><h4>3、获取数据\n</h4>和 set 类似，初次之外，还包括 getString / getInt / getDouble 等方法</p><pre>void _getPressedHandle() {\n    final name = _prefs.getString(_key);\n    print(name);\n    Scaffold.of(context).hideCurrentSnackBar();\n    Scaffold.of(context).showSnackBar(SnackBar(content: Text('get $name')));\n  }</pre><p><h4>4、getKeys、containsKey\n</h4>这些是提供的一些辅助类的方法，用于获取所有的 key 或者判断是否存在 key</p><h4>5、移除数据</h4><pre>void _removePressedHandle() {\n    final res = _prefs.remove(_key);\n    print(res);\n    Scaffold.of(context).hideCurrentSnackBar();\n    Scaffold.of(context).showSnackBar(SnackBar(content: Text('remove $_key')));\n  }</pre><p><br></p><p><br></p>"}}