{"sta":1,"data":{"subTitle":"命名路由、路由组、路由替换、路由销毁","content":"<h3>一、路由表 和 命名路由</h3><p>现在无论是服务端项目还是前端项目基本都是通过路由来决定资源的访问，而项目如果复杂，路由不能随便写，导航也不能直接写个 Wdiget builder<br>因此最终我们都是通过路由表和命名路由来进行导航\n<br>\n<br><h4>1、路由表\n</h4>Scaffold Widget 中有一个构造函数的参数是 routes，是一个 Map 类型，类型声明如下：<br><blockquote>  final Map&lt;String, WidgetBuilder&gt; routes;\n</blockquote>一个字符串映射一个 WidgetBuilder<br>字符串就是路由的名称，而映射只需要返回一个 widget builder 即可,这里我们构造这个路由表：<br>SearchPage 、 LoginPage、 SignPage 三个页面的代码不重复，文章最后能够找到，就是三个 widget</p><pre>final Map&lt;String, WidgetBuilder&gt; _routes = {\n    '/search': (context) =&gt; SearchPage(),\n    '/login': (context) =&gt; LoginPage(),\n    '/sign': (context, {arguments}) =&gt; SignPage(arguments: arguments),\n  };</pre><p>上面构造出了路由表，就可以直接配置到 Scalfold 中\n<br>\n<br><h4>2、onGenerateRoute 路由拦截\n</h4>Scalfold 同时支持一个 onGenerateRoute 的参数，接受一个 Route 工厂函数：</p><pre>/// {@macro flutter.widgets.widgetsApp.onGenerateRoute}\n  final RouteFactory onGenerateRoute;</pre><p>为什么要这么做，从上面的路由表可以看出，'/sign': (context, {arguments}) =&gt; SignPage(arguments: arguments), /sign 这个路由的构造中我们在 builder 中接受了第二个可选命名参数： arguments<br>如何将 arguments 传递给 widget 的构造函数，并且如何在路由跳转之前做些事情都可以在 onGenerateRoute 中进行<br>比如下面的方法：</p><pre>Route _routeGenerator(RouteSettings settings) {\n    final String name = settings.name;\n    final Function pageBuilder = this._routes[name];\n    if (pageBuilder != null) {\n      if (settings.arguments != null) {\n        // 如果透传了参数\n        return MaterialPageRoute(\n            builder: (context) =&gt;\n                pageBuilder(context, arguments: settings.arguments));\n      } else {\n        // 没有透传参数\n        return MaterialPageRoute(builder: (context) =&gt; pageBuilder(context));\n      }\n    }\n    return MaterialPageRoute(builder: (context) =&gt; HomeContent());\n  }</pre><p>上面代码中，从拦截到路由之后，首先从路由表中拿到路由的 builder，如果能够拿到 builder，则判断是否存在 RouteSettings，如果存在则直接通关构造函数的 arguments 传递给页面 Page Widget。<br>这种条件就允许页面 Widget 构造函数中，必须有 arguments 这个参数才可以，比如 /sign 代码如下：<br>这样的优点在于不需要通过 ModalRoute.of(context).settings.xxx 拿数据。直接映射到 Widget 中</p><pre>//  onGeneate\nclass SignPage extends StatelessWidget {\n  final Map arguments;\n  SignPage({Key key, this.arguments}) : super(key: key) {\n    // print(this.arguments);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    String tmp = ModalRoute.of(context).settings.arguments.toString();\n    String tmp2 = this.arguments.toString();\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(tmp),\n      ),\n      body: Center(child: Text(tmp2)),\n    );\n  }\n}</pre><p>需要注意上面的代码，两种方式我都获取了 arguments:</p><pre>String tmp = ModalRoute.of(context).settings.arguments.toString();\n    String tmp2 = this.arguments.toString();</pre><p><h4>3、命名路由导航 Navigator.of(context).pushName\n</h4>创建好了路由表和拦截就可以进行路由导航：</p><pre>Navigator.of(context).pushNamed('/search');</pre><p>此时如果要传值，根据 路由拦截 的方法，可以如下传递：</p><pre>Navigator.of(context).pushNamed('/login', arguments: {\n  \"title\": \"透传title\",\n  \"name\": 'postbird',\n  'passw': '123456'\n});</pre><h4>4、效果：</h4><p><img src=\"/app/json/applets/flutter/imgs/13.gif\" style=\"max-width:100%;\"></p><p><h3>二、路由替换 Navigator.of(context).pushReplacementNamed\n</h3>正常我们跳转页面，是通过 Navigator.push 或者 pushNamed 实现的，每次都是把页面压入堆栈，在回退 的时候会回退到上一跳页面\n<br>\n<br>某些场景下我们期望不返回上一条，在跳转吓一跳的时候替换本页面，将上一个页面从堆栈中移除，这时候就需要 Navigator.of(context).pushReplacementNamed 这个方法</p><pre>FlatButton(\n  child: Text('SignPage Replacement'),\n  color: Theme.of(context).buttonColor,\n  onPressed: () {\n    Navigator.of(context).pushReplacementNamed('/sign');\n  },\n),</pre><p>本质上使用和 pushNamed 是一样的，只是效果会不一样：</p><p><img src=\"/app/json/applets/flutter/imgs/14.gif\" style=\"max-width:100%;\"></p><p>从上面可以发现，从 home -&gt; login -&gt; sign，然后在 sign 中点击返回按钮的时候，中间不会经过 login，直接就返回 home 了\n<br>\n<br><h3>三、根路由 pushNamedAndRemoveUntil\n</h3>与上面 pushReplacementNamed 差不多思想，但是场景更激进，比如我需要直接返回首页，之前的所有路由全部干掉，堆栈清空<br>这种场景下，可以借助 Navigator.of(context).pushNamedAndRemoveUntil<br>从名字上可以看出来，可以有条件的做一些事情</p><pre>FlatButton(\n  child: Text('Return '),\n  color: Theme.of(context).buttonColor,\n  onPressed: () {\n    // 根\n    Navigator.of(context).pushNamedAndRemoveUntil(\n      '/',\n      (route) =&gt; route == null,\n    );\n  },\n)</pre><p>pushNamedAndRemoveUntil 接受两个参数，第一个是路由名，（这里我们使用了根路由）第二个则是对堆栈中的 route 的处理：<br>下面的处理中我们清空了 route 全部置为 null，则会路由到 '/' 根路由前的所有 route 都被干掉。</p><pre>Navigator.of(context).pushNamedAndRemoveUntil(\n      '/',\n      (route) =&gt; route == null,\n    );</pre><p>最终效果：\n<br>\n<img src=\"/app/json/applets/flutter/imgs/15.gif\" style=\"max-width:100%;\"></p><p>上面效果中能够发现， home -&gt; login -&gt; sign1 -&gt; sign2 -&gt; sign3 然后在 sign3 中点击 return 的时候，直接返回的 home，中间的路由都被干掉了。</p><p><br></p>"}}