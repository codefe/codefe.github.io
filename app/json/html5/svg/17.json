{"sta":1,"data":{"subTitle":"SVG 实现动态模糊动画效果","content":"<p>动态模糊是一种广泛使用于动态影像和动画的技术，它能使动作看起来更加平滑自然。<br></p><blockquote>动态模糊是静止图像或一系列图像（如电影或动画）中快速移动物体的明显图像拖尾。当记录的图像在单帧记录期间发生变化时，由于快速移动或长时间曝光从而导致动态模糊的结果。——维基百科上对动态模糊的介绍</blockquote><p>为了对动画应用动态模糊效果，我们需要在每个帧中根据对象的速度和它移动的方向应用方向模糊。</p><p><img src=\"./app/json/html5/svg/img/3.jpeg\" style=\"max-width:100%;\" class=\"\"></p><p>那么，怎么才能产生这种效果呢？<br><h3>设置模糊</h3>由于常规CSS模糊滤镜不支持定向模糊，所以我们不得不使用SVG滤镜。<br>《Creative Gooey Effects》这篇文章中介绍有SVG滤镜的基础知识。<br>为此，我们将只使用高斯滤镜模糊feGaussianBlur原语。</p><pre><code>&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" class=\"filters\"&gt;\n   &lt;defs&gt;\n     &lt;filter id=\"blur\"&gt;\n       &lt;fegaussianblur in=\"SourceGraphic\" stddeviation=\"0,0\"/&gt;\n     &lt;/filter&gt;\n   &lt;/defs&gt;\n &lt;/svg&gt;</code></pre><p>stdDeviation属性用于设置模糊强度，并且可以占用两个参数，用于水平和垂直方向的模糊。<br>将滤镜应用到一个元素上，就像我们之前看到的那样，非常简单：</p><pre><code>.selector{\n   -webkit-filter: url(\"#blur\");\n   filter: url(\"../index.html#blur\");\n }</code></pre><p>然而，对于动态模糊效果，我们仍得通过JS动态更新每个帧的滤镜。<br>首先，我们必须选择并将滤镜存储在一个变量中，以便以后可以访问它。由于jQuery与SVG元素不兼容，所以我们需要使用本机JS函数选择元素：</p><pre><code>var filters = document.querySelector(\".filters\"), // the SVG that contains the filters\n defs = filters.querySelector(\"defs\"), // the  element inside the SVG\n blur = defs.querySelector(\"#blur\"), // the blur filter\n blurFilter = blur.firstElementChild; // the feGaussianBlur primitive</code></pre><p>然后设置强度，即改变滤镜原语的stdDeviation属性。例如，要设置一个水平12px的模糊：</p><blockquote>blurFilter.setAttribute(\"stdDeviation\",\"12,0\");</blockquote><p><img src=\"./app/json/html5/svg/img/2.gif\" style=\"max-width:100%;\" class=\"\"></p><p>记住，此模糊滤镜只支持X或Y方向上的方向模糊，不能任意角度，因此你需要相应地规划好动画效果。\n<br>\n<br>还有，改变模糊滤镜会影响与其相关联的所有对象，因此我们需要为将应用此效果的每个对象添加一个新的元素。下面是一种动态创建这些滤镜的简单方法：</p><pre><code>// go through all the objects that need a blur filter\n $(\".js-blur\").each(function(i){\n // clone the filter\n var blurClone=blur.cloneNode(true);\n \n // create and set a new ID so we can use the filter through CSS\n var blurId=\"blur\"+i;\n blurClone.setAttribute(\"id\",blurId);\n \n defs.appendChild(blurClone);\n \n // set the CSS\n var filter=\"url(#\"+blurId+\")\";\n $(this)\n .css({\n webkitFilter:filter,\n filter:filter\n })\n // store the filter reference on the object for practicity\n .data(\"blur\",blurClone)\n ;\n });</code></pre><p><h3>测量速度\n</h3>\n<br>接下来，我们需要能够计算得到自上一帧以来对象移动的距离。每一帧我们都要计算。实现方法可能会根据设置的不同而不同；例如动画如何完成方面的设置等等。在本教程中，我们将采用更通用的方法，尽管它可能无法针对所有用例进行优化，但适用于大多数JS和CSS动画。\n<br>\n<br>为了得到距离结果，我们将使用jQuery的offset函数，这正是我们需要的：它返回元素的坐标，相对于文档（而不是它的父类）而言，并且将transform属性考虑在内。\n<br>\n<br>为了能够检查改变并更新每一帧，我们将使用requestAnimationFrame。\n<br>\n<br>下面是一个例子：</p><pre><code>// the element we want to apply the effect\n var $element=$(\".selector\");\n // storing the last position, to be able to measure changes\n var lastPos=$element.offset();\n // a multiplier, to be able to control the intensity of the effect\n var multiplier=0.25;\n\n // a helper to simplify setting the blur. \n function setBlur(x,y){\n blurFilter.setAttribute(\"stdDeviation\",x+\",\"+y);\n }\n \n (function updateMotionBlur(){\n // get the current position of the element\n var currentPos=$element.offset();\n \n // calculate the changes from the last frame and apply the multiplier\n var xDiff=Math.abs(currentPos.left-lastPos.left)*multiplier;\n var yDiff=Math.abs(currentPos.top-lastPos.top)*multiplier;\n \n // set the blur\n setBlur(xDiff,yDiff);\n \n // store current position for the next frame\n lastPos=currentPos;\n\n // call to update in the next frame\n requestAnimationFrame(updateMotionBlur);\n })();</code></pre><p>结果如下：</p><p><img src=\"./app/json/html5/svg/img/1.gif\" style=\"max-width:100%;\"></p><p>这不过是仅考虑一个要素的基本方法。更复杂的可能需要特别为其优化的代码。对于更复杂的拍摄，你可以考虑将动态模糊效果应用于多个对象，在没有动画时禁用模糊和速度计算，等等。</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>"}}