{"sta":1,"data":{"subTitle":"客户端的API","content":"<p>WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。<br></p><pre><code>var ws = new WebSocket('ws://localhost:8080');</code></pre><p>执行上面语句之后，客户端就会与服务器进行连接。</p><h3>webSocket.readyState</h3><p>readyState属性返回实例对象的当前状态，共有四种。</p><pre><code>CONNECTING：值为0，表示正在连接。\nOPEN：值为1，表示连接成功，可以通信了。\nCLOSING：值为2，表示连接正在关闭。\nCLOSED：值为3，表示连接已经关闭，或者打开连接失败。</code></pre><p>下面是一个示例。</p><pre><code>switch (ws.readyState) {\n  case WebSocket.CONNECTING:\n    // do something\n    break;\n  case WebSocket.OPEN:\n    // do something\n    break;\n  case WebSocket.CLOSING:\n    // do something\n    break;\n  case WebSocket.CLOSED:\n    // do something\n    break;\n  default:\n    // this never happens\n    break;\n}</code></pre><h3>webSocket.onopen</h3><p>实例对象的onopen属性，用于指定连接成功后的回调函数。</p><pre><code>ws.onopen = function () {\n  ws.send('Hello Server!');\n}</code></pre><p>如果要指定多个回调函数，可以使用addEventListener方法。<br></p><pre><code>ws.addEventListener('open', function (event) {\n  ws.send('Hello Server!');\n});</code></pre><h3>webSocket.onclose</h3><p>实例对象的onclose属性，用于指定连接关闭后的回调函数。</p><pre><code>ws.onclose = function(event) {\n  var code = event.code;\n  var reason = event.reason;\n  var wasClean = event.wasClean;\n  // handle close event\n};\n\nws.addEventListener(\"close\", function(event) {\n  var code = event.code;\n  var reason = event.reason;\n  var wasClean = event.wasClean;\n  // handle close event\n});</code></pre><h3>webSocket.onmessage</h3><p>实例对象的onmessage属性，用于指定收到服务器数据后的回调函数。</p><pre><code>ws.onmessage = function(event) {\n  var data = event.data;\n  // 处理数据\n};\n\nws.addEventListener(\"message\", function(event) {\n  var data = event.data;\n  // 处理数据\n});</code></pre><p>注意，服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）。</p><pre><code>ws.onmessage = function(event){\n  if(typeof event.data === String) {\n    console.log(\"Received data string\");\n  }\n\n  if(event.data instanceof ArrayBuffer){\n    var buffer = event.data;\n    console.log(\"Received arraybuffer\");\n  }\n}</code></pre><p>除了动态判断收到的数据类型，也可以使用binaryType属性，显式指定收到的二进制数据类型。</p><pre><code>// 收到的是 blob 数据\nws.binaryType = \"blob\";\nws.onmessage = function(e) {\n  console.log(e.data.size);\n};\n\n// 收到的是 ArrayBuffer 数据\nws.binaryType = \"arraybuffer\";\nws.onmessage = function(e) {\n  console.log(e.data.byteLength);\n};</code></pre><h3>webSocket.send()</h3><p>实例对象的send()方法用于向服务器发送数据。\n<br>\n<br>发送文本的例子。</p><pre><code>ws.send('your message');</code></pre><p>发送 Blob 对象的例子。</p><pre><code>var file = document\n  .querySelector('input[type=\"file\"]')\n  .files[0];\nws.send(file);</code></pre><p>发送 ArrayBuffer 对象的例子。</p><pre><code>// Sending canvas ImageData as ArrayBuffer\nvar img = canvas_context.getImageData(0, 0, 400, 320);\nvar binary = new Uint8Array(img.data.length);\nfor (var i = 0; i &lt; img.data.length; i++) {\n  binary[i] = img.data[i];\n}\nws.send(binary.buffer);</code></pre><h3>webSocket.bufferedAmount</h3><p>实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。</p><pre><code>var data = new ArrayBuffer(10000000);\nsocket.send(data);\n\nif (socket.bufferedAmount === 0) {\n  // 发送完毕\n} else {\n  // 发送还没结束\n}</code></pre><h3>webSocket.onerror</h3><p>实例对象的onerror属性，用于指定报错时的回调函数。</p><pre><code>socket.onerror = function(event) {\n  // handle error event\n};\n\nsocket.addEventListener(\"error\", function(event) {\n  // handle error event\n});</code></pre><p><br></p>"}}