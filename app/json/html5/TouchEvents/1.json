{"sta":1,"data":{"subTitle":"TouchEvents API","content":"<h3>定义</h3><p><h4>表面（surface）\n</h4>可感知触摸的平面，可以是屏幕或触控板。\n<br><h4>触摸点（touch point）\n</h4>表面上的一个接触点.。有可能是手指 (或者胳膊肘、耳朵、鼻子都行。但一般是手指) 或者触摸笔.\n<br><h3>接口\n</h3><h4>TouchEvent\n</h4>表示位于表面上的一个触摸点的某个状态发生改变时产生的事件。\n<br><h4>Touch\n</h4>表示用户与触摸表面间的一个单独的接触点。\n<br><h4>TouchList\n</h4>表示一组 Touch，用于多点触控的情况。\n<br><h3>示例\n</h3>本示例通过对多个触控点进行同步跟踪，让用户通过多点触控的方式在 &lt;canvas&gt; 元素上用两个（或以上）手指同时画图。本示例只在支持触摸事件的浏览器下生效。</p><p>注：下文中用“手指”表示与平面的交互，当然触控笔等也是可行的。</p><h3>创建画布</h3><pre><code>&lt;canvas id=\"canvas\" width=\"600\" height=\"600\" style=\"border:solid black 1px;\"&gt;\n  你的浏览器不支持 canvas 元素。\n&lt;/canvas&gt;\n&lt;br&gt;\n日志：&lt;pre id=\"log\" style=\"border: 1px solid #ccc;\"&gt;&lt;/pre&gt;</code></pre><h3>设置事件处理器</h3><p>当页面加载时，下文的 startup() 函数由 window.onload 属性触发。</p><pre><code>window.onload = function startup() {\n  const el = document.getElementsByTagName(\"canvas\")[0];\n  el.addEventListener(\"touchstart\", handleStart, false);\n  el.addEventListener(\"touchend\", handleEnd, false);\n  el.addEventListener(\"touchmove\", handleMove, false);\n  log(\"初始化成功。\")\n}</code></pre><p>该函数为 &lt;canvas&gt; 元素设置了所有相关的事件监听器，使事件在触发时能够得到处理。</p><p><h3>跟踪新触摸\n</h3>我们将跟踪当前存在的所有触摸点。</p><pre><code>const ongoingTouches = [];</code></pre><p>当 touchstart 事件触发时，平面上即出现一个新的触摸点，继而调用 handleStart() ：</p><pre><code>function handleStart(evt) {\n  evt.preventDefault();\n  console.log(\"触摸开始。\");\n  const el = document.getElementsByTagName(\"canvas\")[0];\n  const ctx = el.getContext(\"2d\");\n  const touches = evt.changedTouches;\n\n  for (let i = 0; i &lt; touches.length; i++) {\n    console.log(\"开始第 \" + i + \" 个触摸 ...\");\n    ongoingTouches.push(copyTouch(touches[i]));\n    const color = colorForTouch(touches[i]);\n    ctx.beginPath();\n    ctx.arc(touches[i].pageX, touches[i].pageY, 4, 0, 2 * Math.PI, false);\n    // 在起点画一个圆。\n    ctx.fillStyle = color;\n    ctx.fill();\n    console.log(\"第 \" + i + \" 个触摸已开始。\");\n  }\n}</code></pre><p>&nbsp;event.preventDefault() 阻止了浏览器继续处理触摸（和鼠标）事件。 然后我们取得上下文，从事件的 TouchEvent.changedTouches 属性中获得已改变的触摸点列表。\n<br>\n<br>上述列表中所有的 Touch 对象即为当前所有活动的触摸点，把它们置于一个数组中，然后为每个触摸绘制起点。我们设置线条宽度为四像素，所以恰好会绘制一个半径为 4 像素的圆。\n<br>\n<br><h3>当触摸移动时绘制\n</h3>在触摸平面上移动一根或者几根手指会触发 touchmove 事件，从而将调用handleMove() 函数。本例中这个函数用于更新触摸点信息，并为每个触摸点从之前位置到当前位置之间绘制直线。</p><pre><code>function handleMove(evt) {\n  evt.preventDefault();\n  const el = document.getElementsByTagName(\"canvas\")[0];\n  const ctx = el.getContext(\"2d\");\n  const touches = evt.changedTouches;\n\n  for (let i = 0; i &lt; touches.length; i++) {\n    const color = colorForTouch(touches[i]);\n    const idx = ongoingTouchIndexById(touches[i].identifier);\n\n    if (idx &gt;= 0) {\n      log(\"继续第 \" + idx + \"个触摸。\");\n      ctx.beginPath();\n      log(\"ctx.moveTo(\" + ongoingTouches[idx].pageX + \", \" + ongoingTouches[idx].pageY + \");\");\n      ctx.moveTo(ongoingTouches[idx].pageX, ongoingTouches[idx].pageY);\n      log(\"ctx.lineTo(\" + touches[i].pageX + \", \" + touches[i].pageY + \");\");\n      ctx.lineTo(touches[i].pageX, touches[i].pageY);\n      ctx.lineWidth = 4;\n      ctx.strokeStyle = color;\n      ctx.stroke();\n\n      ongoingTouches.splice(idx, 1, copyTouch(touches[i])); // 切换触摸信息\n      console.log(\".\");\n    } else {\n      log(\"无法确定下一个触摸点。\");\n    }\n  }\n}</code></pre><p>这个函数不仅对所有已改变的触摸点进行了遍历，还从缓存的触摸信息数组中得到了每个触摸点要绘制的新线段的起点。这是通过读取每个触摸点的 Touch.identifier 属性实现的。对每个触摸点而言，该属性是个唯一的整数，且手指接触表面的整个过程中，这个属性保持不变。\n<br>\n<br>这样我们就可以取得每个触摸点之前位置的坐标，并且使用恰当的上下文方法绘制片段，从而将新旧两个位置连接起来。\n<br>\n<br>当片段绘制完毕后，我们调用 Array.splice() 将 ongoingTouches 数组中触摸点之前的信息替换为当前信息。\n<br>\n<br><h3>触摸结束处理\n</h3>用户的手指从表面抬起时将触发 touchend 事件。我们通过调用下面的 handleEnd() 函数来处理此类事件。 这个函数的工作就是为每个结束的触摸点绘制最后一个片段，然后将触摸点从 ongoingTouches 数组中移除。</p><pre><code>function handleEnd(evt) {\n  evt.preventDefault();\n  log(\"触摸结束。\");\n  const el = document.getElementsByTagName(\"canvas\")[0];\n  const ctx = el.getContext(\"2d\");\n   touches = evt.changedTouches;\n\n  for (let i = 0; i &lt; touches.length; i++) {\n    const color = colorForTouch(touches[i]);\n    const idx = ongoingTouchIndexById(touches[i].identifier);\n\n    if (idx &gt;= 0) {\n      ctx.lineWidth = 4;\n      ctx.fillStyle = color;\n      ctx.beginPath();\n      ctx.moveTo(ongoingTouches[idx].pageX, ongoingTouches[idx].pageY);\n      ctx.lineTo(touches[i].pageX, touches[i].pageY);\n      ctx.fillRect(touches[i].pageX - 4, touches[i].pageY - 4, 8, 8);\n      // 在终点画一个正方形\n      ongoingTouches.splice(idx, 1); // 用完后移除\n    } else {\n      log(\"无法确定要结束哪个触摸点。\");\n    }\n  }\n}</code></pre><p>这个函数与上一个很相像，唯一的实质性区别就是在调用 Array.splice() 时, 我们把用过的触摸实体从 ongoingTouches 数组中直接移除了，不再添加更新信息。对这个触摸点的跟踪随之终止。\n<br>\n<br><h3>触摸取消处理\n</h3>如果用户的手指不小心滑入浏览器界面，或者触摸需要取消时，会触发 touchcancel 事件。从而会调用下面的 handleCancel() 函数：</p><pre><code>function handleCancel(evt) {\n  evt.preventDefault();\n  console.log(\"触摸取消。\");\n  const touches = evt.changedTouches;\n\n  for (let i = 0; i &lt; touches.length; i++) {\n    const idx = ongoingTouchIndexById(touches[i].identifier);\n    ongoingTouches.splice(idx, 1); // 用完后移除\n  }\n}</code></pre><p>这里的想法是立刻结束触摸，所以我们直接从 ongoingTouches 数组中将其移除，而不去绘制最后的片段。\n<br>\n<br><h3>便捷函数\n</h3>本例中使用了几个便捷函数，有必要简单了解一下，对理解其它代码很有帮助。\n<br>\n<br><h3>为每个触摸点选择一个颜色\n</h3>为了区分每个触摸点绘制的内容，我们引入 colorForTouch() 函数，根据每个触摸点所独有的标记设定一个颜色。 这个标记在这里可能是一个无意义的数字，但我们至少可以利用它“对于每个触摸点的值都不同”这一特性。</p><pre><code>function colorForTouch(touch) {\n  let r = touch.identifier % 16;\n  let g = Math.floor(touch.identifier / 3) % 16;\n  let b = Math.floor(touch.identifier / 7) % 16;\n  r = r.toString(16); // 转换为十六进制字符串\n  g = g.toString(16); // 转换为十六进制字符串\n  b = b.toString(16); // 转换为十六进制字符串\n  const color = \"#\" + r + g + b;\n  log(\"identifier \" + touch.identifier + \" 触摸的颜色为：\" + color);\n  return color;\n}</code></pre><p>这个函数返回一个表示颜色的字符串，可以在调用 &lt;canvas&gt; 的函数时使用。比如，若 Touch.identifier 的值为 10, 则返回的字符串为 \"#aaa\"。</p><blockquote>译注：这里的 colorForTouch() 不是一个好主意。Touch.identifier 是一个实验性属性，存在兼容性问题，不同浏览器之间实现方法不同，因此会得到不同的结果。</blockquote><p><h3>拷贝触摸对象\n</h3>有些浏览器（比如 mobile Safari）会在不同事件之间复用触摸点对象，因此只复制所需的部分，要优于引用整个对象。</p><pre><code>function copyTouch(touch) {\n  return {\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY\n  };\n}</code></pre><p><h3>查找触摸点\n</h3>ongoingTouchIndexById() 函数通过遍历 ongoingTouches 数组来寻找与给定标记相匹配的触摸点，返回该触摸点在数组中的下标</p><pre><code>function ongoingTouchIndexById(idToFind) {\n  for (let i = 0; i &lt; ongoingTouches.length; i++) {\n    const id = ongoingTouches[i].identifier;\n\n    if (id == idToFind) {\n      return i;\n    }\n  }\n  return -1;    // 未找到\n}</code></pre><h3>显示后台操作记录</h3><pre><code>function log(msg) {\n  const p = document.getElementById('log');\n  p.innerHTML = msg + \"\\n\" + p.innerHTML;\n}</code></pre><p><h3>处理点击\n</h3>由于在 touchstart（或系列 touchmove 事件里的首个）中调用 preventDefault() 也会阻止相应的鼠标事件的触发，因此一般情况下我们在touchmove 而不是 touchstart 中调用它，这样，鼠标事件仍可正常触发，链接等部件也可继续工作。有些框架采取了一个替代方案，使用触摸事件代替鼠标事件来达到相同目的。 (下面的示例过于简单，可能产生奇怪的行为。这里仅仅作为一个引导。)</p><pre><code>function onTouch(evt) {\n  evt.preventDefault();\n  if (evt.touches.length &gt; 1 || (evt.type == \"touchend\" &amp;&amp; evt.touches.length &gt; 0))\n    return;\n\n  const newEvt = document.createEvent(\"MouseEvents\");\n  let type = null;\n  let touch = null;\n\n  switch (evt.type) {\n    case \"touchstart\":\n      type = \"mousedown\";\n      touch = evt.changedTouches[0];\n      break;\n    case \"touchmove\":\n      type = \"mousemove\";\n      touch = evt.changedTouches[0];\n      break;\n    case \"touchend\":\n      type = \"mouseup\";\n      touch = evt.changedTouches[0];\n      break;\n  }\n\n  newEvt.initMouseEvent(type, true, true, evt.originalTarget.ownerDocument.defaultView, 0,\n    touch.screenX, touch.screenY, touch.clientX, touch.clientY,\n    evt.ctrlKey, evt.altKey, evt.shiftKey, evt.metaKey, 0, null);\n  evt.originalTarget.dispatchEvent(newEvt);\n}</code></pre><h3>只在第二次触摸时调用 preventDefault()</h3><p>为了阻止页面产生类似 pinchZoom 的行为，可以通过“在系列触摸点的第二个调用 preventDefault()”技术来实现。但是该技术的行为并没有在触摸事件的标准中做出完整定义，并且在不同浏览器中会产生不同行为（比如，iOS将阻止缩放，但允许二指平移；Android 允许缩放但阻止平移；Opera 和 Firefox 目前会阻止所有缩放和平移操作）。目前，对于此类情况最好依靠 meta viewport 来阻止缩放，而不要依赖于上述行为。</p>"}}