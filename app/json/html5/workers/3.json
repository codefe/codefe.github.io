{"sta":1,"data":{"subTitle":"Worker线程用法","content":"<p>Worker 线程内部需要有一个监听函数，监听message事件。</p><pre><code>self.addEventListener('message', function (e) {\n  self.postMessage('You said: ' + e.data);\n}, false);</code></pre><p>上面代码中，self代表子线程自身，即子线程的全局对象。因此，等同于下面两种写法。</p><pre><code>// 写法一\nthis.addEventListener('message', function (e) {\n  this.postMessage('You said: ' + e.data);\n}, false);\n\n// 写法二\naddEventListener('message', function (e) {\n  postMessage('You said: ' + e.data);\n}, false);</code></pre><p>除了使用self.addEventListener()指定监听函数，也可以使用self.onmessage指定。监听函数的参数是一个事件对象，它的data属性包含主线程发来的数据。self.postMessage()方法用来向主线程发送消息。</p><p>根据主线程发来的数据，Worker 线程可以调用不同的方法，下面是一个例子。</p><pre><code>self.addEventListener('message', function (e) {\n  var data = e.data;\n  switch (data.cmd) {\n    case 'start':\n      self.postMessage('WORKER STARTED: ' + data.msg);\n      break;\n    case 'stop':\n      self.postMessage('WORKER STOPPED: ' + data.msg);\n      self.close(); // Terminates the worker.\n      break;\n    default:\n      self.postMessage('Unknown command: ' + data.msg);\n  };\n}, false);</code></pre><p>上面代码中，self.close()用于在 Worker 内部关闭自身。<br></p>"}}