{"sta":1,"data":{"subTitle":"Worker数据通信","content":"<p>前面说过，主线程与 Worker 之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给 Worker，后者再将它还原。</p><p>主线程与 Worker 之间也可以交换二进制数据，比如 File、Blob、ArrayBuffer 等类型，也可以在线程之间发送。下面是一个例子。<br></p><pre><code>// 主线程\nvar uInt8Array = new Uint8Array(new ArrayBuffer(10));\nfor (var i = 0; i &lt; uInt8Array.length; ++i) {\n  uInt8Array[i] = i * 2; // [0, 2, 4, 6, 8,...]\n}\nworker.postMessage(uInt8Array);\n\n// Worker 线程\nself.onmessage = function (e) {\n  var uInt8Array = e.data;\n  postMessage('Inside worker.js: uInt8Array.toString() = ' + uInt8Array.toString());\n  postMessage('Inside worker.js: uInt8Array.byteLength = ' + uInt8Array.byteLength);\n};</code></pre><p>但是，拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 Worker 发送一个 500MB 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做Transferable Objects。这使得主线程可以快速把数据交给 Worker，对于影像处理、声音处理、3D 运算等就非常方便了，不会产生性能负担。<br></p><p>\n<br>如果要直接转移数据的控制权，就要使用下面的写法。</p><pre><code>// Transferable Objects 格式\nworker.postMessage(arrayBuffer, [arrayBuffer]);\n\n// 例子\nvar ab = new ArrayBuffer(1);\nworker.postMessage(ab, [ab]);</code></pre><p><br></p>"}}