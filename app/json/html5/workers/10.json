{"sta":1,"data":{"subTitle":"Worker 新建 Worker","content":"<p>Worker 线程内部还能再新建 Worker 线程（目前只有 Firefox 浏览器支持）。下面的例子是将一个计算密集的任务，分配到10个 Worker。</p><p></p><p>主线程代码如下。</p><pre><code>var worker = new Worker('worker.js');\nworker.onmessage = function (event) {\n  document.getElementById('result').textContent = event.data;\n};</code></pre><p>Worker 线程代码如下。</p><pre><code>// worker.js\n\n// settings\nvar num_workers = 10;\nvar items_per_worker = 1000000;\n\n// start the workers\nvar result = 0;\nvar pending_workers = num_workers;\nfor (var i = 0; i &lt; num_workers; i += 1) {\n  var worker = new Worker('core.js');\n  worker.postMessage(i * items_per_worker);\n  worker.postMessage((i + 1) * items_per_worker);\n  worker.onmessage = storeResult;\n}\n\n// handle the results\nfunction storeResult(event) {\n  result += event.data;\n  pending_workers -= 1;\n  if (pending_workers &lt;= 0)\n    postMessage(result); // finished!\n}</code></pre><p>上面代码中，Worker 线程内部新建了10个 Worker 线程，并且依次向这10个 Worker 发送消息，告知了计算的起点和终点。计算任务脚本的代码如下。</p><pre><code>// core.js\nvar start;\nonmessage = getStart;\nfunction getStart(event) {\n  start = event.data;\n  onmessage = getEnd;\n}\n\nvar end;\nfunction getEnd(event) {\n  end = event.data;\n  onmessage = null;\n  work();\n}\n\nfunction work() {\n  var result = 0;\n  for (var i = start; i &lt; end; i += 1) {\n    // perform some complex calculation here\n    result += 1;\n  }\n  postMessage(result);\n  close();\n}</code></pre><p><br></p>"}}