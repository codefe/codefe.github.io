{"sta":1,"data":{"subTitle":"IntersectionObserver API","content":"<h3>语法</h3><pre><code>var io = new IntersectionObserver(callback, option);</code></pre><p>上面代码中，IntersectionObserver是浏览器原生提供的构造函数，接受两个参数：callback是可见性变化时的回调函数，option是配置对象（该参数可选）。\n<br>\n<br>构造函数的返回值是一个观察器实例。实例的observe方法可以指定观察哪个 DOM 节点。</p><pre><code>// 开始观察\nio.observe(document.getElementById('example'));\n\n// 停止观察\nio.unobserve(element);\n\n// 关闭观察器\nio.disconnect();</code></pre><p>上面代码中，observe的参数是一个 DOM 节点对象。如果要观察多个节点，就要多次调用这个方法。</p><pre><code>io.observe(elementA);\nio.observe(elementB);</code></pre><h3>callback 参数</h3><p>目标元素的可见性变化时，就会调用观察器的回调函数callback。\n<br>\n<br>callback一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。</p><pre><code>var io = new IntersectionObserver(\n  entries =&gt; {\n    console.log(entries);\n  }\n);</code></pre><p>\n<br>上面代码中，回调函数采用的是箭头函数的写法。callback函数的参数（entries）是一个数组，每个成员都是一个IntersectionObserverEntry对象。举例来说，如果同时有两个被观察的对象的可见性发生变化，entries数组就会有两个成员。</p><h3>Option 对象</h3><p>IntersectionObserver构造函数的第二个参数是一个配置对象。它可以设置以下属性。</p><h4>threshold 属性</h4><p>threshold属性决定了什么时候触发回调函数。它是一个数组，每个成员都是一个门槛值，默认为[0]，即交叉比例（intersectionRatio）达到0时触发回调函数。</p><pre><code>new IntersectionObserver(\n  entries =&gt; {/* ... */}, \n  {\n    threshold: [0, 0.25, 0.5, 0.75, 1]\n  }\n);</code></pre><p>用户可以自定义这个数组。比如，[0, 0.25, 0.5, 0.75, 1]就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数。</p><h4>root 属性，rootMargin 属性</h4><p>很多时候，目标元素不仅会随着窗口滚动，还会在容器里面滚动（比如在iframe窗口里滚动）。容器内滚动也会影响目标元素的可见性，参见本文开始时的那张示意图。\n<br>\n<br>IntersectionObserver API 支持容器内滚动。root属性指定目标元素所在的容器节点（即根元素）。注意，容器元素必须是目标元素的祖先节点。</p><pre><code>var opts = { \n  root: document.querySelector('.container'),\n  rootMargin: \"500px 0px\" \n};\n\nvar observer = new IntersectionObserver(\n  callback,\n  opts\n);</code></pre><p>上面代码中，除了root属性，还有rootMargin属性。后者定义根元素的margin，用来扩展或缩小rootBounds这个矩形的大小，从而影响intersectionRect交叉区域的大小。它使用CSS的定义方法，比如10px 20px 30px 40px，表示 top、right、bottom 和 left 四个方向的值。\n<br>\n<br>这样设置以后，不管是窗口滚动或者容器内滚动，只要目标元素可见性变化，都会触发观察器。</p>"}}