{"sta":1,"data":{"subTitle":"Pointer Lock API实现的图片无限3D旋转实例","content":"<p>打开本实例，默认进去会看到一个百度的logo，然后点击这张图片：</p><p>Pointer Lock API的图片无限3D旋转\n<br>\n<br>点击图片触发Pointer Lock，此时鼠标会立即消失，同时图片就会根据你的鼠标位置开始翻江倒海。\n<br>\n<br>而且鼠标的活动范围似乎没有边界，即使移动了一万个屏幕的宽度，我们的图片依然翻转个不停。这就是Pointer Lock API的特性表现。\n<br>\n<br>相关代码如下：\n<br>\n<br>CSS代码：</p><pre><code>&lt;style&gt;\n.box {\n    line-height: 400px;\n    text-align: center;\n    position: relative;\n    perspective: 200px;\n}\n.box img {\n    vertical-align: middle;\n}\n&lt;/style&gt;</code></pre><p>HTML代码：</p><pre><code>&lt;div class=\"box\"&gt;\n    &lt;img id=\"image\" src=\"https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png\"&gt;\n&lt;/div&gt;</code></pre><p>JS代码：</p><pre><code>var eleImage = document.getElementById('image');\nif (eleImage) {\n    // 起始值\n    var moveX = 0, moveY = 0;\n    // 图片无限变换的方法\n    var rotate3D = function (event) {\n        moveX = moveX + event.movementX;\n        moveY = moveY + event.movementY;\n\n        eleImage.style.transform = 'rotateX(' + moveY + 'deg) rotateY(' + moveX + 'deg)';  \n    };\n    // 触发鼠标锁定\n    eleImage.addEventListener('click', function () {\n        eleImage.requestPointerLock();\n    });\n    // 再次点击页面，取消鼠标锁定处理\n    document.addEventListener('click', function () {\n        if (document.pointerLockElement == eleImage) {\n            document.exitPointerLock();\n        } \n    });\n    // 检测鼠标锁定状态变化\n    document.addEventListener('pointerlockchange', function () {\n        if (document.pointerLockElement == eleImage) {\n            document.addEventListener(\"mousemove\", rotate3D, false);\n        } else {\n            document.removeEventListener(\"mousemove\", rotate3D, false);\n        }\n    }, false);\n}</code></pre><p>实现原理</p><p>点击图片，执行eleImage.requestPointerLock()让页面进入鼠标锁定状态，此时会触发'pointerlockchange'事件，于是，给页面绑定鼠标移动改变图片旋转的方法，为了避免重复绑定，我们借助document.pointerLockElement判断页面的锁定状态。最后，为了方便取消页面的锁定状态，我们在页面上绑定了点击事件，通过document.exitPointerLock()取消页面的锁定状态。\n<br>\n<br>注意：event.movementX和event.movementY表示每次mousemove事件触发时候，距离上次移动的水平和垂直位置大小，而不是具体的某个坐标值。因此，需要和初始坐标不断的累加确定当前移动位置。\n<br>\n<br>总结\n<br>最后说下Pointer Lock API的兼容性。\n<br>\n<br>由于Pointer Lock API是与鼠标相关的API，因此所有移动端都不支持，因为没有必要支持。\n<br>\n<br>对于桌面浏览器，Chrome，Firefox以及Edge浏览器都是支持的，并且现在使用可以不加私有前缀，直接走起。IE并不支持，但这并不妨碍我们进行增强使用Pointer Lock API。</p><p><br></p>"}}