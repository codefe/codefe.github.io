{"sta":1,"data":{"subTitle":"揭秘webpack按需加载原理","content":"<p>当页面中一个文件过大并且还不一定用到的时候，我们希望在使用到的时才开始加载，这就是按需加载。要实现按需加载，我们一般想到的方法：动态创建script标签，并将src属性指向对应的文件路径。但是在实现过程中，存在下面问题：</p><p><blockquote>怎么保证相同的文件只加载一次？<br>\n怎么判断文件加载完成？<br>\n文件加载完成后，怎么通知所有引入文件的地方？\n</blockquote>\n<br>​    webpcak 的按需加载已经完美解决了上述问题，本着学习的态度，我决定深入探究一下webpack按需加载的实现原理。\n<br>​\t当涉及到动态代码拆分时，webpack 提供了两个类似的技术。对于动态导入，第一种，也是优先选择的方式是，使用符合 ECMAScript 提案 的 import() 语法。第二种，则是使用 webpack 特定的 require.ensure。本文基于官方推荐的import() 语法</p><p>&nbsp;\n<br>下面我们从一个最简单的例子开始</p><p>&nbsp;有两个文件，在入口文件index.js中，通过import()方法，异步引入a.js文件。</p><p>基本环境&nbsp; webpack 4.43.0</p><p>webpack配置为：</p><pre>const path = require('path');\n\nmodule.exports = {\n  mode: 'development',\n  entry: './index.js',\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist'),\n  },\n};</pre><p>index.js</p><pre>import('./a').then((data) =&gt; {\n  console.log(data);\n});</pre><p>a.js</p><pre>const a = 'a模块';\nexport default a;</pre><p>webpack 打包后变成了两个文件 的代码为：</p><p>bundle.js</p><pre>//  bundle.js 把index.js中的import()语句变成了这个样子\n__webpack_require__\n  .e(/*! import() */ 0)\n  .then(__webpack_require__.bind(null, /*! ./a */ './a.js'))\n  .then((data) =&gt; {\n    console.log(data);\n  });</pre><p>我们可以看到webpack打包后的代码把import()语句换成了webpack自定义的webpack_require.e 函数，下面我们就从这个函数看起：<br>webpack_require.e</p><pre>// 定义installedChunks，用来存储加载过的js信息\n/******/ \tvar installedChunks = {\n/******/ \t\t\"main\": 0\n/******/ \t};\n\n/******/ \t__webpack_require__.e = function requireEnsure(chunkId) {\n/******/     \t        // 定义一个存储promise的数组\n/******/ \t\tvar promises = [];\n/******/\n/******/ \t\t// JSONP chunk loading for javascript\n/******/\t\t// installedChunks为一个对象，用来存储加载过的js信息\n/******/ \t\tvar installedChunkData = installedChunks[chunkId];\n/******/ \t\tif(installedChunkData !== 0) { // 0代表已经加载过了\n/******/\n/******/ \t\t\t// 如果已经存在不为0，则代表正在加载\n/******/ \t\t\tif(installedChunkData) {\n    \t\t\t\t\t// installedChunkData[2]存储的是正在加载中的promise\n/******/ \t\t\t\tpromises.push(installedChunkData[2]);\n/******/ \t\t\t} else {\n/******/ \t\t\t\t// 定义一个promise\n/******/ \t\t\t\tvar promise = new Promise(function(resolve, reject) {\n/******/ \t\t\t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n/******/ \t\t\t\t});\n    \t\t\t\t\t// 存储promise\n/******/ \t\t\t\tpromises.push(installedChunkData[2] = promise);\n/******/\n/******/ \t\t\t\t// 创建script标签，开始加载js\n/******/ \t\t\t\tvar script = document.createElement('script');\n/******/ \t\t\t\tvar onScriptComplete;\n/******/\n/******/ \t\t\t\tscript.charset = 'utf-8';\n    \t\t\t\t\t// 设置一个超时时间\n/******/ \t\t\t\tscript.timeout = 120;\n/******/ \t\t\t\tif (__webpack_require__.nc) {\n/******/ \t\t\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n/******/ \t\t\t\t}\n    \t\t\t\t\t// 获取src，并赋值\n/******/ \t\t\t\tscript.src = jsonpScriptSrc(chunkId);\n/******/\n/******/ \t\t\t\t// 创建一个error，在加载出错后返回\n/******/ \t\t\t\tvar error = new Error();\n    \t\t\t\t\t// 定义加载完成后的时间\n/******/ \t\t\t\tonScriptComplete = function (event) {\n/******/ \t\t\t\t\t// avoid mem leaks in IE.\n/******/ \t\t\t\t\tscript.onerror = script.onload = null;\n/******/ \t\t\t\t\tclearTimeout(timeout);\n    \t\t\t\t\t\t// 判断是否加载成功\n/******/ \t\t\t\t\tvar chunk = installedChunks[chunkId];\n    \t\t\t\t\t\t// 不成功，进行错误处理\n/******/ \t\t\t\t\tif(chunk !== 0) {\n/******/ \t\t\t\t\t\tif(chunk) {\n/******/ \t\t\t\t\t\t\tvar errorType = event &amp;&amp; (event.type === 'load' ? 'missing' : event.type);\n/******/ \t\t\t\t\t\t\tvar realSrc = event &amp;&amp; event.target &amp;&amp; event.target.src;\n/******/ \t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n/******/ \t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n/******/ \t\t\t\t\t\t\terror.type = errorType;\n/******/ \t\t\t\t\t\t\terror.request = realSrc;\n/******/ \t\t\t\t\t\t\tchunk[1](error);\n/******/ \t\t\t\t\t\t}\n/******/ \t\t\t\t\t\tinstalledChunks[chunkId] = undefined;\n/******/ \t\t\t\t\t}\n/******/ \t\t\t\t};\n/******/ \t\t\t\tvar timeout = setTimeout(function(){\n/******/ \t\t\t\t\tonScriptComplete({ type: 'timeout', target: script });\n/******/ \t\t\t\t}, 120000);\n    \t\t\t\t\t// 加载成功和失败都走onScriptComplete，具体原因看下文\n/******/ \t\t\t\tscript.onerror = script.onload = onScriptComplete;\n/******/ \t\t\t\tdocument.head.appendChild(script);\n/******/ \t\t\t}\n/******/ \t\t}\n    \t\t\t// 返回promise\n/******/ \t\treturn Promise.all(promises);\n/******/ \t};</pre><p>\n</p><p>这段代码总共干了这几件事：<br><br>1. 定义一个promise数组，用来存储promise.<br>2. 判断是否已经加载过，如果加载过，返回一个空数组的promise.all().<br>3. 如果正在加载中，则返回存储过的此文件对应的promise.<br>4. 如果没加载过，先定义一个promise，然后创建script标签，加载此js，并定义成功和失败的回调<br>5. 返回一个promise<br><br>只看这个函数，我们可能还有一下疑问：<br><br>1. 判断有无加载过是通过判断installedChunks[chunkId]的值是否为0，但在script.onerror/script.onload回调函数中并没有把installedChunks[chunkId]的值置为0<br>2. promise 把 resolve 和 reject 全部存入了 installedChunks 中， 并没有在获取异步chunk成功的onload 回调中执行 resolve，那么，resolve 是什么时候被执行的呢?<br><br>针对这两个问题，我们需要看一下打包后的另一个文件：</p><p>0.bundle.js<br></p><pre>(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[0],{\n\n/***/ \"./a.js\":\n/*!**************!*\\\n  !*** ./a.js ***!\n  \\**************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\nconst a = 'a模块';\\r\\n/* harmony default export */ __webpack_exports__[\\\"default\\\"] = (a);\\n\\n//# sourceURL=webpack:///./a.js?\");\n\n/***/ })\n\n}]);</pre><p>我们看到，在此文件中，会执行window[\"webpackJsonp\"].push()方法，即每次加载完一个文件，就会执行全局的webpackJsonp数组的push方法，此push方法就是关键：</p><p>bundle.js</p><pre>/******/    // 定义全局数组window[\"webpackJsonp\"]，并重写window[\"webpackJsonp\"]的push方法 \t\n/******/    var jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n/******/ \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n/******/ \tjsonpArray.push = webpackJsonpCallback;\n\n\t\t// 重写window[\"webpackJsonp\"]的push方法 \n/******/ \tfunction webpackJsonpCallback(data) {\n/******/ \t\tvar chunkIds = data[0];\n/******/ \t\tvar moreModules = data[1];\n/******/\n/******/\n/******/ \t\t// add \"moreModules\" to the modules object,\n/******/ \t\t// then flag all \"chunkIds\" as loaded and fire callback\n/******/ \t\tvar moduleId, chunkId, i = 0, resolves = [];\n/******/ \t\tfor(;i &lt; chunkIds.length; i++) {\n/******/ \t\t\tchunkId = chunkIds[i];\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) &amp;&amp; installedChunks[chunkId]) {\n    \t\t\t\t\t// 获取此js文件对应的promise中的resolve方法数组\n/******/ \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n/******/ \t\t\t}\n    \t\t\t\t// 把installedChunks[chunkId] 置为0，代表已经加载过\n/******/ \t\t\tinstalledChunks[chunkId] = 0;\n/******/ \t\t}\n/******/ \t\tfor(moduleId in moreModules) {\n/******/ \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n/******/ \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n/******/ \t\t\t}\n/******/ \t\t}\n/******/ \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n/******/\t\t\n    \t\t\t// 执行此js文件对应的promise中的resolve方法\n/******/ \t\twhile(resolves.length) {\n/******/ \t\t\tresolve.shift()();\n/******/ \t\t}\n/******/\n/******/ \t};</pre><p>bundle.js的这几段代码干了这几件事：</p><p>1. 定义全局数组window[\"webpackJsonp\"]，并重写window[\"webpackJsonp\"]的push方法<br>2. 在新的push方法中，把installedChunks[chunkId]置为0，代表已经加载过，并执行js对应的promise的resolve方法<br><br></p><p><h3>总结</h3>最后，我们再回答 一下文章开头的三个问题：<br>1、怎么保证相同的文件只加载一次？<br>​\t  答：定义installedChunks对象，存储异步js的promise回调，如果已经加载过，则返回一个空数组的promise.all([])，如果在加载过程中，则返回已经存储过的此文件对应的promise。<br>2、怎么判断文件加载完成？<br>​\t  答：1、在主文件中定义一个全局数组，并重写其push方法，在异步文件中执行此全局数组的push方法。<br>​\t\t\t  2、在重写的方法中执行promise的resolve回调。<br>3、文件加载完成后，怎么通知所有引入文件的地方？<br>​\t  答：同2<br><br><br></p>"}}