{"sta":1,"data":{"subTitle":"使用 .vue 文件来完成骨架屏","content":"<p>我们可能不希望在默认的模版(index.html)上来进行代码的coding；想在方案一的基础上，将骨架屏的代码抽离出来，使用一个 .vue 文件来 coding，易于维护。<br></p><p>1、我们在 src 下建一个 skeleton 目录，在里面创建两个文件（skeleton.vue、skeleton.entry.js）；skeleton.vue 就是我们的骨架屏页面的代码，skeleton.entry.js 是编译 skeleton.vue 的入口文件，类似于我们 Vue 项目中的 main.js 文件；<br><br></p><pre><code>// skeleton.entry.js\nimport Vue from 'vue'\nimport Skeleton from './skeleton.vue'\n\nexport default new Vue({\n  // 根实例简单的渲染应用程序组件\n  render: h =&gt; h(Skeleton)\n})</code></pre><p><br></p><pre><code>&lt;!-- skeleton.vue --&gt;\n&lt;template&gt;\n  &lt;div class=\"skeleton page\"&gt;\n    &lt;span&gt;骨架屏&lt;/span&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;style scoped&gt;\n&lt;/style&gt;</code></pre><p><br></p><p>2、我们还需要在新建一个 webpack.skeleton.conf.js 文件，以专门用来进行骨架屏的构建（这个文件放在哪里无所谓，可以放在根目录下，也可以放在 build 目录中）。这是一个 webpack 的配置文件，配合使用 vue-server-renderer 将我们的 skeleton.vue 文件内容构建为单个的 json 格式的文件（这是 Vue SSR 渲染的策略）<br></p><pre><code>// webpack.skeleton.conf.js\n'use strict'\nconst path = require('path')\nconst nodeExternals = require('webpack-node-externals')\nconst VueSSRServerPlugin = require('vue-server-renderer/server-plugin')\n\nmodule.exports = {\n  target: 'node',\n  devtool: '#source-map',\n  entry: './src/skeleton/skeleton.entry.js',\n  output: {\n    path: path.resolve(__dirname, '../dist'),\n    publicPath: '/dist/',\n    filename: '[name].js',\n    libraryTarget: 'commonjs2'\n  },\n  module: {\n    noParse: /es6-promise\\.js$/,  // avoid webpack shimming process\n    rules: [\n      {\n        test: /\\.vue$/,\n        loader: 'vue-loader',\n        options: {\n          compilerOptions: {\n            preserveWhitespace: false\n          }\n        }\n      },\n      {\n        test: /\\.css$/,\n        use: ['vue-style-loader', 'css-loader']\n      }\n    ]\n  },\n  performance: {\n    hints: false\n  },\n  externals: nodeExternals({\n    // do not externalize CSS files in case we need to import it from a dep\n    whitelist: /\\.css$/\n  }),\n  plugins: [\n    // 这是将服务器的整个输出构建为单个 JSON 文件的插件。\n    // 默认文件名为 `vue-ssr-server-bundle.json`\n    new VueSSRServerPlugin({\n      filename: 'skeleton.json'\n    })\n  ]\n}</code></pre><p><br></p><p>3、写完 skeleton.vue 的内容以后，使用 webpack-cli 运行这个 webpack.skeleton.conf.js 配置文件。</p><pre><code>// package.json\n\"skeleton\": \"webpack --progress --config build/webpack.skeleton.conf.js\"</code></pre><p>然后运行：</p><pre><code>npm i webpack-cli@3.3.10 -D\nnpm run skeleton</code></pre><p>就会在 dist 文件夹中生成一个skeleton.json 文件。</p><p><br></p><p>4、将 skeleton.json 内容插入到模版文件 index.html 中。（在根目录下创建一个 skeleton.js 文件）</p><pre><code>// skeleton.js\nconst fs = require('fs')\nconst { resolve } = require('path')\nconst { createBundleRenderer } = require('vue-server-renderer')\n\nfunction createRenderer(bundle, options) {\n  return createBundleRenderer(bundle, Object.assign(options, {\n    // recommended for performance\n    // runInNewContext: false\n  }))\n}\n\nconst handleError = err =&gt; {\n  console.error(`error during render : ${req.url}`)\n  console.error(err.stack)\n}\n\nconst bundle = require('./dist/skeleton.json')\nconst templatePath = resolve('./index.html')\nconst template = fs.readFileSync(templatePath, 'utf-8')\nconst renderer = createRenderer(bundle, {\n  template\n})\n\n// console.log(renderer)\n\n/**\n * 说明：\n * 默认的index.html中包含&lt;%= BASE_URL %&gt;的插值语法\n * 我们不在生成骨架屏这一步改变模板中的这个插值\n * 因为这个插值会在项目构建时完成\n * 但是如果模板中有这个插值语法，而我们在vue-server-renderder中使用这个模板，而不传值的话，是会报错的\n * 所以，我们去掉模板中的插值，而使用这个传参的方式，再将这两个插值原模原样返回到模板中\n * \n * 文档： https://cli.vuejs.org/zh/guide/html-and-static-assets.html#%E6%8F%92%E5%80%BC\n */\nconst context = {\n  title: '',  // default title\n  meta: `&lt;meta name=\"theme-color\" content=\"#4285f4\"&gt;\n    &lt;link rel=\"icon\" href=\"&lt;%= BASE_URL %&gt;favicon.ico\"&gt;\n    &lt;link rel=\"stylesheet\" href=\"&lt;%= BASE_URL %&gt;css/reset.css\"&gt;`\n}\n\nrenderer.renderToString(context, (err, html) =&gt; {\n  if(err) {\n    return handleError(err)\n  }\n  fs.writeFileSync(resolve(__dirname, './index.html'), html, 'utf-8')\n})</code></pre><p><br></p><p>5、模版 index.html 加上插槽注解 这里需要注意的是：index.html 中的 div#app 中要加一个注解插槽，&lt;!--vue-ssr-outlet--&gt; 这个是必须的，Vue SSR 文档中有说这个。这个注解是必须的，请注意！</p><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\"&gt;\n    &lt;title&gt;vue-for-test&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"app\"&gt;\n      &lt;!--vue-ssr-outlet--&gt;\n    &lt;/div&gt;\n    &lt;!-- built files will be auto injected --&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre><p><br></p><p>6、执行</p><pre><code>node skeleton.js</code></pre><p>执行成功后，模版 index.html 中的 div#app 中的内容就会变成我们的骨架屏代码；</p><p><br></p>"}}