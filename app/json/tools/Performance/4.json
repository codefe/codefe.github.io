{"sta":1,"data":{"subTitle":"动画分析","content":"<p>有了上面这些准备，相信你已开始摩拳擦掌了。我们在示例仓库下跑另外一个 Demo：</p><blockquote>cd chrome-preformance-use-demo &amp;&amp; npm run demo2</blockquote><p><img src=\"./app/json/tools/Performance/img/12.jpeg\" style=\"max-width:100%;\" class=\"\"></p><p>初始状态下，10个小方块会分别上下匀速运动，碰到浏览器边界后原路返回。「Add 10」是增加 10 个这样的小方块，「Substract 10」是减少 10 个，「Stop/Start」暂停/开启所有小方块的运动，「Optimize/Unoptimize」优化/取消优化动画。\n<br>\n<br>浏览器是怎么绘制一帧动画的\n<br>\n<br>在默认状态下，我们点击左上角的圆记录事件，几秒后我们可以点击 Performance 中的 Stop 产生分析数据。在概览面板中我们看到在渡过最初的几百毫秒后，CPU 面积图中各种事件占比按固定周期变化，我们点取其中一小段观察，在主线程图中可看到一段一段类似事件组。观察几组事件后，我们发现，这些事件组的组成都是：10 个 Recalculate Style + Layout 的循环 -&gt; Update Layer Tree -&gt; Paint -&gt; Composite Layers。我们知道，Composite Layers 事件之后，意味着人眼可见新的页面图层，也就是说这样一组事件过后，一帧画面绘制在眼前。</p><p><img src=\"./app/json/tools/Performance/img/13.jpeg\" style=\"max-width:100%;\" class=\"\"></p><p>我们点开主线程火焰图的上一栏「Framse」，发现 Composite Layers 事件后不久的虚线处就是下一帧画面出现的节点，这侧面证实了上面的结论。</p><p><img src=\"./app/json/tools/Performance/img/14.jpeg\" style=\"max-width:100%;\" class=\"\"></p><p>当瓶颈出现时\n<br>\n<br>目前的动画看着没什么毛病，我们点击 20 次「Add 10」按钮，增加方块数，可以看到动画出现了明显的卡顿，如果还不感觉卡顿，说明你的计算机性能已经击败了全国 99% 的用户（或者，呃...你可能要去医院看眼睛了），这时你可以在控制面板里降低 CPU 算力。好了，我们再次记录性能数据：</p><p><img src=\"./app/json/tools/Performance/img/15.jpeg\" style=\"max-width:100%;\" class=\"\"></p><p>我们看到报告中有多处醒目的红色，包括帧率图上的大红杠、主线程图中的小角标。\n<br>\n<br>再次按照之前的思路，查看主线程的细节，我们发现在 app.update 函数下发生的 Recalculate Style 和 Layout 事件都出现了警告，提示性能瓶颈的原因可能是强制重排。进入 js 文件查看详细代码，在左栏可以看到消耗了大量时间的代码行呈深黄色，那么这些代码就很有可能是症结所在。</p><p><img src=\"./app/json/tools/Performance/img/16.jpeg\" style=\"max-width:100%;\" class=\"\"></p><p><blockquote>注意：自动计算代码行运算时间需要取消勾选控制面版的「Disable JavaScript Samples」选项。\n</blockquote>\n<br>那么，这行代码到底有什么问题呢，重排又是什么呢？\n<br>\n<br>再谈重排与重绘\n<br>\n<br>简而言之，重排（reflow）和重绘（repaint）都是改变页面样式的步骤。重排步骤包括 Recalculate Style、Layout、Update Layer Tree 等渲染类型事件，重绘步骤包括 Paint 和 Composite Layers 这些绘制类型事件。重排之后必然会造成重绘，而造成重绘的操作不一定会造成重排。下面列出了一些造成重排或重绘的常见操作，更多操作可以参阅 csstriggers</p><p><img src=\"./app/json/tools/Performance/img/17.jpeg\" style=\"max-width:100%;\" class=\"\"></p><p>由于计算布局需要大量时间，重排的开销远大于重绘，在达到相同效果的情况下，我们需要尽量避免重排。举个例子，如果 display: none 和 visibility: hidden 都能满足需求，那么后者更优。\n<br>\n<br>解决瓶颈\n<br>\n<br>再回头看一下我们的动画 Demo，在 performance 的详情面板中，饼图显示动画的绘制过程中渲染（重排）占据的大部分的比重，结合代码我们发现原因：循环中多次在刚给 DOM 更新样式位置后，立即通过 offsetTop 获取 DOM 位置。这样的操作会强制启动重排，因为浏览器并不清楚上一个循环内 DOM 有没有改变位置，必须立即重新布局才能计算 DOM 位置。别急，你可能已经注意到了，我们还有一个「Optimize」按钮。\n<br>\n<br>针对这个问题，我们的优化方案是将 offsetTop 替换成 style.top，后者虽然取的是上一帧动画的元素位置，但并不影响计算下一帧动画位置，省去了重排获取位置的过程，减少了不必要的重排。</p><blockquote>注意：本示例中，还有一处优化是非 Optimize 的情况下就做了的，就是通过 requestAnimationFrame 函数将一帧循环内所有的样式改动（<br>\n m.style.top = pos + 'px';<br>\n ）累计在下一次绘制时统一处理。这样做除了优化了样式的写操作，还让我们更清楚地观察到 offsetTop 读操作这个问题的现象。</blockquote><p>我们对比一下优化前后的报告：</p><p>&nbsp;<br></p><img src=\"./app/json/tools/Performance/img/18.jpeg\" style=\"max-width:100%;\"><p>首先从饼图和 CPU 面积图看，Rendering 事件占比下滑，Painting 事件占比上升。而从帧率图和 frames 线程图中分别可看到，帧率明显上升，一帧图像的绘制时间明显下降，意味着动画流畅性大幅提高，优化目的已达到。再看细节，我们发现绘制一帧动画的事件组中，app.update 函数里没有了 Recalculate style 和 Layout 事件，整个函数执行时间因此显著下降，证明我们的优化方案起了作用。<br></p><p><br></p><p><br></p><p><br></p><p><br></p>"}}