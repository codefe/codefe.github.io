{"sta":1,"data":{"subTitle":"Jest前端自动化测试","content":"<h3>1. Jest特点</h3><ol><li>&nbsp;Jest的基础： 包括基础API，异步测试，Mock技巧，快照功能，定时器，延时器，Dom节点测试。\n</li><li>&nbsp;Vue项目的测试： vue-test-utils工具的讲解，TDD单元测试，BDD集成测试的知识和操作\n</li><li>&nbsp;React项目的测试： Enzyme工具的讲解，TDD单元测试，BDD集成测试的知识和操作</li></ol><h3>2. test 测试方法</h3><h4>使用格式</h4><blockquote><p>test('要测试的描述',()=&gt;{\n<br>    &nbsp;&nbsp;&nbsp;&nbsp;//内容\n<br>})</p></blockquote><h4>可以传2个参数</h4><ol><li>&nbsp;第一个是测试描述\n</li><li>-第二个是函数</li></ol><h3>3. expect 预期方法</h3><blockquote><p>expect(方法名(参数)).toBe('要得到的结果')</p></blockquote><h3>4. 代码覆盖率</h3><blockquote>- npx jest --init<br>\n- npx jest --coverage</blockquote><h3>5. 匹配器</h3><h4>5.1 toBe 相当于 === 严格相等</h4><blockquote>expect('xxx').toBe('xxx')</blockquote><h4>5.2 toEqual 相当于 == 内容相等</h4><blockquote>const a = {name:'zs'}<br>\nexpect(a).toEqual({name:'zs'})</blockquote><h4>5.3 toBeNull  只匹配`null`值</h4><blockquote>const a = null<br>\nexpect(a).toBeNull()</blockquote><h4>5.4 toBeUndefined  匹配 undefined, 空也不匹配</h4><blockquote>const a = undefined<br>\nexpect(a).toBeUndefined()</blockquote><h4>5.5 toBeDefined 只要定义过了，都可以匹配成功</h4><blockquote>const a = 1<br>\nexpect(a).toBeDefined()</blockquote><h4>5.6 toBeTruthy  判断值为true时匹配</h4><h4>5.7 toBeFalsy     判断值为false时匹配</h4><h4>5.8 toBeGreaterThan 大于什么数值匹配</h4><h4>5.9 toBeLessThan 少于一个数字时匹配</h4><h4>5.10 toBeGreaterThanOrEqual 数据大于等于期待数字时匹配</h4><h4>5.11 toBeLessThanOrEqual  数据少于等于期待数字时匹配</h4><h4>5.12 toBeCloseTo 可以自动消除`JavaScript`浮点精度错误的匹配器</h4><blockquote>expect(0.1 + 0.2).toEqual(0.3)//不匹配<br>\nexpect(0.1 + 0.2).toBeCloseTo(0.3)//匹配</blockquote><h4>5.13 toMatch 字符串包含匹配器</h4><blockquote>const str=\"谢大脚、刘英、小红\"<br>\nexpect(str).toMatch('谢大脚')<br>\nexpect(str).toMatch(/谢大脚/)</blockquote><h4>5.14 toContain 数组的匹配器</h4><blockquote>const arr=['谢大脚','刘英','小红']<br>\nexpect(arr).toContain('谢大脚')<br>\n// or<br>\nconst arr=['谢大脚','刘英','小红']<br>\nconst data = new Set(arr)<br>\nexpect(data).toContain('谢大脚')</blockquote><h4>5.15 toThrow 检测一个方法会不会抛出异常</h4><blockquote>const throwNewErrorFunc = ()=&gt;{<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;throw new Error('this is a new error')<br>\n}\n<br>test('toThrow匹配器',()=&gt;{<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;expect(throwNewErrorFunc).toThrow()<br>\n})<br>\n// or toThrow中字符串匹配才通过<br>\nexpect(throwNewErrorFunc).toThrow('this is a new error')</blockquote><h4>5.16 not 相反</h4><blockquote>const throwNewErrorFunc = ()=&gt;{<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;throw new Error('this is a new error')<br>\n}\n<br>test('toThrow匹配器',()=&gt;{<br>\n    &nbsp;&nbsp;&nbsp;&nbsp;expect(throwNewErrorFunc).not.toThrow()<br>\n})<br>\n//现在这个测试用例就不能通过测试了，我们需要删除或注释掉抛出的异常，才可以通过测试。</blockquote><h3>6. 让Jest支持import语法</h3><h4>6.1 安装依赖包 @babel/core  @babel/preset-env -D</h4><h4>6.2 配置.babelrc文件</h4><pre>{\n    \"presets\":[\n        [\n            \"@babel/preset-env\",{\n            \t\"targets\":{\n            \t\t\"node\":\"current\"\n            \t}\n            }\n        ]\n    ]\n}</pre><p><br></p><h3>7. 异步代码测试</h3><pre>//假设下面请求地址返回值为\n{\n    success:true\n}</pre><h4>7.1 测试1</h4><pre>//fetchData.js\nimport axios from 'axios'\nexport const fetchData = (fn) =&gt; {\n    axios.get('xxx').then(response=&gt;{\n        fn(response.data)\n    })\n}\n//fetchData.test.js\nimport { fetchData } from './fetchData.js'\ntest('fetchData 方法测试',(done)=&gt;{\n    fetchData((data)=&gt;{\n        expect(data).toEqual({\n            success: true\n        })\n        done()<font color=\"#c24f4a\">//如果没有这个测试也是通过，不过没有等到数据返回</font>\n    })\n})</pre><h4>7.2 测试2</h4><pre>//fetchData.js\nimport axios from 'axios'\nexport const fetchData = () =&gt; {\n    return axios.get('xxx')\n}\n//fetchData.test.js\nimport { fetchData } from './fetchData.js'\ntest('fetchData 方法测试',()=&gt;{\n   return fetchData().then((res)=&gt;{<font color=\"#c24f4a\">//一定要加 return</font>\n        expect(res.data).toEqual({\n            success: true\n        })\n    })\n})</pre><h4>7.3 404测试</h4><pre>//fetchData.js\nimport axios from 'axios'\nexport const fetchData = () =&gt; {\n    return axios.get('xxx')\n}\n//fetchData.test.js\nimport { fetchData } from './fetchData.js'\ntest('fetchData 方法测试',()=&gt;{\n   expect.assertions(1)<font color=\"#c24f4a\">//断言，必须执行一次 expect</font>\n    <font color=\"#c24f4a\">//因为捕获的是catch,正常的就不会走这里，直接通过了，所以要加上，上面一句</font>\n    return fetchData().catch((err)=&gt;{\n        expect(e.toString().indexOf('404')&gt;-1).toBe(true)\n    })\n})</pre><h4>7.4 await测试</h4><pre>//fetchData.js\nimport axios from 'axios'\nexport const fetchData = () =&gt; {\n    return axios.get('xxx')\n}\n//fetchData.test.js\nimport { fetchData } from './fetchData.js'\ntest('fetchData 方法测试',async()=&gt;{\n    //方法一\n    await expect(fetchData()).resolves.toMatchObject({\n        data:{\n            success:true\n        }\n    })\n    //方法二\n    const res = await fetchData()\n    expect(res.data).toEqual({\n        success:true\n    })\n})</pre><h3>8. 生命周期钩子</h3><h4>8.1 beforeAll&nbsp;</h4><pre>// 在所有测试用例之前进行执行\nbeforeAll(()=&gt;{\n    console.log('beforeAll')\n})</pre><h4>8.2 afterAll</h4><pre>// 在所有测试用例之后进行执行\nafterAll(()=&gt;{\n    console.log('afterAll')\n})</pre><h4>8.3 beforeEach</h4><pre>// 在每个测试用例前都会执行一次的钩子函数\nbeforeEach(()=&gt;{\n    console.log('beforeEach...')\n})</pre><h4>8.4 afterEach</h4><pre>// 在每次测试用例完成测试之后执行一次的钩子函数\nafterEach(()=&gt;{\n    console.log('afterEach...')\n})</pre><h3>9. 测试用例分组 describe</h3><pre>describe('描述',()=&gt;{\n    // 把相关的测试用例写在这里\n})</pre><h3>10. 钩子函数作用域</h3><ol><li>- 钩子函数在父级分组可作用域子集，类似继承\n</li><li>- 钩子函数同级分组作用域互不干扰，各起作用\n</li><li>- 先执行外部的钩子函数，再执行内部的钩子函数</li></ol><h3>11. only</h3><p>在有很多测试用例时，可以加上only只看这一个</p><blockquote>test.only()</blockquote><p><br></p>"}}