{"sta":1,"data":{"subTitle":"组件render优化","content":"<p>首先我来画一张图对组件render优化方案有一个整体的认识：<br></p><p><img src=\"/app/json/frames/react/img/render.png\" style=\"max-width:100%;\" class=\"\"></p><h3>1 class组件引PureComponent或者shouldComponentUpdate进行render优化</h3><h4>1.1 传入的props是基础数据类型的class组件处理方式 ---&gt; PureComponent处理</h4><p>如代码所示，父组件触发 render，无论子组件使用到父组件的 state 作为 props 值是否改变，甚至无论子组件是否使用到父组件的 state，都会触发子组件 render。</p><blockquote>注意，这里我们说的 render 不是浏览器的渲染，而是 react 的 render 函数，触发 react 的 render 函数并不一定会触发浏览器的渲染，因为 react 还有 dom diff 比较的过程</blockquote><p>更进一步的说，当业务场景变得复杂、应用规模变得庞大：组件数量越来越多、组件层次越来越深，组件不必要的触发 render 带来的性能问题越明显。</p><pre>class ChildOne extends React.Component {\n    constructor(props) {\n        super(props)\n    }\n\n    render() {\n        const {value} = this.props;\n        console.log('触发子组件 ChildOne 的 render')\n        return (\n            &lt;div className=\"box\"&gt;\n                &lt;p&gt; 子组件 ChildOne&lt;/p&gt;\n                &lt;div&gt; 父组件传入 props 数据{value}&lt;/div&gt;\n            &lt;/div&gt;\n        );\n    }\n}\n\nclass ChildTwo extends React.Component {\n    constructor(props) {\n        super(props)\n    }\n\n    render() {\n        console.log('触发子组件 ChildTwo 的 render')\n        return (\n            &lt;div className=\"box\"&gt;\n                &lt;p&gt; 子组件 ChildTwo&lt;/p&gt;\n            &lt;/div&gt;\n        );\n    }\n}\n\nclass App extends React.Component {\n    state = {\n        value: 1,\n    };\n\n    handleClick = () =&gt; {\n        this.setState({\n            value: 1\n        });\n    };\n\n    render() {\n        console.log('触发父组件的 render')\n        return (\n            &lt;React.Fragment&gt;\n                &lt;div className=\"box\"&gt;\n                    &lt;div&gt;{this.state.value}&lt;/div&gt;\n                    &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt;\n                &lt;/div&gt;\n                &lt;ChildOne value={this.state.value}/&gt;\n                &lt;ChildTwo/&gt;\n            &lt;/React.Fragment&gt;\n        );\n    }\n}\n\nReactDOM.render(&lt;App/&gt;, document.getElementById(\"root\"))</pre><p>运行过程如下：</p><p><img src=\"/app/json/frames/react/img/render1.png\" style=\"max-width:100%;\" class=\"\"></p><p><br></p><p>那究竟该如何解决这类问题呢。针对 class 组件和函数组件，react 给出了不同的处理方式,这里我们先用PureComponent的方式进行class组件的处理方式。\n<br>\n<br>点击按钮后发现，父组件触发 render 后，两个子组件的 render 均未触发。先见代码：</p><pre>class ChildOne extends React.PureComponent {\n    constructor(props) {\n        super(props)\n    }\n\n    render() {\n        const {value} = this.props;\n        console.log('触发子组件 ChildOne 的 render')\n        return (\n            &lt;div className=\"box\"&gt;\n                &lt;p&gt; 子组件 ChildOne&lt;/p&gt;\n                &lt;div&gt; 父组件传入 props 数据{value}&lt;/div&gt;\n            &lt;/div&gt;\n        );\n    }\n}\n\nclass ChildTwo extends React.PureComponent {\n    constructor(props) {\n        super(props)\n    }\n\n    render() {\n        console.log('触发子组件 ChildTwo 的 render')\n        return (\n            &lt;div className=\"box\"&gt;\n                &lt;p&gt; 子组件 ChildTwo&lt;/p&gt;\n            &lt;/div&gt;\n        );\n    }\n}\n\nclass App extends React.Component {\n    state = {\n        value: 1,\n    };\n\n    handleClick = () =&gt; {\n        this.setState({\n            value: 1\n        });\n    };\n\n    render() {\n        console.log('触发父组件的 render')\n        return (\n            &lt;React.Fragment&gt;\n                &lt;div className=\"box\"&gt;\n                    &lt;div&gt;{this.state.value}&lt;/div&gt;\n                    &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt;\n                &lt;/div&gt;\n                &lt;ChildOne value={this.state.value}/&gt;\n                &lt;ChildTwo/&gt;\n            &lt;/React.Fragment&gt;\n        );\n    }\n}\n\nReactDOM.render(&lt;App/&gt;, document.getElementById(\"root\"))</pre><p>我们再上图：</p><p><img src=\"/app/json/frames/react/img/render2.png\" style=\"max-width:100%;\" class=\"\"></p><h4>1.2 传入的props是复杂数据类型的class组件处理方式 ---&gt; shouldComponentUpdate</h4><p>先看一段代码：\n<br>\n<br>父组件的 state 中的 value 是复杂数据类型值：传入子组件 ChildOne 的 props 是个对象，且 ChildOne 仍然继承自 React.PureComponent</p><pre>class ChildOne extends React.PureComponent {\n    constructor(props) {\n        super(props)\n    }\n\n    render() {\n        const {value} = this.props;\n        console.log('触发子组件 ChildOne 的 render')\n        return (\n            &lt;div className=\"box\"&gt;\n                &lt;p&gt; 子组件 ChildOne&lt;/p&gt;\n                &lt;div&gt; 父组件传入 props 数据{value.number}&lt;/div&gt;\n            &lt;/div&gt;\n        );\n    }\n}\n\nclass App extends React.Component {\n    state = {\n        value: {\n            number: 1,\n        }\n    };\n\n    handleClick = () =&gt; {\n        this.setState({\n            value: {\n                number: 1\n            }\n        });\n    };\n\n    render() {\n        console.log('触发父组件的 render')\n        return (\n            &lt;React.Fragment&gt;\n                &lt;div className=\"box\"&gt;\n                    &lt;div&gt;{this.state.value.number}&lt;/div&gt;\n                    &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt;\n                &lt;/div&gt;\n                &lt;ChildOne value={this.state.value}/&gt;\n            &lt;/React.Fragment&gt;\n        );\n    }\n}\n\nReactDOM.render(&lt;App/&gt;, document.getElementById(\"root\"))</pre><p>运行发现：\n<br>点击按钮后查看控制台，子组件还是触发了 render。这是因为子组件虽然继承自 PureComponent，但 PureComponent 只能进行浅比较，传入的 value 对象的表面值没有改变都是{number:1}，但是千万别忘了 setState() 后返回的都是新对象，前后两个对象的指针并不相等，这也就是为什么会触发子组件 render 的原因。</p><p><img src=\"/app/json/frames/react/img/render3.png\" style=\"max-width:100%;\" class=\"\"></p><p>那该如何解决这种问题呢？这里就要用到React 提供的新生命周期 shouldComponentUpdate：</p><pre>class ChildOne extends React.Component {\n    constructor(props) {\n        super(props)\n    }\n\n    shouldComponentUpdate(nextProps, nextState) {\n        console.log('nextProps', nextProps)\n        console.log('this.props', this.props)\n        return nextProps.value.number !== this.props.value.number\n    }\n\n    render() {\n        console.log('触发子组件 ChildTwo 的 render')\n        return (\n            &lt;div className=\"box\"&gt;\n                &lt;p&gt; 子组件 ChildTwo&lt;/p&gt;\n            &lt;/div&gt;\n        );\n    }\n}\n\nclass App extends React.Component {\n    state = {\n        value: {\n            number: 1,\n        }\n    };\n\n    handleClick = () =&gt; {\n        this.setState({\n            value: {\n                number: 1\n            }\n        });\n    };\n\n    render() {\n        console.log('触发父组件的 render')\n        return (\n            &lt;React.Fragment&gt;\n                &lt;div className=\"box\"&gt;\n                    &lt;div&gt;{this.state.value.number}&lt;/div&gt;\n                    &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt;\n                &lt;/div&gt;\n                &lt;ChildOne value={this.state.value}/&gt;\n            &lt;/React.Fragment&gt;\n        );\n    }\n}\n\nReactDOM.render(&lt;App/&gt;, document.getElementById(\"root\"))</pre><p>shouldComponentUpdate 接收两个参数 nextProps 和 nextState，每次组件的 props 和 state 变化都会触发该生命周期，我们可在该生命周期中手动做比较，再返回 bool 值来决定是否触发当前组件的 render 函数，返回 true 会触发组件 render，返回 false 则不触发。\n<br>\n<br>运行过程如下：</p><p><img src=\"/app/json/frames/react/img/render4.png\" style=\"max-width:100%;\" class=\"\"></p><h3>2 函数式组件引入React.memo进行render优化</h3><p><h4>2.1 基础数据类型：\n</h4>此时我们看到，经过 React.memo() 高阶组件包装的子组件 ChildTwo 不再触发 render 了。正是因为 React.memo() 自动进行了一次浅比较，当前后两次传入的 props 一样时，不会触发 render。</p><pre>import React from \"react\";\nimport \"./style.css\";\n\nconst ChildOne = props =&gt; {\n  console.log(\"触发子组件 ChildOne 的 render\");\n  return (\n    &lt;div className=\"box\"&gt;\n      &lt;p&gt; 子组件 ChildOne&lt;/p&gt;\n      &lt;div&gt; 父组件传入 props 数据{props.value}&lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n\nconst ChildTwo = React.memo(props =&gt; {\n  console.log(\"触发子组件 ChildTwo 的 render\");\n  return (\n    &lt;div className=\"box\"&gt;\n      &lt;p&gt; 子组件 ChildTwo&lt;/p&gt;\n      &lt;div&gt; 父组件传入 props 数据{props.value}&lt;/div&gt;\n    &lt;/div&gt;\n  );\n});\nexport default class App extends React.Component {\n  state = {\n    value: 1\n  };\n\n  handleClick = () =&gt; {\n    this.setState({\n      value: 1\n    });\n  };\n\n  render() {\n    console.log(\"触发 render\");\n    return (\n      &lt;React.Fragment&gt;\n        &lt;div className=\"box\"&gt;\n          &lt;div&gt;{this.state.value}&lt;/div&gt;\n          &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt;\n        &lt;/div&gt;\n        &lt;ChildOne value={this.state.value} /&gt;\n        &lt;ChildTwo value={this.state.value} /&gt;\n      &lt;/React.Fragment&gt;\n    );\n  }\n}</pre><p>运行过程如下：</p><p><img src=\"/app/json/frames/react/img/render5.png\" style=\"max-width:100%;\" class=\"\"></p><p><h4>2.2 复杂数据类型：\n</h4>但如果要对复杂类型的 props 进行 shouldComponentUpdate 中类似的手动比较时，React.memo() 的使用方法完全不同：\n<br>\n<br>此时，React.memo() 需传入第二个参数，自定义比较函数 areEqual，在 areEqual 函数中进行手动比较。\n<br>\n<br>需要注意的是，与 class 组件中的 shouldComponentUpdate() 生命周期返回值不同，如果比较函数函数返回 true，则不触发函数组件的 render；反之如果返回 false，则触发函数组件的 render。</p><pre>// 当前后两次传入子组件的 props 对象中的 number 值都为 1 时，比较函数 areEqual 返回 true，所以未触发子组件 render；当前后两次传入子组件的 props 对象中的 number 不相等时，比较函数 areEqual 返回 false，触发了子组件 render。\nconst ChildOne = React.memo(props =&gt; {\n    console.log('触发子组件 ChildTwo 的 render')\n    return (\n        &lt;div className=\"box\"&gt;\n            &lt;p&gt; 子组件 ChildOne&lt;/p&gt;\n            &lt;div&gt; 父组件传入 props 数据{props.value.number}&lt;/div&gt;\n        &lt;/div&gt;\n    )\n}, areEqual)\n\nfunction areEqual(prevProps, nextProps) {\n    console.log('prevProps', prevProps)\n    console.log('nextProps', nextProps)\n    return prevProps.value.number === nextProps.value.number\n}\n\nclass App extends React.Component {\n    state = {\n        value: {\n            number: 1,\n        }\n    };\n\n    handleClick = () =&gt; {\n        this.setState({\n            value: {\n                number: 1\n            }\n        });\n    };\n\n    render() {\n        console.log('触发 render')\n        return (\n            &lt;React.Fragment&gt;\n                &lt;div className=\"box\"&gt;\n                    &lt;div&gt;{this.state.value.number}&lt;/div&gt;\n                    &lt;button onClick={this.handleClick}&gt;+&lt;/button&gt;\n                &lt;/div&gt;\n                &lt;ChildOne value={this.state.value}/&gt;\n            &lt;/React.Fragment&gt;\n        );\n    }\n}\n\nReactDOM.render(&lt;App/&gt;, document.getElementById(\"root\"))</pre><p>运行过程如下：</p><p><img src=\"/app/json/frames/react/img/render6.png\" style=\"max-width:100%;\"></p><p><br></p>"}}