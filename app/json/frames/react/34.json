{"sta":1,"data":{"subTitle":"组件中 useEffect 的执行顺序","content":"<p>先不要看答案，想一想下面的代码 console.log 的顺序是什么？&nbsp;</p><p>&nbsp;示例</p><pre>export default function MyDemo10() {\n  console.log(\"init render\");\n  const [counter, setCounter] = useState(0);\n  useEffect(() =&gt; {\n    const timer = setTimeout(() =&gt; {\n      console.log(\"change\");\n      setCounter(counter + 2);\n    }, 1000);\n    console.log(\"effect:\", timer);\n  }, []);\n  console.log(\"before render\");\n  return (\n    &lt;div className=\"container\"&gt;\n      {console.log(\"render...\")}\n      &lt;div className=\"el\"&gt;{counter}&lt;/div&gt;\n    &lt;/div&gt;\n  );\n}</pre><p>结果示例\n<br>\n<img src=\"/app/json/frames/react/img/r4.gif\" style=\"max-width:100%;\">首先按照顺序执行 init render---before render---render...\n<br>渲染完 DOM 之后，执行 useEffect 中 effect,500ms 之后，change，然后改变 counter\n<br>因为改变了 counter，所以重新渲染函数，init render---before render---render...\n<br>\n<br>示例  useEffect 中加入 return 之后呢？</p><pre>export default function MyDemo11() {\n  console.log(\"init render\");\n  const [counter, setCounter] = useState(0);\n  useEffect(() =&gt; {\n    const timer = setTimeout(() =&gt; {\n      console.log(\"change\");\n      setCounter(counter + 2);\n    }, 10000);\n    console.log(\"effect:\", timer);\n    return () =&gt; {\n      console.log(\"clear:\", timer);\n      clearTimeout(timer);\n    };\n  }, [counter]);\n  console.log(\"before render\");\n  return (\n    &lt;div className=\"container\"&gt;\n      {console.log(\"render...\")}\n      &lt;div className=\"el\"&gt;{counter}&lt;/div&gt;\n    &lt;/div&gt;\n  );\n}</pre><p>结果示例\n<br>\n<img src=\"/app/json/frames/react/img/r5.gif\" style=\"max-width:100%;\">首先按照顺序执行 init render---before render---render...\n<br>渲染完 DOM 之后，执行 useEffect 中 effect,500ms 之后，change，然后改变 counter\n<br>因为改变了 counter，所以重新渲染函数，init render---before render---render...\n<br>渲染完 DOM 之后，执行 useEffect 中 return,clear---执行完 return 后在次执行effect,500ms 之后，change，然后改变 counter\n<br>循环往复\n<br>示例&nbsp; 父子组件中的 useEffect, useLayoutEffect 执行顺序</p><p>父组件：</p><pre>const MyDemo12 = () =&gt; {\n  const [myName, SetMyName] = useState(\"初始值\");\n  return (\n    &lt;div&gt;\n      &lt;Child name={myName} /&gt;\n      &lt;button onClick={() =&gt; SetMyName(\"新名字\")}&gt;点击&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};</pre><p>子组件：</p><pre>const Child = (props) =&gt; {\n  useEffect(() =&gt; {\n    console.log(\"组件useEffect\");\n  });\n  useLayoutEffect(() =&gt; {\n    console.log(\"组件useLayoutEffect\");\n  });\n  console.log(\"组件\");\n  return (\n    &lt;div&gt;\n      {console.log(\"组件render\")}我是子组件{props.name}\n      &lt;Cards /&gt;\n    &lt;/div&gt;\n  );\n};</pre><p>子孙组件</p><pre>const Cards = () =&gt; {\n  useEffect(() =&gt; {\n    console.log(\"子孙组件useEffect\");\n  });\n  useLayoutEffect(() =&gt; {\n    console.log(\"子孙组件useLayoutEffect\");\n  });\n  return &lt;&gt;{console.log(\"子孙组件render\")}我是子孙组件&lt;/&gt;;\n};</pre><p>结果示例</p><p><img src=\"/app/json/frames/react/img/r6.gif\" style=\"max-width:100%;\"></p><p>点击按钮，改变子组件的 props，可以看到 useLayoutEffect 总是比 useEffect 先执行，如下图所示，先执行完父子组件的 useLayoutEffect，才会执行父子组件的 useEffect：</p><p><img src=\"/app/json/frames/react/img/r7.png\" style=\"max-width:100%;\"></p><p><br></p><p><br></p><p><br></p><p><br></p>"}}