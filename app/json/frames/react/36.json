{"sta":1,"data":{"subTitle":"如何获取上一时刻的 props 和 state","content":"<p>核心知识点 使用 useRef 可以很好的保存变量，核心是在 render 之后执行 useEffect 保存当前的 state 和 props，然后下一次渲染子组件的时候，先执行自定义的 hook 函数，从而得到上一时刻的 state 和 props，待 render 之后再去执行 自定义的 hook 中的 useEffect 函数，从而更新保存的 useRef 中的变量，最终写成自定义 useHook 的形式：<br></p><p>\n<br>示例 1 自定义的 Hook 函数，获取上一时刻的 props 和 state\n<br>\n<br>父组件：&nbsp;<br></p><pre>const MyDemo19 = () =&gt; {\n  const [counter, SetCounter] = useState(0);\n  const changeCounter = () =&gt; {\n    SetCounter((preState) =&gt; {\n      return preState + 1;\n    });\n  };\n  return (\n    &lt;&gt;\n      &lt;ChildCom counter={counter} /&gt;\n      &lt;button onClick={changeCounter}&gt;点击改变子组件props&lt;/button&gt;\n    &lt;/&gt;\n  );\n};</pre><p>子组件：</p><pre>const ChildCom = (props) =&gt; {\n  const [num, setNum] = useState(0);\n  const mycounter = usePreProps(props.counter);\n  console.log(\"上一时刻的props\", mycounter);\n  const preData = usePreData(num);\n  console.log(\"上一时刻的data\", preData);\n  const changeNum = () =&gt; {\n    setNum(num + 1);\n  };\n  return (\n    &lt;&gt;\n      &lt;div&gt;子组件props:{props.counter}&lt;/div&gt;\n      &lt;div&gt;子组件data:{num}&lt;/div&gt;\n      &lt;button onClick={changeNum}&gt;点击改变state&lt;/button&gt;\n    &lt;/&gt;\n  );\n};</pre><p>封装的 Hook</p><pre>//获取上一时刻的props\nconst usePreProps = (props) =&gt; {\n  const prevCountRef = useRef();\n  useEffect(() =&gt; {\n    prevCountRef.current = props;\n  });\n  return prevCountRef.current;\n};\n\n//获取上一时刻的state\nconst usePreData = (value) =&gt; {\n  const ref = useRef();\n  useEffect(() =&gt; {\n    ref.current = value;\n  });\n  return ref.current;\n};</pre><p><img src=\"/app/json/frames/react/img/r15.gif\" style=\"max-width:100%;\"></p><p>点击两个按钮，可以得到上一时刻的 props 值和 state 值，核心就是使用了 useRef，并使用自定义 Hook 进行了封装；\n<br>\n<br>示例 2 useEffect 中 return 返回的 props 是哪一次的？\n<br>\n<br>父组件：</p><pre>export default function MyBox() {\n  const [myId, setMyId] = useState(0);\n  return (\n    &lt;&gt;\n      &lt;ChildDemo id={myId} /&gt;\n      &lt;button\n        onClick={() =&gt; {\n          setMyId(myId + 1);\n        }}\n      &gt;\n        点击me\n      &lt;/button&gt;\n    &lt;/&gt;\n  );\n}</pre><p>子组件：</p><pre>interface IChildDemoProps {\n  id: number;\n}\nfunction ChildDemo(props: IChildDemoProps) {\n  useEffect(() =&gt; {\n    console.log(props.id);\n    return () =&gt; {\n      console.log(\"clear\", props.id);\n    };\n  });\n  return (\n    &lt;div className=\"container\"&gt;\n      &lt;div className=\"el\"&gt;{props.id}&lt;/div&gt;\n    &lt;/div&gt;\n  );\n}</pre><p><img src=\"/app/json/frames/react/img/r16.gif\" style=\"max-width:100%;\"></p><p>在 props 发生变化之后，每次执行 useEffect 前都会先执行 return 中的函数，所以 return 中的 props 都是上一次的 props</p><p><br></p>"}}