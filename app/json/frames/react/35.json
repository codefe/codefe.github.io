{"sta":1,"data":{"subTitle":"useCallback、useMemo 和 React.memo 的区别联系","content":"<blockquote>useMemo 和 useCallback 接收的参数都是一样,第一个参数为回调，第二个参数为要依赖的数据</blockquote><p>共同作用 仅当依赖数据发生变化, 才会重新计算结果，也就是起到缓存的作用。\n<br>\n<br>两者区别\n<br>\n<br>1、useMemo 计算结果是 return 回来的值, 主要用于缓存计算结果的值，应用场景如：需要计算的状态，类似于 vue 中的 computed\n<br>2、useCallback 计算结果是 函数, 主要用于缓存函数，应用场景如: 需要缓存的函数，因为函数式组件每次任何一个 state 的变化，整个组件都会被重新刷新，一些函数是没有必要被重新刷新的，此时就应该缓存起来，提高性能和减少资源浪费。\n<br>形如：</p><pre>const onShow = useMemo(() =&gt; {\n  return () =&gt; {\n    setShow((isShow) =&gt; !isShow);\n  };\n}, []);\nconst onShow = useCallback(() =&gt; {\n  setShow((isShow) =&gt; !isShow);\n}, []);</pre><p>示例 父组件中 input 输入内容的时候会重新执行 Parent 函数式组件，就会重新渲染 Button 子组件</p><pre>//子组件\nconst Button = () =&gt; {\n  console.log(\"我被重新渲染了\");\n  return (\n    &lt;div&gt;\n      &lt;button&gt;点击按钮&lt;/button&gt;\n    &lt;/div&gt;\n  );\n};\n//父组件\nconst MyDemo13 = () =&gt; {\n  const [inputValue, setInputValue] = useState(\"\");\n  return (\n    &lt;div&gt;\n      &lt;input\n        value={inputValue}\n        onChange={(e) =&gt; setInputValue(e.target.value)}\n      /&gt;\n      &lt;Button /&gt;\n    &lt;/div&gt;\n  );\n};\nexport default MyDemo13;</pre><p><img src=\"/app/json/frames/react/img/r8.gif\" style=\"max-width:100%;\"></p><p>如上图所示，在父组件的 input 输入框中输入文字，按钮子组件居然也重新渲染了。\n<br>\n<br>示例 改进方式：使用 React.memo 函数包裹子组件</p><p>React.memo 仅检查 props 变更。如果你的组件在相同 props 的情况下渲染相同的结果，那么你可以通过将其包装在 React.memo 中调用，以此通过记忆组件渲染结果的方式来提高组件的性能表现。这意味着在这种情况下，React 将跳过渲染组件的操作并直接复用最近一次渲染的结果。</p><p>注意的是 默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。</p><pre>function ChildComponent(props) {\n  /* 使用 props 渲染 */\n}\nfunction areEqual(prevProps, nextProps) {\n  /*\n  返回 true 则不在渲染子组件，\n  否则返回 false 渲染子组件\n  */\n}\nexport default React.memo(ChildComponent, areEqual);</pre><p>示例改为：</p><pre>//子组件\nconst Button = React.memo(function Button() {\n  console.log(\"我被重新渲染了\");\n  return (\n    &lt;div&gt;\n      &lt;button&gt;点击按钮&lt;/button&gt;\n    &lt;/div&gt;\n  );\n});\n//父组件\nconst MyDemo14 = () =&gt; {\n  const [inputValue, setInputValue] = useState(\"\");\n  return (\n    &lt;div&gt;\n      &lt;input\n        value={inputValue}\n        onChange={(e) =&gt; setInputValue(e.target.value)}\n      /&gt;\n      &lt;Button /&gt;\n    &lt;/div&gt;\n  );\n};</pre><p><img src=\"/app/json/frames/react/img/r9.gif\" style=\"max-width:100%;\"></p><p>由于 Button 组件被 React.memo 包裹，比较了 Button 的 props 没有发生变化，所以改变父组件的时候，不会重新渲染子组件。\n<br>\n<br>我们再改进一下，如果要求点击子组件 Button 的按钮，触发父组件中 onShow 方法，从而改变 state：isShow，隐藏子组件：\n<br>\n<br>示例</p><pre>const Button = React.memo(function Button(props) {\n  console.log(\"子组件被重新渲染了\");\n  return (\n    &lt;div&gt;\n      &lt;button onClick={props.onShow}&gt;点击隐藏&lt;/button&gt;\n    &lt;/div&gt;\n  );\n});\n\nconst MyDemo15 = () =&gt; {\n  const [inputValue, setInputValue] = useState(\"\");\n  const [isShow, setIsShow] = useState(true);\n  const onShow = () =&gt; {\n    setIsShow((isShow) =&gt; !isShow);\n  };\n  return (\n    &lt;div&gt;\n      &lt;input\n        value={inputValue}\n        onChange={(e) =&gt; setInputValue(e.target.value)}\n      /&gt;\n      {isShow &amp;&amp; &lt;Button onShow={onShow} /&gt;}\n    &lt;/div&gt;\n  );\n};</pre><p><img src=\"/app/json/frames/react/img/r10.gif\" style=\"max-width:100%;\"></p><p>&nbsp;我们发现父组件中 input 输入内容会导致父组件函数重新渲染，因为这关系到了 React 是如何浅层比较的，在子组件中 onShow 是引用类型，所以他们是始终都不相等的，也就是[]===[]这样比较时始终返回 false，在基本数据类型比较时 React.memo 才会起作用。从而导致子组件 Button 也会重新渲染。那么我们该如何优化呢？</p><p>\n<br>方法一：使用 React.memo 的第二个比较函数包裹子组件\n<br>\n<br>先确认执行顺序，像剥洋葱一样，我们看下面的示例： 示例&nbsp;<br>\n<br>父组件</p><pre>const MyDemo16 = () =&gt; {\n  const [inputValue, setInputValue] = useState(\"\");\n  const [arrList, setarrList] = useState([]);\n  console.log(\"渲染父组件\");\n  useEffect(() =&gt; {\n    console.log(\"父组件执行一次useEffect\");\n  }, []);\n  useEffect(() =&gt; {\n    if (inputValue.length &gt; 0) {\n      console.log(\"触发父组件useEffect\");\n      const newList = [...arrList];\n      newList.push(inputValue);\n      setarrList(newList);\n    }\n  }, [inputValue]);\n  return (\n    &lt;div&gt;\n      &lt;input\n        value={inputValue}\n        onChange={(e) =&gt; setInputValue(e.target.value)}\n      /&gt;\n      &lt;Button arrList={arrList} /&gt;\n    &lt;/div&gt;\n  );\n};</pre><p>子组件代码：</p><pre>const Button = React.memo(function Button(props) {\n  const prevCountRef = useRef();\n  console.log(\"渲染子组件\");\n  useEffect(() =&gt; {\n    console.log(\"子组件执行一次useEffect\");\n  }, []);\n  useEffect(() =&gt; {\n    if (props.arrList.length &gt; 3) {\n      console.log(\"子组件useEffect\");\n    }\n  }, [props.arrList]);\n  return (\n    &lt;div&gt;\n      &lt;ul&gt;\n        {props.arrList.map((item, index) =&gt; {\n          return &lt;li key={index}&gt;{item}&lt;/li&gt;;\n        })}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  );\n}, areEqual);</pre><p>对应的 areEqual 函数：</p><pre>function areEqual(prevProps, nextProps) {\n  console.log(prevProps.arrList);\n  console.log(nextProps.arrList);\n  if (JSON.stringify(prevProps.arrList) === JSON.stringify(nextProps.arrList)) {\n    console.log(\"true\");\n    return true;\n  } else {\n    console.log(\"false\");\n    return false;\n  }\n}</pre><p><img src=\"/app/json/frames/react/img/r11.gif\" style=\"max-width:100%;\"></p><p>渲染父组件--&gt;渲染子组件--&gt;子组件执行 useEffect--&gt;父组件执行 useEffect\n<br>父组件中输入内容后，inputValue 发生变化，所以会触发：\n<br>父组件重新渲染--&gt;执行 areEqual 函数[返回 true]（因为此时还没有触发父组件的 useEffect，所以没有改变 props）所以不渲染子组件--&gt;父组件执行 useEffect，改变 arrList\n<br>重新渲染父组件--&gt;执行 areEqual 函数[返回 false]（因为此时已经触发父组件的 useEffect，所以改变 props 的 arrList）--&gt;渲染子组件</p><p><img src=\"/app/json/frames/react/img/r12.png\" style=\"max-width:100%;\"></p><p>确定好执行顺序之后，我们再来看优化的示例：\n<br>\n<br>示例&nbsp; 如果传入的 props 是函数时，即使父组件中传入的 props.onVisible 一样，但是子组件得到的也是不一样的\n<br>\n<br>父组件：</p><pre>const MyDemo17 = () =&gt; {\n  const [inputValue, setInputValue] = useState(\"\");\n  const onShow = () =&gt; {\n    console.log(\"isShow\");\n    return \"hello\";\n  };\n  return (\n    &lt;div&gt;\n      &lt;input\n        value={inputValue}\n        onChange={(e) =&gt; setInputValue(e.target.value)}\n      /&gt;\n      &lt;Button onShow={onShow} /&gt;\n    &lt;/div&gt;\n  );\n};\nexport default MyDemo17;</pre><p>子组件代码：</p><pre>function areEqual(prevProps, nextProps) {\n  if (prevProps == nextProps) {\n    console.log(\"true\");\n    return true;\n  } else {\n    console.log(\"false\");\n    return false;\n  }\n}\nconst Button = React.memo(function Button(props) {\n  console.log(\"渲染子组件\");\n  return (\n    &lt;div&gt;\n      &lt;button onClick={props.onShow}&gt;点击按钮&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}, areEqual);</pre><p><img src=\"/app/json/frames/react/img/r13.gif\" style=\"max-width:100%;\"></p><p>从上面可以看出，父组件输入内容后，父组件 state 发生变化，重新渲染父组件，则传递给子组件的函数也是重新渲染的，areEqual 函数打印的是 false。\n<br>\n<br>当然我们可以修改 areEqual 函数，对比两次 props 传入的值是否一样，但是 props 数据较多的时候就有些不方便了。</p><pre>function areEqual(prevProps, nextProps) {\n  if (JSON.stringify(prevProps) == JSON.stringify(nextProps)) {\n    console.log(\"true\");\n    return true;\n  } else {\n    console.log(\"false\");\n    return false;\n  }\n}</pre><p>这是 useCallback 或者 useMemo 就登场了：\n<br>\n<br>示例 父组件使用 useCallback 或者 useMemo 控制父组件中函数的缓存\n<br>\n<br>父组件：</p><pre>const onShow = useCallback(() =&gt; {\n  console.log(\"isShow\");\n  return \"hello\";\n}, []);</pre><p>或者</p><pre>const onShow = useMemo(() =&gt; {\n  return () =&gt; {\n    console.log(\"isShow\");\n    return \"hello\";\n  };\n}, []);</pre><p>示例 使用 useCallback 进行缓存函数示例</p><pre>const Button = React.memo(function Button(props) {\n  console.log(\"子组件被重新渲染了\");\n  return (\n    &lt;div&gt;\n      &lt;button onClick={props.onShow}&gt;点击隐藏&lt;/button&gt;\n    &lt;/div&gt;\n  );\n});\n\nconst MyDemo18 = () =&gt; {\n  const [inputValue, setInputValue] = useState(\"\");\n  const [isShow, setIsShow] = useState(true);\n  const onShow = useCallback(() =&gt; {\n    setIsShow((isShow) =&gt; !isShow);\n  }, [isShow]);\n  return (\n    &lt;div&gt;\n      &lt;input\n        value={inputValue}\n        onChange={(e) =&gt; setInputValue(e.target.value)}\n      /&gt;\n      {isShow &amp;&amp; &lt;Button onShow={onShow} /&gt;}\n    &lt;/div&gt;\n  );\n};</pre><p><img src=\"/app/json/frames/react/img/r14.gif\" style=\"max-width:100%;\"></p><p>从上图可以看出，父组件中 onShow 函数经过 useCallback 包裹后，子组件不再触发。\n<br>\n<br>示例&nbsp; 类似的使用 useMemo 进行缓存</p><pre>const onShow = useMemo(() =&gt; {\n  return () =&gt; {\n    setIsShow((isShow) =&gt; !isShow);\n  };\n}, [isShow]);</pre><p>注意 useMemo 用来返回缓存的变量；useCallBack 用来返回缓存的函数。</p><p><br></p>"}}