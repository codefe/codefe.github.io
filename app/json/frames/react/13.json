{"sta":1,"data":{"subTitle":"setState更新状态的2种写法","content":"<blockquote>setState为异步执行</blockquote><p>一. setState(stateChange,[callback]) ----- 对象式的setState\n<br>   &nbsp;&nbsp;&nbsp;&nbsp;1. stateChange为状态改变的对象(该对象可以体现出状态的更改)\n<br>   &nbsp;&nbsp;&nbsp;&nbsp;2. callback是可选的回调函数，它在状态更新完毕、界面也更新后(render调用后)才被调用</p><blockquote>const { count } = this.state<br>this.setState({count:count+1},()=&gt;{<br>\n&nbsp; &nbsp; &nbsp;console.log(this.state.count)<br>})</blockquote><p>\n<br>二. setState(updater, [callback]) ----函数式的setState\n<br>   &nbsp;&nbsp;&nbsp;&nbsp;1. updater为返回stateChange对象的函数\n<br>   &nbsp;&nbsp;&nbsp;&nbsp;2. updater可以接收到state和props\n<br>   &nbsp;&nbsp;&nbsp;&nbsp;3. callback是可选的回调函数，它在状态更新、界面也更新后(render调用后)才被调用\n<br>\n</p><blockquote>this.setState((state,props)=&gt;{<br>&nbsp; &nbsp; return {count: state.count + 1}<br>},()=&gt;{<br>\n     &nbsp;&nbsp;&nbsp;&nbsp;console.log(this.state.count)<br>\n})</blockquote><p>简写</p><blockquote>this.setState(state=&gt;({count:state.count+1}))</blockquote><p>总结：\n<br>   &nbsp;&nbsp;&nbsp;&nbsp;1. 对象式的setState是函数式的setState的简写方式(语法糖)\n<br>   &nbsp;&nbsp;&nbsp;&nbsp;2. 使用原则：\n<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a. 如果新状态不依赖于原状态=====&gt; 使用对象方式\n<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b. 如果新状态依赖原状态 ========&gt; 使用函数方式\n<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c. 如果需要在setState()执行后获取最新的状态数据，要在第二个callback函数中读取</p>"}}