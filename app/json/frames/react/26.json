{"sta":1,"data":{"subTitle":"大量数据长列表使用虚拟滚动","content":"<p>长列表使用虚拟滚动，相信大家在平时开发时经常会遇到长列表，如会话列表、订单列表等等，列表项成百上千甚至更多，页面在渲染这些列表项时非常耗时，有时候页面可能都无法与用户交互，出现假死的情况，用户体验很不好。</p><p></p><p>来看一个例子，一个含 1 万个列表项的列表组件。其中我们在 render 和 componentDidMount 中都记录一个时间，通过计算两者时差值 renderTime，来得到从开始 render 到 dom 完成挂载的时间，代码如下：</p><pre>import React from \"react\";\nimport \"./index.css\";\n\n// 列表项\nconst Row = ({ index, style }) =&gt; (\n    &lt;div className={index % 2 ? \"ListItemOdd\" : \"ListItemEven\"}&gt;\n        Row {index}\n    &lt;/div&gt;\n);\n\n// 定义一个长度为 10000 的数组用于生成列表项\nconst arr = new Array(10000).fill('*');\nlet startRender = 0;\nlet finishRender = 0;\n// 列表\nclass App extends React.Component {\n    componentDidMount() {\n        finishRender = new Date().getTime();\n        console.log('renderTime', (finishRender - startRender)/1000, 's');\n    }\n\n    render() {\n        startRender = new Date().getTime();\n        return (\n            &lt;div className=\"List\"&gt;\n                {arr.map((el, index) =&gt; &lt;Row key={index} index={index} /&gt;) }\n            &lt;/div&gt;\n        )\n    }\n}\n\nexport default App;</pre><p>我们可以测试一下，对于 1 万个列表项 render 完成并全部挂载 dom 后，componentDidMount 中打印的 renderTime 大约为 0.223s。</p><p>现在我们将列表项增加到 10 倍，即 10 万个再试一次。我们可以看到 10 万个列表项计算的 renderTime 大约为 1.596s，已经有了比较明显的渲染延时，流畅度也降低了不少。</p><p>仔细观察这两个表，我们可以发现，用户实际只能看到可视区域内的 8-9 个列表项，而不在可视区域内的列表项为大多数，而在没有滚动到这些列表项之前，渲染它们其实是没有实际意义的。那有没有方法可以控制列表仅渲染可视区域内的列表项呢？\n<br>\n<br>这个时候我们可以引入支持虚拟滚动的列表组件，来实现这个功能，而之所以称之为虚拟滚动，是因为我们在滚动时并没有真的在滚动完整的列表，而是不断更新可视区域内的列表项，来造成一种滚动的假象。\n<br>\n<br>我们以 npm 包 react-window 来举例，仍然是 1 万个列表项，我们用 react-window 提供的 FixedSizeList 组件作为列表项的父组件，并且为父组件提供列表的宽高、列表项高度以及列表项数量等数据：</p><pre>import React from \"react\"\nimport { FixedSizeList as List } from \"react-window\"\n\nimport \"./index.css\"\n\n// 列表项\nconst Row = ({ index, style }) =&gt; (\n    &lt;div className={index % 2 ? \"ListItemOdd\" : \"ListItemEven\"} style={style}&gt;\n        Row {index}\n    &lt;/div&gt;\n);\n\n// 定义一个长度为 10000 的数组用于生成列表项\nconst arr = new Array(10000).fill('*')\nlet startRender = 0\nlet finishRender = 0\n\n// 列表\nclass App extends React.Component {\n    componentDidMount() {\n        finishRender = new Date().getTime()\n        console.log('renderTime', (finishRender - startRender)/1000, 's')\n    }\n    render() {\n        startRender = new Date().getTime()\n        return (\n            &lt;List\n                className=\"List\"\n                height={350}\n                itemCount={arr.length}\n                itemSize={35}\n                width={300}\n            &gt;\n                {Row}\n            &lt;/List&gt;\n        );\n    }\n}\n\nexport default App;</pre><p>我们可以看到同样是 1 万个列表项的 renderTime 仅有 0.003s，比之前的 0.223s，相差 74 倍之多。</p><p>接下来，我们继续增加列表项到 10 万，可以看到 10 万个列表项的 renderTime 也是大约为 0.009s，跟之前的1万列表的时长基本没有变化，只是增加了几毫秒，但是跟没有用react-window之前的10 万列表项的 1.596s 来说，快了 177 倍。</p><p>很显然，在多列表项的场景里，使用虚拟滚动对性能提升有非常大的帮助，而且列表项越多，使用虚拟滚动的优势也越大。除了示例中提到的 react-window npm 包外，还有其他支持虚拟滚动的工具，大家可以根据项目实际情况进行选择。</p><p><br></p>"}}