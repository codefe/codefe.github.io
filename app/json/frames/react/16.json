{"sta":1,"data":{"subTitle":"effectHook","content":"<p>1. Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件的生命周期钩子)<br></p><p>2. React中的副作用操作：\n<br>    &nbsp;&nbsp;&nbsp;&nbsp;发ajax请求数据获取\n<br>    &nbsp;&nbsp;&nbsp;&nbsp;设置订阅/启动定时器\n<br>    &nbsp;&nbsp;&nbsp;&nbsp;手动更改真实DOM\n<br>3. 语法和说明：\n<br><blockquote>    React.useEffect(()=&gt;{<br>\n        &nbsp;&nbsp;&nbsp;&nbsp;let timer = setInterval(()=&gt;{<br>\n            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setCount(count=&gt;count+1)<br>\n        &nbsp;&nbsp;&nbsp;&nbsp;},1000)<br>\n        &nbsp;&nbsp;&nbsp;&nbsp;return ()=&gt;{//相当于卸载组件之前,在此做一些收尾工作，比如清除定时器、取消订阅等<br>            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearInterval(timer)<br>\n        &nbsp;&nbsp;&nbsp;&nbsp;}<br>\n    },[stateValue]) //如果指定的是[],回调函数只会在第一次render()后执行\n</blockquote>4. 可以把 useEffect Hook 看做如下三个函数的组合\n<br><blockquote>    componentDidMount()<br>\n    componentDidUpdate()<br>\n    componentWillUnmount()\n</blockquote>    \n<br><h3>例子\n</h3>\n</p><pre>// 函数式组件\nfunction Demo(){\n    //底层作了处理,count会被缓存，不会被重新调用而被覆盖\n    const [count,setCount] = React.useState(0)\n    //如果第二个参数不写，会监测全部，空为不监测，如果要监测其中的可以写进去\n    React.useEffect(()=&gt;{\n        let timer = setInterval(()=&gt;{\n            setCount(count=&gt;count+1)\n        },1000)\n        return ()=&gt;{//相当于卸载组件之前\n            clearInterval(timer)\n        }\n    },[])\n\n    //卸载组件\n    function unmount(){\n        ReactDOM.unmountComponentAtNode(document.getElementById('root'))\n    }\n\n    return (\n        &lt;div&gt;\n            &lt;h2&gt;当前求和为：{count}&lt;/h2&gt;\n            &lt;button onClick={unmount}&gt;卸载组件&lt;/button&gt;\n        &lt;/div&gt;\n    )\n}\n\nexport default Demo</pre><p><br></p><p><br></p>"}}