{"sta":1,"data":{"subTitle":"Vue性能优化方法","content":"<p>1.路由懒加载&nbsp;</p><pre><code>const router = new VueRouter({\n  routes: [\n    {path: '/foo',component: ()=&gt;import('./Foo.vue')}\n  ]\n})</code></pre><p>2. keep-alive缓存页面</p><pre><code>&lt;template&gt;\n  &lt;div id=\"app\"&gt;\n    &lt;keep-alive&gt;\n      &lt;router-view /&gt;\n    &lt;/keep-alive&gt;\n  &lt;/div&gt;\n&lt;/template&gt;</code></pre><p>3. 使用v-show 复用DOM</p><p>4. v-for 遍历避免同时使用v-if</p><pre><code>&lt;template v-if=\"show\"&gt;\n   &lt;p v-for=\"v in list\" :key=\"v.id\"&gt;外层包一个template&lt;p&gt;\n&lt;/template&gt;</code></pre><p>5. 长列表性能优化</p><p>如果列表是纯粹的数据展示，不会有任何变化，就不需要做响应化</p><pre><code>export default {\n  data: ()  =&gt; ({\n    users: []\n  }),\n  async created() {\n    this.users = Object.freeze(获取来的数据)\n  }\n}</code></pre><p>如果是大数据长列表，可采用虚拟滚动，只渲染少部分区域的内容</p><pre><code>&lt;recycle-scroller :items=\"items\" :item-size=\"24\"&gt;\n  &lt;template v-slot=\"{item}\"&gt;\n    &lt;FetchItemView :item=\"item\" @vote=\"voteItem(item)\" /&gt;\n  &lt;/template&gt;\n&lt;/recycle-scroller&gt;</code></pre><p>6. 事件的销毁</p><p>Vue组件销毁时，会自动解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。</p><pre><code>created() {\n  this.timer = setInterval(this.refresh, 2000)\n},\nbeforeDestroy () {\n  clearInterval(this.timer）\n}</code></pre><p>7. 图片懒加载</p><p>对于图片过多的页面，为了加载页面速度加速。所以很多时候我们需要将页面内未出现在可是区域内的图片先不做加载，等到滚动到可视区域后再去加载</p><pre><code>&lt;img v-lazy=\"/static/img/1.png\"&gt;</code></pre><p>参考项目： vue-lozyload https://github.com/hilongjw/vue-lazyload</p><p>8. 第三方插件按需引入</p><p>像element-ui这样的第三方组件库可以按需引入，避免体积较大。</p><pre><code>import Vue from 'vue'\nimport {Button, Select} from 'element-ui'\nVue.use(Button)\nVue.use(Select)</code></pre><p>9. 无状态的组件标记为函数式组件</p><pre><code>&lt;template functional&gt;\n&lt;/template&gt;</code></pre><p>10. 子组件分割</p><p>11. 变量本地化</p><pre><code>const base = this.base //不要频繁引用this.base</code></pre><p>12. 服务端渲染 - SSR</p>"}}