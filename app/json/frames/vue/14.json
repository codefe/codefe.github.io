{"sta":1,"data":{"subTitle":"Proxy,defineProperty","content":"<p></p><div><div>3.0 基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。替代了Vue 2采用 defineProperty去定义get 和 set, 意味着彻底放弃了兼容IE, 这也取消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：<br>\n=&gt;只能监测属性，不能监测对象:<br>\n=&gt;检测属性的添加和删除；<br>\n=&gt;检测数组索引和长度的变更；<br>\n=&gt;支持 Map、Set、WeakMap 和 WeakSet。<br>\n<strong>新的 observer 还提供了以下特性：</strong><br>\n<code>用于创建 observable 的公开 API</code>。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。<br>\n<code>默认采用惰性观察</code>。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。<br>\n<code>更精确的变更通知</code>。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。<br>\n<code>不可变的 observable</code>：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。<br>\n<code>更好的调试功能</code>：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。</div><br></div>"}}