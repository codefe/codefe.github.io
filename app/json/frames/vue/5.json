{"sta":1,"data":{"subTitle":"setup语法糖","content":"<h3>1. setup执行的时机</h3><p>在beforeCreate之前执行(一次), 此时组件对象还没有创建\n<br>this是undefined, 不能通过this来访问data/computed/methods / props\n<br>其实所有的composition API相关回调函数中也都不可以\n<br><br><h3>2. setup的返回值</h3>一般都返回一个对象: 为模板提供数据, 也就是模板中可以直接使用此对象中的所有属性/方法\n<br>返回对象中的属性会与data函数返回对象的属性合并成为组件对象的属性\n<br>返回对象中的方法会与methods中的方法合并成功组件对象的方法\n<br>如果有重名, setup优先\n<br>注意:\n<br>一般不要混合使用: methods中可以访问setup提供的属性和方法, 但在setup方法中不能访问data和methods\n<br>setup不能是一个async函数: 因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性数据\n<br>\n<br><h3>3. setup的参数</h3>setup(props, context) / setup(props, {attrs, slots, emit})\n<br>props: 包含props配置声明且传入了的所有属性的对象\n<br>attrs: 包含没有在props配置中声明的属性的对象, 相当于 this.$attrs\n<br>slots: 包含所有传入的插槽内容的对象, 相当于 this.$slots\n<br>emit: 用来分发自定义事件的函数, 相当于 this.$emit</p><h3>4. setup 语法糖</h3><p>4.1&nbsp; 不用写export default{}</p><p>4.2 导入组件后，不用再注册，可以直接使用</p><p>4.3 不用写 return 就可以在模板使用</p><p>4.4 props 传参改为 defineProps</p><pre>//之前\nexport default {\n    setup(props)\n}\n// 现在\n// defineProps 不需要导入可直接使用\nconst props = defineProps(['msg'])\n//or\nconst props = defineProps({\n    msg: String\n})\n//ts写法\nconst props = defineProps&lt;{ msg: string }&gt;({\n    msg: String\n})\n//上面ts写法可简写为\nconst props = defineProps&lt;{ msg: string }&gt;()\n//通过类型定义\ntype Ps = {\n    title: string,\n    age: number,\n    size?: number\n}\nconst props = defineProps&lt;Ps&gt;()\n// 设置默认值\nimport { withDefaults }  from 'vue'\nconst props = withDefaults( defineProps&lt;Ps&gt;(),{\n    title: 'a',\n    age: 18,\n    size: 20\n})</pre><p>4.5 事件发送 defineEmits</p><pre>// 之前\nexport default {\n    emits:['foo-click']\n}\n// 现在\n//defineEmits 不需要导入可直接使用\nconst emit = defineEmits(['foo-click'])\nemit('foo-click')\n//or\nconst emit = defineEmits&lt;{\n    (e:'change', id: number):void,\n    (e:'update', value: string):void\n}&gt;()</pre><p>4.6 useContext</p><pre>//之前\nexport default {\n    setup(props,context){}\n}\n//现在 useContext要放在 defineProps,defineEmits之前\nimport { useContext } from 'vue'\nconst ctx = useContext()\n//ctx中包含：\n// attrs,emit,expose,props,slots\n//上面5.事件发送也可这样写：\nimport { useContext, defineEmits } from 'vue'\nconst ctx = useContext()\ndefineEmit('foo-click')\nconst handleClick = () =&gt; {\n    ctx.emit('foo-click')\n}</pre><p>4.7 defineExpose</p><p>由于setup是封闭的，当父组件通过模板 ref 的方式获取到当前组件的实例时是null, 可以使用 defineExpose导出要暴露出去的属性和方法给实例。</p><p>4.8 await</p><p>可以在setup中直接写 await 不用 async</p><p>4.9 inherit-attrs</p><pre>// 子组件 Foo.vue\n// inherit-attrs 可以控制是否可以继承父组件传过来的属性\n&lt;template inherit-attrs=\"false\"&gt;\n    &lt;div&gt;\n    \tFoo:{{msg}}\n    &lt;/div&gt;\n&lt;/template&gt;\n//App.vue\n&lt;template&gt;\n   &lt;div&gt;\n        &lt;Foo ref=\"foo\" :msg=\"1\" class=\"foo bar baz\"&gt;&lt;/Foo&gt;\n   &lt;/div&gt;     \n&lt;/template&gt;</pre><p>4.10 自定义指令</p><pre>//vFocus.js\nexport default {\n    mounted(el){\n        el.focus()\n    }\n}\n//导入使用 vFocus 必须加v\nimport vFocus from '@/utils/vFocus.js'\n&lt;input type=\"text\" v-focus /&gt;</pre><p><br></p><p><br></p>"}}