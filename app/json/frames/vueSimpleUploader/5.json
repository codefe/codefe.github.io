{"sta":1,"data":{"subTitle":"MD5的计算过程","content":"<p>断点续传及秒传的基础是要计算文件的<code>MD5</code>，这是文件的唯一标识，然后服务器根据<code>MD5</code>进行判断，是进行秒传还是断点续传。</p><p></p><p>在<code>file-added</code>事件之后，就计算<code>MD5</code>，我们最终的目的是<strong>将计算出来的<code>MD5</code>加到参数里传给后台</strong>，然后<strong>继续文件上传</strong>的操作，详细的思路步骤是：</p><ol><li>把uploader组件的autoStart设为false，即选择文件后不会自动开始上传\n</li><li>先通过 file.pause()暂停文件，然后通过H5的FileReader接口读取文件\n</li><li>将异步读取文件的结果进行MD5，这里我用的加密工具是spark-md5，你可以通过npm install spark-md5 --save来安装，也可以使用其他MD5加密工具。\n</li><li>file有个属性是uniqueIdentifier，代表文件唯一标示，我们把计算出来的MD5赋值给这个属性 file.uniqueIdentifier = md5，这就实现了我们最终的目的。\n</li><li>通过file.resume()开始/继续文件上传。</li></ol><pre><code>/**\n* 计算md5，实现断点续传及秒传\n* @param file\n*/\n/**\n* 计算md5，实现断点续传及秒传\n* @param file\n*/\n computeMD5(file) {\n    let fileReader = new FileReader();\n    let time = new Date().getTime();\n    let blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;\n    let currentChunk = 0;\n    const chunkSize = 10 * 1024 * 1000;\n    let chunks = Math.ceil(file.size / chunkSize);\n    let spark = new SparkMD5.ArrayBuffer();\n    \n    // 文件状态设为\"计算MD5\"\n    this.statusSet(file.id, 'md5');\n    \n    file.pause();\n    \n    loadNext();\n    \n    fileReader.onload = (e =&gt; {\n        spark.append(e.target.result);\n        if (currentChunk &lt; chunks) {\n            currentChunk++;\n            loadNext();\n            // 实时展示MD5的计算进度\n            this.$nextTick(() =&gt; {\n                $(`.myStatus_${file.id}`).text('校验MD5 '+ ((currentChunk/chunks)*100).toFixed(0)+'%')\n            })\n        } else {\n            let md5 = spark.end();\n            this.computeMD5Success(md5, file);\n            console.log(`MD5计算完毕：${file.name} \\nMD5：${md5} \\n分片：${chunks} 大小:${file.size} 用时：${new Date().getTime() - time} ms`);\n        }\n    });\n    fileReader.onerror = function () {\n        this.error(`文件${file.name}读取出错，请检查该文件`)\n        file.cancel();\n    };\n    function loadNext() {\n        let start = currentChunk * chunkSize;\n        let end = ((start + chunkSize) &gt;= file.size) ? file.size : start + chunkSize;\n        fileReader.readAsArrayBuffer(blobSlice.call(file.file, start, end));\n    }\n},\n\ncomputeMD5Success(md5, file) {\n    // 将自定义参数直接加载uploader实例的opts上\n    Object.assign(this.uploader.opts, {\n        query: {\n            ...this.params,\n        }\n    })\n    file.uniqueIdentifier = md5;\n    file.resume();\n    this.statusRemove(file.id);\n},</code></pre><p>给file的uniqueIdentifier 属性赋值后，请求中的identifier即是我们计算出来的MD5</p><p><img src=\"./app/json/frames/vueSimpleUploader/img/3.png\" style=\"max-width:100%;\"></p>"}}