{"sta":1,"data":{"subTitle":"文件上传流程概览","content":"<h3>1. 点击按钮，触发文件上传操作：&nbsp;</h3><p>(如果你做的不是全局上传的功能，而是直接点击上传，忽略这一步。）&nbsp;</p><p>&nbsp;因为我做的是全局上传的插件，要先把上传的窗口隐藏起来，在点击某个上传按钮的时候，用Bus发送一个openUploader的事件，在globalUploader.vue中接收该事件，trigger我们uploader-btn的click事件。&nbsp;</p><p>&nbsp;在某个页面中，点击上传按钮，同时把要给后台的参数带过来（如果有的话），这里组件之间传值我用的event bus，当然用vuex会更好：</p><pre><code>Bus.$emit('openUploader', {\n   superiorID: this.superiorID\n})</code></pre><p>在globalUploader.vue中接收该事件：</p><pre><code>Bus.$on('openUploader', query =&gt; {\n    this.params = query || {};\n\n    if (this.$refs.uploadBtn) {\n\t    // 这样就打开了选择文件的操作窗口\n        $('#global-uploader-btn').click();\n    }\n});</code></pre><h3>2. 选择文件后，将上传的窗口展示出来，开始md5的计算工作</h3><pre><code>onFileAdded(file) {\n    this.panelShow = true;\n\t\n\t// 计算MD5，下文会提到\n    this.computeMD5(file);\n},</code></pre><p>这里有个前提，我在uploader中将autoStart设为了false，为什么要这么做？</p><blockquote>在选择文件之后，我要计算MD5，以此来实现断点续传及秒传的功能，所以选择文件后直接开始上传肯定不行，要等MD5计算完毕之后，再开始文件上传的操作。</blockquote><p>具体的MD5计算方法，会在下面讲，这里先简单引出。</p><p>上传过程中，会不断触发file-progress上传进度的回调</p><pre><code>// 文件进度的回调\nonFileProgress(rootFile, file, chunk) {\n    console.log(`上传中 ${file.name}，chunk：${chunk.startByte / 1024 / 1024} ~ ${chunk.endByte / 1024 / 1024}`)\n},</code></pre><h3>3. 文件上传成功后</h3><p>文件上传成功后，在“上传完成”的回调中，通过服务端返回的needMerge字段，来判断是否需要再发送合并分片的请求，\n<br>如果这个字段为true，则需要给后台发一个请求合并的ajax请求，否则直接上传成功。\n<br>\n<br>注意：这里的needMerge是我和后台商议决定的字段名</p><pre><code>onFileSuccess(rootFile, file, response, chunk) {\n    let res = JSON.parse(response);\n\n    // 服务器自定义的错误，这种错误是Uploader无法拦截的\n    if (!res.result) {\n        this.$message({ message: res.message, type: 'error' });\n        return\n    }\n\t\n\t// 如果服务端返回需要合并\n    if (res.needMerge) {\n        api.mergeSimpleUpload({\n            tempName: res.tempName,\n            fileName: file.name,\n            ...this.params,\n        }).then(data =&gt; {\n            // 文件合并成功\n            Bus.$emit('fileSuccess', data);\n        }).catch(e =&gt; {});\n    // 不需要合并    \n    } else {\n        Bus.$emit('fileSuccess', res);\n        console.log('上传成功');\n    }\n},\n\nonFileError(rootFile, file, response, chunk) {\n\tconsole.log(error)\n},</code></pre><p><br></p>"}}