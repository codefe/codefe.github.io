{"sta":1,"data":{"subTitle":"Vue3里为什么要用Proxy替代defineProperty","content":"<h3>一、Object.defineProperty</h3><p>定义：Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象\n<br>为什么能实现响应式\n<br>通过defineProperty 两个属性，get及set\n<br>\n<br><h4>get\n</h4>属性的 getter 函数，当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值\n<br><h4>set\n</h4>属性的 setter 函数，当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined\n<br>下面通过代码展示：\n<br>定义一个响应式函数defineReactive\n<br>\n</p><pre>function update() {\n    app.innerText = obj.foo\n}\n\nfunction defineReactive(obj, key, val) {\n    Object.defineProperty(obj, key, {\n        get() {\n            console.log(`get ${key}:${val}`);\n            return val\n        },\n        set(newVal) {\n            if (newVal !== val) {\n                val = newVal\n                update()\n            }\n        }\n    })\n}</pre><p>调用defineReactive，数据发生变化触发update方法，实现数据响应式</p><pre>const obj = {}\ndefineReactive(obj, 'foo', '')\nsetTimeout(()=&gt;{\n    obj.foo = new Date().toLocaleTimeString()\n},1000)\n在对象存在多个key情况下，需要进行遍历\nfunction observe(obj) {\n    if (typeof obj !== 'object' || obj == null) {\n        return\n    }\n    Object.keys(obj).forEach(key =&gt; {\n        defineReactive(obj, key, obj[key])\n    })\n}</pre><p>如果存在嵌套对象的情况，还需要在defineReactive中进行递归</p><pre>function defineReactive(obj, key, val) {\n    observe(val)\n    Object.defineProperty(obj, key, {\n        get() {\n            console.log(`get ${key}:${val}`);\n            return val\n        },\n        set(newVal) {\n            if (newVal !== val) {\n                val = newVal\n                update()\n            }\n        }\n    })\n}</pre><p>当给key赋值为对象的时候，还需要在set属性中进行递归</p><pre>set(newVal) {\n    if (newVal !== val) {\n        observe(newVal) // 新值是对象的情况\n        notifyUpdate()\n    }\n}</pre><p>上述例子能够实现对一个对象的基本响应式，但仍然存在诸多问题\n<br>现在对一个对象进行删除与添加属性操作，无法劫持到</p><pre>const obj = {\n    foo: \"foo\",\n    bar: \"bar\"\n}\nobserve(obj)\ndelete obj.foo // no ok\nobj.jar = 'xxx' // no ok</pre><p>当我们对一个数组进行监听的时候，并不那么好使了</p><pre>const arrData = [1,2,3,4,5];\narrData.forEach((val,index)=&gt;{\n    defineProperty(arrData,index,val)\n})\narrData.push() // no ok\narrData.pop()  // no ok\narrDate[0] = 99 // ok</pre><p>可以看到数据的api无法劫持到，从而无法实现数据响应式，<br>所以在Vue2中，增加了set、delete API，并且对数组api方法进行一个重写<br>还有一个问题则是，如果存在深层的嵌套对象关系，需要深层的进行监听，造成了性能的极大问题<br>小结<br>检测不到对象属性的添加和删除<br>数组API方法无法监听到<br>需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题<br><br></p><h3>二、proxy</h3><p>&nbsp;\n<br>Proxy的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了\n<br>在ES6系列中，我们详细讲解过Proxy的使用，就不再述说了\n<br>下面通过代码进行展示：\n<br>定义一个响应式方法reactive</p><p>&nbsp;<span style=\"background-color: rgb(241, 241, 241); font-family: &quot;Lucida Console&quot;, Consolas, Monaco; white-space: pre-wrap;\">function reactive(obj) {</span><br></p><pre>    if (typeof obj !== 'object' &amp;&amp; obj != null) {\n        return obj\n    }\n    // Proxy相当于在对象外层加拦截\n    const observed = new Proxy(obj, {\n        get(target, key, receiver) {\n            const res = Reflect.get(target, key, receiver)\n            console.log(`获取${key}:${res}`)\n            return res\n        },\n        set(target, key, value, receiver) {\n            const res = Reflect.set(target, key, value, receiver)\n            console.log(`设置${key}:${value}`)\n            return res\n        },\n        deleteProperty(target, key) {\n            const res = Reflect.deleteProperty(target, key)\n            console.log(`删除${key}:${res}`)\n            return res\n        }\n    })\n    return observed\n}</pre><p>测试一下简单数据的操作，发现都能劫持</p><pre>const state = reactive({\n    foo: 'foo'\n})\n// 1.获取\nstate.foo // ok\n// 2.设置已存在属性\nstate.foo = 'fooooooo' // ok\n// 3.设置不存在属性\nstate.dong = 'dong' // ok\n// 4.删除属性\ndelete state.dong // ok</pre><p>再测试嵌套对象情况，这时候发现就不那么 OK 了</p><pre>const state = reactive({\n    bar: { a: 1 }\n})\n\n// 设置嵌套对象属性\nstate.bar.a = 10 // no ok\n如果要解决，需要在get之上再进行一层代理\nfunction reactive(obj) {\n    if (typeof obj !== 'object' &amp;&amp; obj != null) {\n        return obj\n    }\n    // Proxy相当于在对象外层加拦截\n    const observed = new Proxy(obj, {\n        get(target, key, receiver) {\n            const res = Reflect.get(target, key, receiver)\n            console.log(`获取${key}:${res}`)\n            return isObject(res) ? reactive(res) : res\n        },\n    return observed\n}</pre><p><h3>三、总结\n</h3>\n<br>Object.defineProperty只能遍历对象属性进行劫持</p><pre>function observe(obj) {\n    if (typeof obj !== 'object' || obj == null) {\n        return\n    }\n    Object.keys(obj).forEach(key =&gt; {\n        defineReactive(obj, key, obj[key])\n    })\n}</pre><p>Proxy直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的</p><pre>function reactive(obj) {\n    if (typeof obj !== 'object' &amp;&amp; obj != null) {\n        return obj\n    }\n    // Proxy相当于在对象外层加拦截\n    const observed = new Proxy(obj, {\n        get(target, key, receiver) {\n            const res = Reflect.get(target, key, receiver)\n            console.log(`获取${key}:${res}`)\n            return res\n        },\n        set(target, key, value, receiver) {\n            const res = Reflect.set(target, key, value, receiver)\n            console.log(`设置${key}:${value}`)\n            return res\n        },\n        deleteProperty(target, key) {\n            const res = Reflect.deleteProperty(target, key)\n            console.log(`删除${key}:${res}`)\n            return res\n        }\n    })\n    return observed\n}</pre><p>Proxy可以直接监听数组的变化（push、shift、splice）</p><pre>const obj = [1,2,3]\nconst proxtObj = reactive(obj)\nobj.psuh(4) // ok</pre><p>Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等，这是Object.defineProperty不具备的<br>正因为defineProperty自身的缺陷，导致Vue2在实现响应式过程需要实现其他的方法辅助（如重写数组方法、增加额外set、delete方法）<br></p><pre>// 数组重写\nconst originalProto = Array.prototype\nconst arrayProto = Object.create(originalProto)\n['push', 'pop', 'shift', 'unshift', 'splice', 'reverse', 'sort'].forEach(method =&gt; {\n  arrayProto[method] = function () {\n    originalProto[method].apply(this.arguments)\n    dep.notice()\n  }\n});\n\n// set、delete\nVue.set(obj,'bar','newbar')\nVue.delete(obj),'bar')</pre><p><br></p><p><font color=\"#c24f4a\">Proxy 不兼容IE，也没有 polyfill, defineProperty 能支持到IE9</font></p><p><br></p><p><br></p><p><br></p>"}}