{"sta":1,"data":{"subTitle":"nextTick实现原理","content":"<p>nextTick 方法主要是使用了 宏任务 和 微任务 定义了一个异步方法。多次调用 nextTick 会将方法存入队列中，通过这个异步方法清空当前队列。所以 nextTick 方法就是异步方法。</p><p>\n<br>默认在内部调用 nextTick 时会传入 flushSchedulerQueue 方法, 存在一个数组里并让它执行。用户有时也会调用 nextTick，调用时把用户传过来的 cb 也放在数组里，都是同一个数组 callbacks 。多次调用 nextTick 只会执行一次, 等到代码都执行完毕后，会调用 timerFunc 这个异步方法依次进行判断所支持的类型：\n<br>\n<br>1. 如支持 Promise 则把 timerFunc 包裹在了 Promise 中并把 flushCallbacks 放在了 then 中, 相当于异步执行了 flushCallBacks 。flushCallBacks 函数作用就是让传过来的方法依次执行。\n<br>\n<br>2. 如不是 IE 、支持 Mutationobserve 并且是原生的 Mutationobserve。首先声明一个变量并创建一个文本节点。接着创建 Mutationobserve 实例并把 flushCallBacks 传入, 调用 observe 方法去观测每一个节点。如果节点变化会异步执行 flushCallBacks方法。\n<br>\n<br>3. 如果支持 setImmediate , 则调用 setImmediate 传入flushCallBacks 异步执行。\n<br>\n<br>4. 以上都不支持就只能调用 setTimeout 传入 flushCallBacks 。\n<br>\n<br>作用：$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM。\n<br>\n<br></p>"}}