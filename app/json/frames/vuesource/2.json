{"sta":1,"data":{"subTitle":"Vue响应式数据的原理","content":"<p>在 Vue 初始化数据时, 使用 Object.defineProperty 重新定义 data 中所有属性，增加了数据 获取(getter) / 设置(setter) 的拦截功能。在 获取 / 设置 时可增加一些逻辑，这个逻辑交叫作 依赖收集。当页面取到对应属性时会进行依赖收集, 如果属性发生变化, 则会通知收集的依赖进行更新，而负责收集的就是 watcher。</p><p>\n<br>如负责渲染的 watcher 会在页面渲染的时候对数据进行取值，并把当前 watcher 先存起来对应到数据上，当更新数据的时候告诉对应的 watcher 去更新， 从而实现了数据响应式。\n<br>\n<br>data 一般分为两大类: 对象类型 和 数组：\n<br>\n<br><h3>对象：\n</h3>\n<br>在 Vue 初始化的时候，会调用 initData 方法初始化 data，它会拿到当前用户传入的数据。判断如果已经被观测过则不在观测，如果没有观测过则利用 new Observer 创建一个实例用来观测数据。如果数据是对象类型非数组的话会调用 this.walk(value) 方法把数据进行遍历，在内部使用 definReactive 方法重新定义( definReactive 是比较核心的方法: 定义响应式 )，而重新定义采用的就是 Object.defineProperty 。如当前对象的值还是个对象，会自动调用递归观测。当用户取值的时候会调用 get 方法并收集当前的 wacther 。在 set 方法里，数据变化时会调用 notify 方法触发数据对应的依赖进行更新。\n<br>\n<br><h3>数组:\n</h3>\n<br>使用函数劫持的方式重写了数组的方法，并进行了原型链重写。使 data 中的数组指向了自己定义的数组原型方法。这样的话，当调用数组 API 时，可以通知依赖更新。如果数组中包含着引用类型，则会对数组中的引用类型进行再次监控。\n<br>\n<br>也就是当创建了 Observer 观测实例后，如果数据是数组的话，判断是否支持自己原型链，如果不支持则调用 protoAugment 方法使目标指向 arrayMethods 方法。arrayMethods 就是重写的数组方法，包括 push、pop、shift 、unshift、splice、sort 和 reverse 共七个可以改变数组的方法，内部采用函数劫持的方式。在数组调用重写的方法之后，还是会调用原数组方法去更新数组。只不过重写的方法会通知视图更新。如果使用 push、unshift 和 splice 等方法新增数据，会调用 observeArray 方法对插入的数据再次进行观测。\n<br>\n<br>如果数组中有引用类型，则继续调用 observeArray 方法循环遍历每一项，继续深度观测。前提是每一项必须是对象类型, 否则 observe 方法会直接 return。\n<br>\n<br></p>"}}