{"sta":1,"data":{"subTitle":"vm.$set()具体是做什么的？","content":"<h3>this.xxx[xxx] = xxx,在data里添加一个数据，vue能不能侦测到？为什么？</h3><p>不能, 在new Vue()初始化的时候，在实例的data初始化的数据，才能被侦测到；因为在生命周期beforeCreate到create钩子之间会进行将data中的数据进去双向绑定的侦测；实例初始化完之后再添加的数据，无办法完成侦测初始化。<br></p><h3>有没有办法解决这个问题？</h3><p>通过vm.$set()可以解决这个问题。</p><p><blockquote>vm.$set(target,key,val)</blockquote>1.target如果是数组的话,先判断key是不是合法的下标,如果这两个条件都通过.那就将target.length和传进来的key取一个最大值赋值给target.length,然后调用splice去修改数组<br>2.key已经存在target里面并且不是存在target原型上的,那就是只改变值<br>3.target如果不是响应式数据,那么也只是改变数据,不需要通知watcher<br>4.如果target是vue实例,或者target是this.$data,那么直接退出程序<br>5.如果上面的条件都不满足,那么就是新添加的响应数据,那就直接调用defineReactive()去侦测该数据,然后去通知watcher<br><h3>具体实现代码如下：</h3></p><pre><code>function set(target, key, val) {\n\n    const ob = target.__ob__\n\n    if (Array.isArray(target) &amp;&amp; key &gt;= 0) {\n\n        target.length = Math.max(target.length, key)\n\n        target.splice(key, 1, val)\n\n        return val\n\n    }\n\n    if ((key in target &amp;&amp; !(key in Object.prototype)) || !ob) {\n\n        target[key] = val\n\n        return val\n\n    }\n\n    if (target._isVue || (ob &amp;&amp; ob.vmCount)) {\n\n        return val\n\n    }\n\n    defineReactive(ob.value, key, val)\n\n    ob.dep.notify()\n\n    return val\n\n}</code></pre><p>提示：这里解释一下target.__ob__，target._isVue,ob.vmCount是什么，如果target是一个双向绑定的是数据，它的原型上就会有一个__ob__属性，如果有原型上有_isVue属性，证明它是Vue的实例，如果__ob__.vmCount大于0就证明该target是根数据this.$data<br><br></p><p><br></p>"}}