{"sta":1,"data":{"subTitle":"Vue中Computed和watch","content":"<p>默认 computed 和 watch 内部都是用一个 watcher 实现的 。&nbsp;</p><p>computed有缓存功能, 不会先执行，只有当依赖的属性发生变化才会通知视图跟新。&nbsp;</p><p>watcher 没有缓存，默认会先执行，只要监听的属性发生变化就会更新视图。</p><p><h3>computed</h3>调用 initComputed 方法初始化计算属性时，会获取到用户定义的方法，并创建一个 watcher 把用户定义传进去， 这个 watcher 有个标识： lazy = true，默认不会执行用户定义的函数。还有个标识 dirty = true 默认去求值 。watcher 内部调用 defineComputed 方法将计算属性定义在实例上，其底层也是用的 Object.defineProperty。并且传入了 createComputedGetter 方法定义一个计算属性。在用户取值时，调用的是 createComputedGetter 返回函数 computedGetter。判断当前的 watcher.dirty 是否为 true。如果为 true 则调用 watcher.evaluate 方法求值。在求值时是调用的 this.get() 方法。其实 this.get() 就是用户传入的方法，执行时会把方法里的属性依次取值。而在取值前调用了 pushTarget 方法将 watcher 放在了全局上，当取值时会进行依赖收集，把当前的计算属性的 watcher 收集起来。等数据变化则通知 watcher 重新执行，也就是进入到了 update 方法中。update 并没有直接让 watcher 执行，而是将 dirty = true。这样的好处就是，如果 dirty = true，就进行求值，否则就返回上次计算后的值，从而实现了缓存的机制。<br><h3>watch</h3>调用 initWatch 方法初始化 watch 的时候，内部传入用户定义的方法调用了 createWatcher 方法。在 createWatcher 方法中比较核心的就是 $watch 方法，内部调用了 new Watcher 并传入了 expOrFn 和 回调函数。expOrFn 如果是个字符串的话, 会包装成一个函数并返回这个字符串。这时 lazy = false 了, 则直接调用了 this.get() 方法取属性的值。同 computed 在取值前也执行 pushTarget 方法将 watcher 放在了全局上, 当用户取值时就收集了 watcher。 因此当属性值发生改变时, watcher 就会更新。\n<br>如果监听的属性值是个对象，则取对象里的值就不会更新了，因为默认只能对属性进行依赖收集，不能对属性值是对象的进行依赖收集。想要不管属性值是否是对象都能求值进行收集依赖，可设置 deep = true 。如设置了deep = true ，则会调用 traverse 方法进行递归遍历。\n<br>\n<br></p>"}}