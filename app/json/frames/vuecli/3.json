{"sta":1,"data":{"subTitle":"Vue-cli 原理分析","content":"<h3 id=\"%E8%83%8C%E6%99%AF\" name=\"%E8%83%8C%E6%99%AF\">背景</h3><p>在平时工作中会有遇到许多以相同模板定制的小程序，因此想自己建立一个生成模板的脚手架工具，以模板为基础构建对应的小程序，而平时的小程序都是用mpvue框架来写的，因此首先先参考一下Vue-cli的原理。知道原理之后，再定制自己的模板脚手架肯定是事半功倍的。</p><p>在说代码之前我们首先回顾一下Vue-cli的使用，我们通常使用的是webpack模板包，输入的是以下代码。</p><p><code>vue init webpack [project-name]</code>\n在执行这段代码之后，系统会自动下载模板包，随后会询问我们一些问题，比如模板名称，作者，是否需要使用eslint，使用npm或者yarn进行构建等等，当所有问题我们回答之后，就开始生成脚手架项目。</p><p>我们将源码下载下来，源码仓库点击这里，平时用的脚手架还是2.0版本，要注意，默认的分支是在dev上，dev上是3.0版本。</p><p></p><p>我们首先看一下package.json，在文件当中有这么一段话</p><pre><code>{\n    \"bin\":{\n        \"vue\":\"bin/vue\",\n        \"vue-init\":\"bin/vue-init\",\n        \"vue-list\":\"bin/vue-list\"\n    }\n}</code></pre><p>由此可见，我们使用的命令 vue init，应该是来自bin/vue-init这个文件，我们接下来看一下这个文件中的内容</p><pre><code>bin/vue-init\nconstdownload =require('download-git-repo')\nconstprogram =require('commander')\nconstexists =require('fs').existsSync\nconstpath =require('path')\nconstora =require('ora')\nconsthome =require('user-home')\nconsttildify =require('tildify')\nconstchalk =require('chalk')\nconstinquirer =require('inquirer')\nconstrm =require('rimraf').sync\nconstlogger =require('../lib/logger')\nconstgenerate =require('../lib/generate')\nconstcheckVersion =require('../lib/check-version')\nconstwarnings =require('../lib/warnings')\nconstlocalPath =require('../lib/local-path')</code></pre><p>download-git-repo 一个用于下载git仓库的项目的模块\n<br>commander 可以将文字输出到终端当中\n<br>fs 是node的文件读写的模块\n<br>path 模块提供了一些工具函数，用于处理文件与目录的路径\n<br>ora 这个模块用于在终端里有显示载入动画\n<br>user-home 获取用户主目录的路径\n<br>tildify 将绝对路径转换为波形路径 比如/Users/sindresorhus/dev → ~/dev\n<br>inquirer 是一个命令行的回答的模块，你可以自己设定终端的问题，然后对这些回答给出相应的处理\n<br>rimraf 是一个可以使用 UNIX 命令 rm -rf的模块\n<br>剩下的本地路径的模块其实都是一些工具类，等用到的时候我们再来讲\n<br>\n<br>// 是否为本地路径的方法 主要是判断模板路径当中是否存在 ./\n<br>const isLocalPath = localPath.isLocalPath\n<br>// 获取模板路径的方法 如果路径参数是绝对路径 则直接返回 如果是相对的 则根据当前路径拼接</p><pre><code>constgetTemplatePath = localPath.getTemplatePath\n\n/**\n\n* Usage.\n\n*/\n\nprogram\n\n.usage('&lt;template-name&gt; [project-name]')\n\n.option('-c, --clone','use git clone')\n\n.option('--offline','use cached template')\n\n/**\n\n* Help.\n\n*/\n\nprogram.on('--help', () =&gt; {\n\nconsole.log('  Examples:')\n\nconsole.log()\n\nconsole.log(chalk.gray('    # create a new project with an official template'))\n\nconsole.log('    $ vue init webpack my-project')\n\nconsole.log()\n\nconsole.log(chalk.gray('    # create a new project straight from a github template'))\n\nconsole.log('    $ vue init username/repo my-project')\n\nconsole.log()\n\n})\n\n/**\n\n* Help.\n\n*/\n\nfunctionhelp(){\n\nprogram.parse(process.argv)\n\nif(program.args.length &lt;1)returnprogram.help()\n\n}\n\nhelp()</code></pre><p>这部分代码声明了vue init用法，如果在终端当中 输入 vue init --help或者跟在vue init 后面的参数长度小于1，也会输出下面的描述</p><pre><code>Usage: vue-init  [project-name]\n\nOptions:\n\n-c, --cloneusegit clone\n\n--offlineusecached template\n\n-h, --help   output usage information\n\nExamples:\n\n# create a new project with an official template\n\n$ vue init webpackmy-project\n\n# create a new project straight from a github template\n\n$ vue init username/repomy-project</code></pre><p>接下来是一些变量的获取</p><pre><code>/**Settings.*/\n\n// 模板路径\n\nlettemplate = program.args[0]\n\nconsthasSlash = template.indexOf('/') &gt;-1\n\n// 项目名称\n\nconstrawName = program.args[1]\n\nconstinPlace = !rawName || rawName ==='.'\n\n// 如果不存在项目名称或项目名称输入的'.' 则name取的是 当前文件夹的名称\n\nconstname = inPlace ? path.relative('../', process.cwd()) : rawName\n\n// 输出路径\n\nconstto = path.resolve(rawName ||'.')\n\n// 是否需要用到 git clone\n\nconstclone = program.clone ||false\n\n// tmp为本地模板路径 如果 是离线状态 那么模板路径取本地的\n\nconsttmp = path.join(home,'.vue-templates', template.replace(/[/:]/g,'-'))\n\nif(program.offline) {\n\nconsole.log(`&gt; Use cached template at${chalk.yellow(tildify(tmp))}`)\n\ntemplate = tmp\n\n}</code></pre><p>接下来主要是根据模板名称，来下载并生产模板，如果是本地的模板路径，就直接生成。</p><pre><code>/**\n\n* Check, download and generate the project.\n\n*/\n\nfunctionrun(){\n\n// 判断是否是本地模板路径\n\nif(isLocalPath(template)) {\n\n// 获取模板地址\n\nconsttemplatePath = getTemplatePath(template)\n\n// 如果本地模板路径存在 则开始生成模板\n\nif(exists(templatePath)) {\n\ngenerate(name, templatePath, to, err =&gt; {\n\nif(err) logger.fatal(err)\n\nconsole.log()\n\nlogger.success('Generated \"%s\".', name)\n\n})\n\n}else{\n\nlogger.fatal('Local template \"%s\" not found.', template)\n\n}\n\n}else{\n\n// 非本地模板路径 则先检查版本\n\ncheckVersion(()=&gt;{\n\n// 路径中是否 包含'/'\n\n// 如果没有 则进入这个逻辑\n\nif(!hasSlash) {\n\n// 拼接路径 'vuejs-tempalte'下的都是官方的模板包\n\nconstofficialTemplate ='vuejs-templates/'+ template\n\n// 如果路径当中存在 '#'则直接下载\n\nif(template.indexOf('#') !==-1) {\n\ndownloadAndGenerate(officialTemplate)\n\n}else{\n\n// 如果不存在 -2.0的字符串 则会输出 模板废弃的相关提示\n\nif(template.indexOf('-2.0') !==-1) {\n\nwarnings.v2SuffixTemplatesDeprecated(template, inPlace ?'': name)\n\nreturn\n\n}\n\n// 下载并生产模板\n\ndownloadAndGenerate(officialTemplate)\n\n}\n\n}else{\n\n// 下载并生生成模板\n\ndownloadAndGenerate(template)\n\n}\n\n})\n\n}\n\n}</code></pre><p>我们来看下 downloadAndGenerate这个方法</p><pre><code>/**\n\n* Download a generate from a template repo.\n\n*\n\n*@param{String} template\n\n*/\n\nfunctiondownloadAndGenerate(template){\n\n// 执行加载动画\n\nconstspinner = ora('downloading template')\n\nspinner.start()\n\n// Remove if local template exists\n\n// 删除本地存在的模板\n\nif(exists(tmp)) rm(tmp)\n\n// template参数为目标地址 tmp为下载地址 clone参数代表是否需要clone\n\ndownload(template, tmp, {clone}, err =&gt; {\n\n// 结束加载动画\n\nspinner.stop()\n\n// 如果下载出错 输出日志\n\nif(err) logger.fatal('Failed to download repo '+ template +': '+ err.message.trim())\n\n// 模板下载成功之后进入生产模板的方法中 这里我们再进一步讲\n\ngenerate(name, tmp, to, err =&gt; {\n\nif(err) logger.fatal(err)\n\nconsole.log()\n\nlogger.success('Generated \"%s\".', name)\n\n})\n\n})\n\n}</code></pre><p>到这里为止，bin/vue-init就讲完了，该文件做的最主要的一件事情，就是根据模板名称，来下载生成模板，但是具体下载和生成的模板的方法并不在里面。\n<br>\n<br>下载模板\n<br>下载模板用的download方法是属于download-git-repo模块的。\n<br>\n<br>最基础的用法为如下用法，这里的参数很好理解，第一个参数为仓库地址，第二个为输出地址，第三个是否需要 git clone，带四个为回调参数</p><pre><code>download('flipxfx/download-git-repo-fixture','test/tmp',{clone:true},function(err){\n\nconsole.log(err ?'Error':'Success')\n\n})</code></pre><p>在上面的run方法中有提到一个#的字符串实际就是这个模块下载分支模块的用法</p><pre><code>download('bitbucket:flipxfx/download-git-repo-fixture#my-branch','test/tmp', {clone:true},function(err){\n\nconsole.log(err ?'Error':'Success')\n\n})</code></pre><p>生成模板\n<br>模板生成generate方法在generate.js当中，我们继续来看一下</p><pre><code>generate.js\n\nconstchalk =require('chalk')\n\nconstMetalsmith =require('metalsmith')\n\nconstHandlebars =require('handlebars')\n\nconstasync=require('async')\n\nconstrender =require('consolidate').handlebars.render\n\nconstpath =require('path')\n\nconstmultimatch =require('multimatch')\n\nconstgetOptions =require('./options')\n\nconstask =require('./ask')\n\nconstfilter =require('./filter')\n\nconstlogger =require('./logger')</code></pre><p>chalk 是一个可以让终端输出内容变色的模块\n<br>Metalsmith是一个静态网站（博客，项目）的生成库\n<br>handlerbars 是一个模板编译器，通过template和json，输出一个html\n<br>async 异步处理模块，有点类似让方法变成一个线程\n<br>consolidate 模板引擎整合库\n<br>multimatch 一个字符串数组匹配的库\n<br>options 是一个自己定义的配置项文件\n<br>\n<br>随后注册了2个渲染器，类似于vue中的 vif velse的条件渲染</p><pre><code>// register handlebars helper\n\nHandlebars.registerHelper('if_eq',function(a, b, opts){\n\nreturna === b\n\n? opts.fn(this)\n\n: opts.inverse(this)\n\n})\n\nHandlebars.registerHelper('unless_eq',function(a, b, opts){\n\nreturna === b\n\n? opts.inverse(this)\n\n: opts.fn(this)\n\n})</code></pre><p>接下来看关键的generate方法</p><pre><code>module.exports =functiongenerate(name, src, dest, done){\n\n// 读取了src目录下的 配置文件信息， 同时将 name auther(当前git用户) 赋值到了 opts 当中\n\nconstopts = getOptions(name, src)\n\n// 拼接了目录 src/{template} 要在这个目录下生产静态文件\n\nconstmetalsmith = Metalsmith(path.join(src,'template'))\n\n// 将metalsmitch中的meta 与 三个属性合并起来 形成 data\n\nconstdata =Object.assign(metalsmith.metadata(), {\n\ndestDirName: name,\n\ninPlace: dest === process.cwd(),\n\nnoEscape:true\n\n})\n\n// 遍历 meta.js元数据中的helpers对象，注册渲染模板数据\n\n// 分别指定了 if_or 和   template_version内容\n\nopts.helpers &amp;&amp;Object.keys(opts.helpers).map(key=&gt;{\n\nHandlebars.registerHelper(key, opts.helpers[key])\n\n})\n\nconsthelpers = { chalk, logger }\n\n// 将metalsmith metadata 数据 和 { isNotTest, isTest 合并 }\n\nif(opts.metalsmith &amp;&amp;typeofopts.metalsmith.before ==='function') {\n\nopts.metalsmith.before(metalsmith, opts, helpers)\n\n}\n\n// askQuestions是会在终端里询问一些问题\n\n// 名称 描述 作者 是要什么构建 在meta.js 的opts.prompts当中\n\n// filterFiles 是用来过滤文件\n\n// renderTemplateFiles 是一个渲染插件\n\nmetalsmith.use(askQuestions(opts.prompts))\n\n.use(filterFiles(opts.filters))\n\n.use(renderTemplateFiles(opts.skipInterpolation))\n\nif(typeofopts.metalsmith ==='function') {\n\nopts.metalsmith(metalsmith, opts, helpers)\n\n}elseif(opts.metalsmith &amp;&amp;typeofopts.metalsmith.after ==='function') {\n\nopts.metalsmith.after(metalsmith, opts, helpers)\n\n}\n\n// clean方法是设置在写入之前是否删除原先目标目录 默认为true\n\n// source方法是设置原路径\n\n// destination方法就是设置输出的目录\n\n// build方法执行构建\n\nmetalsmith.clean(false)\n\n.source('.')// start from template root instead of `./src` which is Metalsmith's default for `source`\n\n.destination(dest)\n\n.build((err, files) =&gt;{\n\ndone(err)\n\nif(typeofopts.complete ==='function') {\n\n// 当生成完毕之后执行 meta.js当中的 opts.complete方法\n\nconsthelpers = { chalk, logger, files }\n\nopts.complete(data, helpers)\n\n}else{\n\nlogMessage(opts.completeMessage, data)\n\n}\n\n})\n\nreturndata\n\n}</code></pre><p>meta.js\n<br>接下来看以下complete方法</p><pre><code>complete:function(data, { chalk }){\n\nconstgreen = chalk.green\n\n// 会将已有的packagejoson 依赖声明重新排序\n\nsortDependencies(data, green)\n\nconstcwd = path.join(process.cwd(), data.inPlace ?'': data.destDirName)\n\n// 是否需要自动安装 这个在之前构建前的询问当中 是我们自己选择的\n\nif(data.autoInstall) {\n\n// 在终端中执行 install 命令\n\ninstallDependencies(cwd, data.autoInstall, green)\n\n.then(()=&gt;{\n\nreturnrunLintFix(cwd, data, green)\n\n})\n\n.then(()=&gt;{\n\nprintMessage(data, green)\n\n})\n\n.catch(e=&gt;{\n\nconsole.log(chalk.red('Error:'), e)\n\n})\n\n}else{\n\nprintMessage(data, chalk)\n\n}\n\n}</code></pre><p>构建自定义模板\n<br>在看完vue-init命令的原理之后，其实定制自定义的模板是很简单的事情，我们只要做2件事\n<br>\n<br>首先我们需要有一个自己模板项目\n<br>如果需要自定义一些变量，就需要在模板的meta.js当中定制\n<br>由于下载模块使用的是download-git-repo模块，它本身是支持在github，gitlab，bitucket上下载的，到时候我们只需要将定制好的模板项目放到git远程仓库上即可。\n<br>\n<br>由于我需要定义的是小程序的开发模板，mpvue本身也有一个quickstart的模板，那么我们就在它的基础上进行定制，首先我们将它fork下来，新建一个custom分支，在这个分支上进行定制。\n<br>\n<br>我们需要定制的地方有用到的依赖库，需要额外用到less以及wxparse\n<br>因此我们在 template/package.json当中进行添加</p><pre><code>{\n\n// ... 部分省略\n\n\"dependencies\": {\n\n\"mpvue\":\"^1.0.11\"{{#vuex}},\n\n\"vuex\":\"^3.0.1\"{{/vuex}}\n\n},\n\n\"devDependencies\": {\n\n// ... 省略\n\n// 这是添加的包\n\n\"less\":\"^3.0.4\",\n\n\"less-loader\":\"^4.1.0\",\n\n\"mpvue-wxparse\":\"^0.6.5\"\n\n}\n\n}</code></pre><p>除此之外，我们还需要定制一下eslint规则，由于只用到standard，因此我们在meta.js当中 可以将 airbnb风格的提问删除</p><pre><code>\"lintConfig\": {\n\n\"when\":\"lint\",\n\n\"type\":\"list\",\n\n\"message\":\"Pick an ESLint preset\",\n\n\"choices\": [\n\n{\n\n\"name\":\"Standard (https://github.com/feross/standard)\",\n\n\"value\":\"standard\",\n\n\"short\":\"Standard\"\n\n},\n\n{\n\n\"name\":\"none (configure it yourself)\",\n\n\"value\":\"none\",\n\n\"short\":\"none\"\n\n}\n\n]\n\n}</code></pre><pre><code>.eslinttrc.js\n\n'rules': {\n\n{{#if_eq lintConfig \"standard\"}}\n\n\"camelcase\":0,\n\n//allow paren-less arrow functions\n\n\"arrow-parens\":0,\n\n\"space-before-function-paren\":0,\n\n//allow async-await\n\n\"generator-star-spacing\":0,\n\n{{/if_eq}}\n\n{{#if_eq lintConfig \"airbnb\"}}\n\n//don't require .vue extension when importing\n\n'\n\nimport/extensions': ['error', 'always', {\n\n'\n\njs': 'never',\n\n'\n\nvue': 'never'\n\n}],\n\n// allow optionalDependencies\n\n'\n\nimport/no-extraneous-dependencies': ['error', {\n\n'\n\noptionalDependencies': ['test/unit/index.js']\n\n}],\n\n{{/if_eq}}\n\n// allow debugger during development\n\n'\n\nno-debugger': process.env.NODE_ENV === 'production' ? 2 : 0\n\n}</code></pre><p>最后我们在构建时的提问当中，再设置一个小程序名称的提问，而这个名称会设置到导航的标题当中。\n<br>提问是在meta.js当中添加</p><pre><code>\"prompts\": {\n\n\"name\": {\n\n\"type\":\"string\",\n\n\"required\":true,\n\n\"message\":\"Project name\"\n\n},\n\n// 新增提问\n\n\"appName\": {\n\n\"type\":\"string\",\n\n\"required\":true,\n\n\"message\":\"App name\"\n\n}\n\n}</code></pre><p>main.json</p><pre><code>{\n\n\"pages\": [\n\n\"pages/index/main\",\n\n\"pages/counter/main\",\n\n\"pages/logs/main\"\n\n],\n\n\"window\": {\n\n\"backgroundTextStyle\":\"light\",\n\n\"navigationBarBackgroundColor\":\"#fff\",\n\n// 根据提问设置标题\n\n\"navigationBarTitleText\":\"{{appName}}\",\n\n\"navigationBarTextStyle\":\"black\"\n\n}\n\n}</code></pre><p>最后我们来尝试一下我们自己的模板\n<br>\n<br><blockquote>vue init Baifann/mpvue-quickstart#custom min-app-project</blockquote></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>"}}