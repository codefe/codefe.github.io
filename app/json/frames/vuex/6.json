{"sta":1,"data":{"subTitle":"vuex 基础使用Store、State、Getter","content":"<h3>一、vuex 的核心思想（流程）：</h3><p><img src=\"/app/json/frames/vuex/imgs/vuex.png\" style=\"max-width:100%;\"></p><p>相比于 Flux，vuex 对其进行了 vue 的适配，借助 vue 的 细粒度响应机制（文档说的）进行高效的状态更新，基本上大型项目如果要进行状态管理，直接就是 vuex 就可以，而 React 系，则存在 Flux、Redux、MobX 等等。<br>有些时候官方规范化之后也有好处。\n<br>\n<br>安装引入很简单：</p><pre>yarn add vuex\n\nimport Vuex from 'vuex'</pre><p><h3>二、Store 及基本使用\n</h3>严格来说，Store 的概念并不是 vuex 的直接子集属性，每个 vuex 的核心就是 Store，也可以称之为仓库，而这个 Store 就是一个单一状态管理容器。<br>Store 中可以配置 State、getter、mutation 等属性，而Store 的属性涵盖了对一个数据的初始化、获取及更新操作。<br>Store 维护了一套响应式的状态存储机制，也就是当 Store 的数据发生变化是，会通知 Vue 组件，进行响应式的更新。<br>一个 Store 会有一些约定好的属性，因此定义一个 Store 的过程基本如下：\n<br>\n<br>引入 Vue 及 Vuex，并启用 Vuex:</p><pre>import Vue from 'vue';\nimport Vuex from 'vuex';\n\nVue.use(Vuex);</pre><p>一定要确保 Vue.use(Vuex); 在 new Vuex.Store({}) 之前调用， 否则你会收到这样一个错误：<br><blockquote>[vuex] must call Vue.use(Vuex) before creating a store instance.\n</blockquote>\n定义 Store 的 state：</p><pre>const state = {\n  count: 0\n}</pre><p>定义 Store 的 getters：（如果需要）</p><pre>const getters = {\n  getCount(state) {\n    return state.count;\n  }\n}</pre><p>这样可以不通过 this.$store.state.count 的形式访问，而是可以通过 this.$store.getters.getCount 的形式访问（当然还有更简洁方式），出了访问方式变动之外，可以在函数中进行一系列操作，然后在返回数据。\n<br>\n<br>定义 Store 的 mutations:</p><pre>const mutations = {\n  increment(state){\n    state.count ++ ;\n  }\n}</pre><p>getters 是获取数据，而 mutations 则是显示的对数据进行更改。 Store 的 state 是不允许通过 this.$store.state.count = 2 的形式去修改的，必须显示的提交修改才能去执行修改。\n<br>\n<br>提交修改的方式是 this.$store.commit(mutationName)。<br>将 state、getters 以及 mutations 作为初始化内容传入 new Vuex.Store({}):</p><pre>const store = new Vuex.Store({\n state,\n getters,\n mutations\n});\n\nexport default store;</pre><p>最后将 store 导出，然后在 new Vue({}) 的地方引入，挂载到 store 属性下即可。</p><pre>import store from './store';\n\nnew Vue({\n  el: '#app',\n  router,\n  store,\n  render: (c) =&gt; {return c(App)}\n});</pre><p><h3>三、state\n</h3>Vuex 是一个单一的状态树来管理状态，而 Store 则是Vuex 的存储仓库，每个 Store 中真实表示数据或者状态的则是 Store 的 state 属性。<br>如果熟悉 React 则就无需强调什么是 state 了， 所有的数据初始化定义都应该在 state 中定义，并且获取数据也可以从 state 中取，只是无法直接去更改某个 state 的值。<br>比如在模板中读取某个 state 的值的方式：</p><pre>&lt;p&gt;count is: {{this.$store.state.count}}&lt;/p&gt;</pre><pre>console.log(this.$store.state.count)</pre><p>而在如果你没有使用 getters 的话，一般也会推荐将 state 的值初始化给组件computed 的某个属性，能够简化很多 this.$store.state.xxx 的代码。\n<br>\n<br>比如我将state.count 赋值给 computed 中的 count：</p><pre>computed: {\n      count() {\n        return this.$store.state.count\n      }\n    },</pre><p>这样在模板中我可以直接使用 count:</p><pre>&lt;p&gt;count is: {{count}}&lt;/p&gt;</pre><p><h3>mapState\n</h3>我本人不觉得 mapState 有什么特别大的帮助，只是在开发上可能少写点代码而已\n<br>\n<br>使用 mapState 需要首先从 vuex 中引入</p><pre>import {mapState} from 'vuex';</pre><p>即使每次初始化 computed，也需要写大量的 this.$store.state.xx 因此 vuex 暴露一个 mapState 的属性，用来边界开发，尤其是将 state 的值初始化给 computed 的时候：</p><pre>computed: mapState({\n    // 箭头函数可使代码更简练\n    count: state =&gt; state.count,\n\n    // 传字符串参数 'count' 等同于 `state =&gt; state.count`\n    countAlias: 'count',\n\n    // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n    countPlusLocalState (state) {\n      return state.count + this.localCount\n    }\n  })\n}</pre><p>上面 computed 的定义中，直接是运行了 mapState 方法， 然后参数是一个对象：\n<br>\n<br><blockquote>count: state =&gt; state.count：定义一个 computed:count，通过一个函数传入 state 参数，并返回 state.count<br>\ncountAlias: 'count', 直接对 state.count 进行重命名<br>\ncountPlusLocalState (state) { return state.count + this.loca.... } 如果需要获取 本组件的一些状态，则必须使用常规函数的形式，并且将 state 传入函数，其中可以通过 this.xxx 获取局部状态。\n</blockquote>如果想直接用 state 的名称，可以直接给 mapState 传一个数组：</p><pre>computed: mapState([\n  // 映射 this.count 为 store.state.count\n  'count'\n])</pre><p>而如果本地也有 computed 数据，然后也需要 state 初始化一些本地数据，借助 mapState 实现的话，需要进行对象展开符，当然，mapState 该怎么用还是怎么用，与上面一样。</p><pre>computed: {\n  localComputed () { /* ... */ },\n  // 使用对象展开运算符将此对象混入到外部对象中\n  ...mapState({\n    // ...\n  })\n}</pre><p><h3>四、Getters\n</h3>getters 只是为了更加方便的获取数据，比如一个 count state，如果不同的组件需要不同结果的 count，则一般都是由业务组件去做这个事情，而 store 也可以把这个事情给做掉。<br>举例：我需要在每个 state.count 的值前面，在加上一个 state.num，组合成一个新的值给多个组件使用。<br>如果组件完成这个事情，则需要有组件去实现，（包括金钱、时间的格式化，内容过滤等操作），而通过 getter 则可以提供统一的访问形式。<br><h4>1、getter 的定义及基本使用\n</h4>getter 的定义也很简单，定义某个属性，方法中形参是 state：</p><pre>getters: {\n    doneTodos: state =&gt; {\n      return state.todos.filter(todo =&gt; todo.done)\n    }\n  }</pre><p>通过传入的 state 参数，可以访问当前 store 的状态，进行一系列的判断过滤等。</p><p><h4>2、多个 getter 配合\n</h4>getter 也可以结合其他的 getter 一起使用，getter 定义的第二个参数可以是其他 getter：</p><pre>getters: {\n  doneTodos: state =&gt; {\n      return state.todos.filter(todo =&gt; todo.done)\n  },\n  doneTodosCount: (state, getters) =&gt; {\n    return getters.doneTodos.length\n  }\n}</pre><p>上面的例子中，首先我已经定义完了 doneTodos 这个 getter，但是比如我还需要获取完成的 todo 的数量，如果我还是使用 state 的话，我还需要写一遍遍历判断最后计数。<br>而我直接使用当前 getters.doneTodos.length 就不需要再去写那些代码了。\n<br>\n<br><h4>3、getter 传参\n</h4>除此之外，还可以通过方法访问 getters，所谓的方法访问无非就是传递参数，来进行不同的预期处理：</p><pre>getters: {\n  getTodoById: (state) =&gt; (id) =&gt; {\n    return state.todos.find(todo =&gt; todo.id === id)\n  }\n}</pre><p>比如上面的 getters 支持通过 id 查找 todo，并且返回。<br>当定义好之后，就能够直接通过下面的方式查找需要的 todo：</p><pre>this.$store.getters.getTodoById(2) // -&gt; { id: 2, text: '...', done: false }</pre><p>而这种定义方式，无非就是一个科里化，没有什么新奇的玩意儿。\n<br>\n<br><h4>4、mapGetter\n</h4>mapGetter 的使用需要首先引入 import { mapGetters } from 'vuex'<br>mapGetter 如同 mapState 一样，没什么特别新奇的功能，也是一种辅助作用，写代码比较轻松，必须要写那么多的 this.$store.getters.name<br>而使用的形式也非常类似于 mapState：</p><pre>computed: mapGetter({\n    // 箭头函数可使代码更简练\n    count: getters=&gt; getters.getCount,\n\n    // 传字符串参数 'count' 等同于 `getters=&gt; getters.getCount`\n    countAlias: 'getCount',\n\n    // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n    countPlusLocalState (getters) {\n      return getters.getCount+ this.localCount\n    }\n  })\n}</pre><p><br></p><p><br></p>"}}