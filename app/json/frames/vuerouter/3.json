{"sta":1,"data":{"subTitle":"vue-router路由守卫","content":"<p>1. 全局守卫 ( vue-router 全局有三个守卫 )</p><p>router.beforeEach 全局前置守卫 进入路由之前\n<br>router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用\n<br>router.afterEach 全局后置钩子 进入路由之后\n<br>\n</p><pre><code>// main.js 入口文件\n  import router from './router'; // 引入路由\n  router.beforeEach((to, from, next) =&gt; { \n    next();\n  });\n  router.beforeResolve((to, from, next) =&gt; {\n    next();\n  });\n  router.afterEach((to, from) =&gt; {\n    console.log('afterEach 全局后置钩子');\n  });</code></pre><p><br></p><p>2. 路由独享守卫\n<br>\n</p><pre><code>const router = new VueRouter({\n    routes: [\n      {\n        path: '/foo',\n        component: Foo,\n        beforeEnter: (to, from, next) =&gt; { \n          // 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖\n        }\n      }\n    ]\n  })</code></pre><p><br></p><p>3. 路由组件内的守卫\n<br>beforeRouteEnter 进入路由前, 在路由独享守卫后调用 不能 获取组件实例 this，组件实例还没被创建\n<br>beforeRouteUpdate (2.2) 路由复用同一个组件时, 在当前路由改变，但是该组件被复用时调用 可以访问组件实例 this\n<br>beforeRouteLeave 离开当前路由时, 导航离开该组件的对应路由时调用，可以访问组件实例 this\n<br>\n<br></p>"}}