{"sta":1,"data":{"subTitle":"巧用二分查找实现多行文本溢出显示省略号","content":"<p>既然我们想控制文本在某行溢出省略，只需确定某行的最后一个字儿就好了，然后从该位置截取文本并加上省略号，实现思路很清晰。有两个值是必须要知道的，每行文字高度和容器的高度：<br></p><pre>// 取到元素高度，需减去上下的padding\n// getStyle用于获取元素的计算属性，int方法用于去掉元素单位（如将16px转成16）\nconst contentHeight = ele =&gt; {\n    const height = ele.offsetHeight;\n    const borderTop = int(getStyle('borderTop'));\n    const borderBottom = int(getStyle('borderBottom'));\n    const paddingTop = int(getStyle('paddingTop'));\n    const paddingBottom = int(getStyle('paddingBottom'));\n    return height - paddingTop - paddingBottom - borderTop - borderBottom; \n};\n// 获取每行文本高度：若获取到元素lineheight，取其值；若没取到，将元素替换为自定义文本并取其高度\n// fillText作用为替换元素内文本\nconst eleLineHeight = text =&gt; {\n    let lineHeight = int(getStyle('lineHeight'));\n    if (isNaN(lineHeight)) {\n        fillText('test');\n        lineHeight = contentHeight(ele);\n        fillText(text);\n    }\n    return lineHeight;\n};</pre><p>知道了这两个值，我们只能确定容器内文本的行数，又如何能够确定某行的最后一个字儿呢，网上给出了一个简单粗暴的方法，只需要往容器内递增文字，然后判断最后一个文字是不是在指定行，且它下一个字儿刚好位于下一行，那这个字儿应该就是我们要找的，talk is cheap，代码如下：</p><pre>const limitRows = 3;\nconst text = ele.innerText;\nlet len = 1;\nwhile (len) {\n    fillText(ele, text.slice(0, len) + '...');\n    const curRow = rows(contentHeight(ele), eleLineHeight(ele));\n    fillText(ele, text.slice(0, len + 1) + '...');\n    const nextRow = rows(contentHeight(ele), eleLineHeight(ele));\n    if (curRow === limitRows &amp;&amp; nextRow === limitRows + 1) {\n        fillText(ele, text.slice(0, len) + '...');\n        break;\n    }\n    len++;\n    if (len === text.length) {\n        break;\n    }\n}</pre><p>​功能算是实现了，但很容器发现一个问题，如若文字比较多，如第5000个字儿才是我们的目标，那么将会进行5000次的文本替换，这样巨量的dom操作指定会存在性能问题，经测试，果然浏览器出现了明显的卡顿。\n<br>\n<br>  发现问题，解决问题，才是一个优秀程序员的必备素养。绞尽脑汁后，想到两个方案，一为我们可以根据容器文本总行数和要限制行数来确定一个大概的位置，计算公式为： (limitRows / totalRows ) * textLength，以该位置为起点来进一步找到目标位置，将大大减少查找次数，具体实现读者可自行尝试。但这样也有美中不足的地儿，因为这个大概的位置并不准确，如果遇到极端情况，像最后一行文字过少，那么出现的误差就会很大。比如每行有60个字儿，共有241个字儿，文本共占据容器5行空间，而产品要求限制两行文本显示省略号，根据公式计算出的位置大概在第96个字儿，而实际的位置是第120个字儿左右的位置，那么我们将进行20多次的查找操作才能确定出这个位置。\n<br>\n<br>  ​该方法能带来一些效率上的提升，那还有木有更好的办法呢？答案当然是有的。涉及到多次查找的问题，前辈们已经总结了很多不错的算法，其中有一个叫二分查找，经典的js实现逻辑为：</p><pre>function binary_search(arr, key) {\n    var low = 0,\n        high = arr.length - 1;\n\n    while(low &lt;= high) {\n        var mid = parseInt((high + low) /2);\n        if(key == arr[mid]) {\n            return mid;\n        } else if(key &gt; arr[mid]) {\n            low = mid + 1;\n        } else {\n            high = mid -1;\n        }\n    }\n    return -1;\n}</pre><p>该算法真的能算上一种很高效的操作了，它的优点是比较次数少，查找速度快，平均性能好，时间复杂度为O(log2n)，这是个什么概念呢，也就是说32768个数字，最多只需要15次查找就能找到我们想要的那个。当然它的高效也有一定前提，要求数组是有序的，放在该需求中，我们的文字是无序的，但是文字的位置是有序的，稍做调整，就能满足我们现在的需求：</p><pre>// cb是一个回调函数，用于判断下一次操作是向前还是向后查找\nconst binarySearch(text, cb) {\n    let min = 0, max = text.length - 1;\n    while(min &lt;= max) {\n        const mid = parseInt((max + min) / 2);\n        const result = cb(mid);\n        max = result &gt; 0 ? mid - 1 : max;\n        min = result &lt; 0 ? mid + 1 : min;\n        if (result === 0) return mid;\n    }\n};</pre><p>有了该算法的支持，查找次数指数级降低，从而能够保证查找的性能，具体实现参照如下代码：</p><pre>const clamp = () =&gt; {\n    const pos = binarySearch(text, cur =&gt; {\n        const curRows = textRows(sliceText(cur));\n        if (curRows !== limitRows) return curRows - limitRows;\n        return textRows(sliceText(cur + 1)) - limitRows - 1;\n    });\n\n    fillText(sliceText(pos));\n};</pre><p>以上代码我们分析了下大体的实现流程，完整代码及使用如下（代码可以直接运行）：</p><pre>// 完整代码\n\n// 定义工具函数\nconst int = v =&gt; parseFloat(v);\nconst countRows = (h, l) =&gt; Math.round(h / l);\nconst binarySearch = (text, cb) =&gt; {\n    let min = 0, max = text.length - 1;\n    while(min &lt;= max) {\n        const mid = parseInt((max + min) / 2);\n        const result = cb(mid);\n        max = result &gt; 0 ? mid - 1 : max;\n        min = result &lt; 0 ? mid + 1 : min;\n        if (result === 0) return mid;\n    }\n};\n// 具体实现\nclass MultiClamp {\n    constructor(element, config = (params || {})) {\n        // 设置默认配置，并将用户配置添加到this\n        Object.assign(this, {\n            rows: 2,\n            ellipsis: '...',\n            expandText: '展开',\n            closeText: '收起',\n        }, config);\n\n        this.ele = element;\n        this.text = element.innerText;\n        this.singleLineHeight = this.eleLineHeight();\n\n        // 判断文本行数是否需要显示省略号，不需要直接返回\n        const initRows = countRows(this.contentHeight(), this.singleLineHeight);\n        if (initRows &lt;= this.rows) return;\n\n        // 如需要展开/收起功能，创建对应标签\n        if (this.expandable) this.expandableDom = this.createExpandableDom();\n        if (this.closeable) this.closeableDom = this.createCloseableDom();\n\n        // 文本溢出隐藏\n        this.clamp();\n    }\n    // 创建展开功能标签\n    createExpandableDom = () =&gt; {\n        const expendDom = document.createElement('span');\n        expendDom.innerHTML = this.expandText;\n        expendDom.className = 'expand';\n        expendDom.onclick = () =&gt; {\n            this.ele.innerHTML = this.text;\n            if (this.closeableDom) this.ele.appendChild(this.closeableDom);\n        };\n        return expendDom;   \n    }\n    // 创建收起功能标签\n    createCloseableDom = () =&gt; {\n        const closeDom = document.createElement('span');\n        closeDom.innerHTML = this.closeText;\n        closeDom.className = 'close';\n        closeDom.onclick = () =&gt; { this.clamp(); };\n        return closeDom;        \n    }\n    // 填充容器文本\n    fillText(text, addExp) {\n        this.ele.innerHTML = text;\n        if (addExp) this.ele.appendChild(this.expandableDom);\n    }\n    // 获取文本行数\n    textRows = text =&gt; {\n        this.fillText(text, this.expandable);\n        return countRows(this.contentHeight(), this.singleLineHeight);\n    }\n    // 根据位置截取文本\n    sliceText = pos =&gt; `${this.text.slice(0, pos)}${this.ellipsis}`\n    // 获取元素计算属性\n    getStyle = attr =&gt; (\n        window.getComputedStyle ? \n            window.getComputedStyle(this.ele, null)[attr] : \n            this.ele.currentStyle[attr]\n    )\n    // 获取容器高度\n    contentHeight() {\n        const height = this.ele.offsetHeight;\n        const attrs = ['borderTop', 'borderBottom', 'paddingTop', 'paddingBottom'];\n        return height - attrs.reduce((total, cur) =&gt; (total + int(this.getStyle(cur))), 0);\n    }\n    // 获取每行文本高度\n    eleLineHeight() {\n        let lineHeight = int(this.getStyle('lineHeight'));\n        if (isNaN(lineHeight)) {\n            this.fillText('test');\n            lineHeight = this.contentHeight(this.ele);\n            this.fillText(this.text);\n        }\n        return lineHeight;\n    }\n    // 文本溢出隐藏\n    clamp() {\n        const { text, rows, sliceText, textRows } = this;\n        const pos = binarySearch(text, cur =&gt; {\n            const curRows = textRows(sliceText(cur));\n            if (curRows !== rows) return curRows - rows;\n            return textRows(sliceText(cur + 1)) - rows - 1;\n        });\n        this.fillText(sliceText(pos), this.expandable);\n    }         \n}</pre><p>使用方法及效果</p><pre>new MultiClamp(containerElement, { \n    rows: 2, // 文本限制行数，默认两行\n    ellipsis: '...', // 扩展省略号\n    expandable: false, // 是否支持展开操作，默认不支持\n    expandText: '展开', // 展开操作按钮文案，默认为展开\n    closeable: false, // 是否支持收起操作，默认不支持\n    closeText: '收起' // 收起操作按钮文案，默认为收起\n})</pre><p><br></p>"}}