{"sta":1,"data":{"subTitle":"函数柯里化","content":"<pre><code>function add(a,b){\n             return a + b;\n         }\n         var currys = function(fn,args = []){\n             var length = fn.length; //计算期望函数的参数长度\n            args =args; //利用闭包特性保存参数\n             return function(){\n                 newArgs = [].slice.call(arguments); //将自身函数参数赋给新参数\n                 \n                 [].push.apply(newArgs,args); //将上回保留的参数push进新的数组\n                 \n                 if(newArgs.length&lt;length){ //判断当前函数的参数是否与期望函数参数一致\n                     return curry.call(this,fn,newArgs); //如果不够，递归调用\n                 }else{\n                     \n                     return fn.apply(this,newArgs); // 如果够，就执行期望函数\n                 }\n             }\n         }\n         var addcurry = currys(add);\n         console.log(addcurry(1)(2));</code></pre><p><br></p>"}}