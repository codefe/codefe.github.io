{"sta":1,"data":{"subTitle":"防抖&节流","content":"<p>防抖和节流属于高阶技巧，业务中比较多见的场合也就是搜索内容改变提示信息。即使不加也也不一定能看出区别，但是加了新手维护代码可能会崇拜你哦。&nbsp;</p><p><h3>区别</h3>函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。\n<br>防抖是将多次执行变为只执行一次，节流是将多次执行变为每隔一段时间执行。</p><p><h3>应用场景\n</h3><h4>　　防抖(debounce)</h4>　　　　search搜索联想，用户在不断输入值时，用防抖来节约请求资源。<br>　　　　window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次<br><h4>　　节流(throttle)</h4>　　　　鼠标不断点击触发，mousedown(单位时间内只触发一次)<br>　　　　监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断</p><h3>防抖&nbsp;</h3><p><font color=\"#c24f4a\">防抖原理：一定时间内，只有最后一次操作，再过wait毫秒后才执行函数</font></p><p>方法一</p><pre><code>function debounce(func, wait) {\n    let timeout;\n    return function () {\n        let context = this;\n        let args = arguments;\n\n        if (timeout) clearTimeout(timeout);\n        \n        timeout = setTimeout(() =&gt; {\n            func.apply(context, args)\n        }, wait);\n    }\n}</code></pre><p>方法二</p><pre><code>let timeout = null;\n\n/**\n * @param {Function} func 要执行的回调函数 \n * @param {Number} wait 延时的时间\n * @param {Boolean} immediate 是否立即执行 \n * @return null\n */\nfunction debounce(func, wait = 500, immediate = false) {\n\t// 清除定时器\n\tif (timeout !== null) clearTimeout(timeout);\n\t// 立即执行，此类情况一般用不到\n\tif (immediate) {\n\t\tvar callNow = !timeout;\n\t\ttimeout = setTimeout(function() {\n\t\t\ttimeout = null;\n\t\t}, wait);\n\t\tif (callNow) typeof func === 'function' &amp;&amp; func();\n\t} else {\n\t\t// 设置定时器，当最后一次操作后，timeout不会再被清除，所以在延时wait毫秒后执行func回调方法\n\t\ttimeout = setTimeout(function() {\n\t\t\ttypeof func === 'function' &amp;&amp; func();\n\t\t}, wait);\n\t}\n}\n\nexport default debounce</code></pre><p><br></p><h3>节流</h3><p><font color=\"#c24f4a\">节流原理：在一定时间内，只能触发一次</font></p><p>方法一</p><pre><code>function throttle(func, wait) {\n    let previous = 0;\n    return function() {\n        let now = Date.now();\n        let context = this;\n        let args = arguments;\n        if (now - previous &gt; wait) {\n            func.apply(context, args);\n            previous = now;\n        }\n    }\n}</code></pre><p>方法二</p><pre><code>let timer, flag;\n/**\n * @param {Function} func 要执行的回调函数 \n * @param {Number} wait 延时的时间\n * @param {Boolean} immediate 是否立即执行\n * @return null\n */\nfunction throttle(func, wait = 500, immediate = true) {\n\tif (immediate) {\n\t\tif (!flag) {\n\t\t\tflag = true;\n\t\t\t// 如果是立即执行，则在wait毫秒内开始时执行\n\t\t\ttypeof func === 'function' &amp;&amp; func();\n\t\t\ttimer = setTimeout(() =&gt; {\n\t\t\t\tflag = false;\n\t\t\t}, wait);\n\t\t}\n\t} else {\n\t\tif (!flag) {\n\t\t\tflag = true\n\t\t\t// 如果是非立即执行，则在wait毫秒内的结束处执行\n\t\t\ttimer = setTimeout(() =&gt; {\n\t\t\t\tflag = false\n\t\t\t\ttypeof func === 'function' &amp;&amp; func();\n\t\t\t}, wait);\n\t\t}\n\t\t\n\t}\n};\nexport default throttle</code></pre><p><br></p>"}}