{"sta":1,"data":{"subTitle":"防抖节流原理、区别以及应用","content":"<h3>1）防抖</h3><p><h4>原理：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。\n</h4><h4>适用场景：\n</h4>按钮提交场景：防止多次提交按钮，只执行最后提交的一次\n<br>搜索框联想场景：防止联想发送请求，只发送最后一次输入</p><pre><code>/** 防抖:\n * 应用场景：当用户进行了某个行为(例如点击)之后。不希望每次行为都会触发方法，而是行为做出后,一段时间内没有再次重复行为，\n * 才给用户响应\n * 实现原理 : 每次触发事件时设置一个延时调用方法，并且取消之前的延时调用方法。（每次触发事件时都取消之前的延时调用方法）\n *  @params fun 传入的防抖函数(callback) delay 等待时间\n *  */\nconst debounce = (fun, delay = 500) =&gt; {\n    let timer = null //设定一个定时器\n    return function (...args) {\n        clearTimeout(timer);\n        timer = setTimeout(() =&gt; {\n            fun.apply(this, args)\n        }, delay)\n    }\n}</code></pre><p><br></p><h3>2）节流</h3><h4>原理：</h4><p>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。\n<br><h4>适用场景\n</h4>拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动\n<br>缩放场景：监控浏览器resize</p><pre><code>/** 节流\n *  应用场景:用户进行高频事件触发(滚动)，但在限制在n秒内只会执行一次。\n *  实现原理: 每次触发时间的时候，判断当前是否存在等待执行的延时函数\n * @params fun 传入的防抖函数(callback) delay 等待时间\n * */\n\nconst throttle = (fun, delay = 1000) =&gt; {\n    let flag = true;\n    return function (...args) {\n        if (!flag) return;\n        flag = false\n        setTimeout(() =&gt; {\n            fun.apply(this, args)\n            flag = true\n        }, delay)\n    }\n}</code></pre><p><br></p><blockquote>区别:节流不管事件触发多频繁保证在一定时间内一定会执行一次函数。防抖是只在最后一次事件触发后才会执行一次函数</blockquote><p><br></p>"}}