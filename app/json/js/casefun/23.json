{"sta":1,"data":{"subTitle":"把原始list转换成树形结构","content":"<p></p><div><div><p>以下数据结构中，id 代表部门编号，name 是部门名称，parentId 是父部门编号，为 0 代表一级部门，现在要求实现一个 convert 方法，把原始 list 转换成树形结构，parentId 为多少就挂载在该 id 的属性 children 数组下，结构如下：</p>\n<p>// 原始 list 如下</p><pre><code>let list =[\n    {id:1,name:'部门A',parentId:0},\n    {id:2,name:'部门B',parentId:0},\n    {id:3,name:'部门C',parentId:1},\n    {id:4,name:'部门D',parentId:1},\n    {id:5,name:'部门E',parentId:2},\n    {id:6,name:'部门F',parentId:3},\n    {id:7,name:'部门G',parentId:2},\n    {id:8,name:'部门H',parentId:4}\n];\nconst result = convert(list, ...);</code></pre><p>// 转换后的结果如下</p><pre><code>let result = [\n    {\n      id: 1,\n      name: '部门A',\n      parentId: 0,\n      children: [\n        {\n          id: 3,\n          name: '部门C',\n          parentId: 1,\n          children: [\n            {\n              id: 6,\n              name: '部门F',\n              parentId: 3\n            }, {\n              id: 16,\n              name: '部门L',\n              parentId: 3\n            }\n          ]\n        },\n        {\n          id: 4,\n          name: '部门D',\n          parentId: 1,\n          children: [\n            {\n              id: 8,\n              name: '部门H',\n              parentId: 4\n            }\n          ]\n        }\n      ]\n    },\n  ···\n];</code></pre><p>实现了两种解法, 明显第二种更简单, 时间复杂度更低</p><p>方法一</p><pre><code>export {}\nlet list =[\n  {id:1,name:'部门A',parentId:0},\n  {id:2,name:'部门B',parentId:0},\n  {id:3,name:'部门C',parentId:1},\n  {id:4,name:'部门D',parentId:1},\n  {id:5,name:'部门E',parentId:2},\n  {id:6,name:'部门F',parentId:3},\n  {id:7,name:'部门G',parentId:2},\n  {id:8,name:'部门H',parentId:4}\n];\n\ninterface Dep {\n  id: number,\n  name: string,\n  parentId: number,\n  children?: Array&lt;Dep&gt;\n};\n\nfunction deepCompose(rawList: Array&lt;Dep&gt;, comList: Array&lt;Dep&gt;) {\n  const depList = rawList.slice();\n  while (depList.length &gt; 0) {\n    const node = depList.shift();\n\n    // append child nodes\n    const children = comList.filter(d =&gt; d.parentId === node.id);\n    if (children.length === 0) continue;\n\n    node.children = children;\n\n    deepCompose(children, comList);\n  }\n}\n\nfunction composeTree(depList: Dep[]) {\n  // first sort by parentId asc\n  depList.sort((a, b) =&gt; a.parentId - b.parentId);\n\n  // filter head\n  const [{ parentId }] = depList;\n  let rootDepList = depList.filter(dep =&gt; dep.parentId === parentId);\n  \n  deepCompose(rootDepList, depList);\n\n  return rootDepList;\n}\n\nconst depTree = composeTree(list);\nconsole.log(`${JSON.stringify(depTree)}`);</code></pre><p>方法二</p><pre><code>export {}\n\nlet list =[\n  {id:1,name:'部门A',parentId:0},\n  {id:2,name:'部门B',parentId:0},\n  {id:3,name:'部门C',parentId:1},\n  {id:4,name:'部门D',parentId:1},\n  {id:5,name:'部门E',parentId:2},\n  {id:6,name:'部门F',parentId:3},\n  {id:7,name:'部门G',parentId:2},\n  {id:8,name:'部门H',parentId:4}\n];\n\ninterface Dep {\n  id: number,\n  name: string,\n  parentId: number,\n  children?: Array&lt;Dep&gt;\n};\n\nfunction composeTree(depList: Array&lt;Dep&gt;) {\n  const depMap = new Map();\n  depList.forEach(d =&gt; depMap.set(d.id, d));\n\n  for (const d of depList) {\n    const parentId = d.parentId;\n    if (depMap.has(parentId)) {\n      const parentDep = depMap.get(parentId);\n      parentDep.children = parentDep.children || [];\n      parentDep.children.push(d);\n    }\n  }\n\n  // filter head list\n  depList.sort((a, b) =&gt; a.parentId - b.parentId);\n  const [{ parentId }] = depList;\n  const rootDepList = depList.filter(dep =&gt; dep.parentId === parentId);\n\n  return rootDepList;\n}\n\nconst res = composeTree(list);\nconsole.log(`${JSON.stringify(res)}`);</code></pre><p><br></p></div></div>"}}