{"sta":1,"data":{"subTitle":"Object.fromEntries","content":"<p>Object.fromEntries() 方法把键值对列表转换为一个对象。</p><p><h3>语法\n</h3><blockquote>Object.fromEntries(iterable);\n</blockquote><h3>参数\n</h3>iterable\n<br>类似 Array 、 Map 或者其它实现了可迭代协议的可迭代对象。\n<br><h3>返回值\n</h3>一个由该迭代对象条目提供对应属性的新对象。\n<br>\n<br><h3>描述\n</h3>Object.fromEntries() 方法接收一个键值对的列表参数，并返回一个带有这些键值对的新对象。这个迭代参数应该是一个能够实现@@iterator方法的的对象，返回一个迭代器对象。它生成一个具有两个元素的类数组的对象，第一个元素是将用作属性键的值，第二个元素是与该属性键关联的值。\n<br>\n<br>Object.fromEntries() 执行与 Object.entries 互逆的操作。<br><h3>Map 转化为 Object\n</h3>通过 Object.fromEntries， 可以将 Map 转换为 Object:</p><pre><code>const map = new Map([ ['foo', 'bar'], ['baz', 42] ]);\nconst obj = Object.fromEntries(map);\nconsole.log(obj); // { foo: \"bar\", baz: 42 }</code></pre><h3>Array 转化为 Object</h3><p>通过 Object.fromEntries， 可以将 Array 转换为 Object:</p><pre><code>const arr = [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ];\nconst obj = Object.fromEntries(arr);\nconsole.log(obj); // { 0: \"a\", 1: \"b\", 2: \"c\" }</code></pre><h3>对象转换</h3><p>Object.fromEntries 是与 Object.entries() 相反的方法，用 数组处理函数 可以像下面这样转换对象：</p><pre><code>const object1 = { a: 1, b: 2, c: 3 };\n\nconst object2 = Object.fromEntries(\n  Object.entries(object1)\n  .map(([ key, val ]) =&gt; [ key, val * 2 ])\n);\n\nconsole.log(object2);\n// { a: 2, b: 4, c: 6 }</code></pre><p><br></p>"}}