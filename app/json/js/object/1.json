{"sta":1,"data":{"subTitle":"Object.assign","content":"<p>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。</p><p><h3>语法\n</h3><blockquote>Object.assign(target, ...sources)\n</blockquote><h3>参数\n</h3>target\n<br>目标对象。\n<br>sources\n<br>源对象。\n<br><h3>返回值\n</h3>目标对象。\n<br>\n<br><h3>描述\n</h3>如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。\n<br>\n<br>Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。\n<br>\n<br>String类型和 Symbol 类型的属性都会被拷贝。\n<br>\n<br>在出现错误的情况下，例如，如果属性不可写，会引发TypeError，如果在引发错误之前添加了任何属性，则可以更改target对象。\n<br>\n<br><font color=\"#c24f4a\">注意，Object.assign 不会在那些source对象值为 null 或 undefined 的时候抛出错误。</font></p><h3>复制一个对象</h3><pre><code>const obj = { a: 1 };\nconst copy = Object.assign({}, obj);\nconsole.log(copy); // { a: 1 }</code></pre><h3>深拷贝问题</h3><p>针对深拷贝，需要使用其他办法，因为 Object.assign()拷贝的是（可枚举）属性值。\n<br>\n<br>假如源值是一个对象的引用，它仅仅会复制其引用值。</p><pre><code>const log = console.log;\n\nfunction test() {\n  'use strict';\n  let obj1 = { a: 0 , b: { c: 0}};\n  let obj2 = Object.assign({}, obj1);\n  log(JSON.stringify(obj2));\n  // { a: 0, b: { c: 0}}\n\n  obj1.a = 1;\n  log(JSON.stringify(obj1));\n  // { a: 1, b: { c: 0}}\n  log(JSON.stringify(obj2));\n  // { a: 0, b: { c: 0}}\n\n  obj2.a = 2;\n  log(JSON.stringify(obj1));\n  // { a: 1, b: { c: 0}}\n  log(JSON.stringify(obj2));\n  // { a: 2, b: { c: 0}}\n\n  obj2.b.c = 3;\n  log(JSON.stringify(obj1));\n  // { a: 1, b: { c: 3}}\n  log(JSON.stringify(obj2));\n  // { a: 2, b: { c: 3}}\n\n  // Deep Clone\n  obj1 = { a: 0 , b: { c: 0}};\n  let obj3 = JSON.parse(JSON.stringify(obj1));\n  obj1.a = 4;\n  obj1.b.c = 4;\n  log(JSON.stringify(obj3));\n  // { a: 0, b: { c: 0}}\n}\n\ntest();</code></pre><h3>合并对象</h3><pre><code>const o1 = { a: 1 };\nconst o2 = { b: 2 };\nconst o3 = { c: 3 };\n\nconst obj = Object.assign(o1, o2, o3);\nconsole.log(obj); // { a: 1, b: 2, c: 3 }\nconsole.log(o1);  // { a: 1, b: 2, c: 3 }, 注意目标对象自身也会改变。</code></pre><h3>合并具有相同属性的对象</h3><pre><code>const o1 = { a: 1, b: 1, c: 1 };\nconst o2 = { b: 2, c: 2 };\nconst o3 = { c: 3 };\n\nconst obj = Object.assign({}, o1, o2, o3);\nconsole.log(obj); // { a: 1, b: 2, c: 3 }</code></pre><p>属性被后续参数中具有相同属性的其他对象覆盖。</p><h3>拷贝 symbol 类型的属性</h3><pre><code>const o1 = { a: 1 };\nconst o2 = { [Symbol('foo')]: 2 };\n\nconst obj = Object.assign({}, o1, o2);\nconsole.log(obj); // { a : 1, [Symbol(\"foo\")]: 2 } (cf. bug 1207182 on Firefox)\nObject.getOwnPropertySymbols(obj); // [Symbol(foo)]</code></pre><h3>继承属性和不可枚举属性是不能拷贝的</h3><pre><code>const obj = Object.create({foo: 1}, { // foo 是个继承属性。\n    bar: {\n        value: 2  // bar 是个不可枚举属性。\n    },\n    baz: {\n        value: 3,\n        enumerable: true  // baz 是个自身可枚举属性。\n    }\n});\n\nconst copy = Object.assign({}, obj);\nconsole.log(copy); // { baz: 3 }</code></pre><h3>原始类型会被包装为对象</h3><pre><code>const v1 = \"abc\";\nconst v2 = true;\nconst v3 = 10;\nconst v4 = Symbol(\"foo\")\n\nconst obj = Object.assign({}, v1, null, v2, undefined, v3, v4);\n// 原始类型会被包装，null 和 undefined 会被忽略。\n// 注意，只有字符串的包装对象才可能有自身可枚举属性。\nconsole.log(obj); // { \"0\": \"a\", \"1\": \"b\", \"2\": \"c\" }</code></pre><h3>异常会打断后续拷贝任务</h3><pre><code>const target = Object.defineProperty({}, \"foo\", {\n    value: 1,\n    writable: false\n}); // target 的 foo 属性是个只读属性。\n\nObject.assign(target, {bar: 2}, {foo2: 3, foo: 3, foo3: 3}, {baz: 4});\n// TypeError: \"foo\" is read-only\n// 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。\n\nconsole.log(target.bar);  // 2，说明第一个源对象拷贝成功了。\nconsole.log(target.foo2); // 3，说明第二个源对象的第一个属性也拷贝成功了。\nconsole.log(target.foo);  // 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。\nconsole.log(target.foo3); // undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。\nconsole.log(target.baz);  // undefined，第三个源对象更是不会被拷贝到的。</code></pre><h3>拷贝访问器</h3><pre><code>const obj = {\n  foo: 1,\n  get bar() {\n    return 2;\n  }\n};\n\nlet copy = Object.assign({}, obj);\nconsole.log(copy); // { foo: 1, bar: 2 } copy.bar的值来自obj.bar的getter函数的返回值\n\n// 下面这个函数会拷贝所有自有属性的属性描述符\nfunction completeAssign(target, ...sources) {\n  sources.forEach(source =&gt; {\n    let descriptors = Object.keys(source).reduce((descriptors, key) =&gt; {\n      descriptors[key] = Object.getOwnPropertyDescriptor(source, key);\n      return descriptors;\n    }, {});\n\n    // Object.assign 默认也会拷贝可枚举的Symbols\n    Object.getOwnPropertySymbols(source).forEach(sym =&gt; {\n      let descriptor = Object.getOwnPropertyDescriptor(source, sym);\n      if (descriptor.enumerable) {\n        descriptors[sym] = descriptor;\n      }\n    });\n    Object.defineProperties(target, descriptors);\n  });\n  return target;\n}\n\ncopy = completeAssign({}, obj);\nconsole.log(copy);\n// { foo:1, get bar() { return 2 } }</code></pre><p><br></p>"}}