{"sta":1,"data":{"subTitle":"Object.freeze","content":"<p>Object.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。</p><pre><code>const obj = {\n  prop: 42\n};\n\nObject.freeze(obj);\n\nobj.prop = 33;\n// Throws an error in strict mode\n\nconsole.log(obj.prop);\n// expected output: 42</code></pre><p><h3>语法\n</h3><blockquote>Object.freeze(obj)\n</blockquote><h3>参数\n</h3>obj\n<br>要被冻结的对象。\n<br><h3>返回值\n</h3>被冻结的对象。\n<br>\n<br><h3>描述\n</h3>被冻结对象自身的所有属性都不可能以任何方式被修改。任何修改尝试都会失败，无论是静默地还是通过抛出TypeError异常（最常见但不仅限于strict mode）。\n<br>\n<br>数据属性的值不可更改，访问器属性（有getter和setter）也同样（但由于是函数调用，给人的错觉是还是可以修改这个属性）。如果一个属性的值是个对象，则这个对象中的属性是可以修改的，除非它也是个冻结对象。数组作为一种对象，被冻结，其元素不能被修改。没有数组元素可以被添加或移除。\n<br>\n<br>这个方法返回传递的对象，而不是创建一个被冻结的副本。\n<br>\n<br><h3>冻结对象</h3></p><pre><code>var obj = {\n  prop: function() {},\n  foo: 'bar'\n};\n\n// 新的属性会被添加, 已存在的属性可能\n// 会被修改或移除\nobj.foo = 'baz';\nobj.lumpy = 'woof';\ndelete obj.prop;\n\n// 作为参数传递的对象与返回的对象都被冻结\n// 所以不必保存返回的对象（因为两个对象全等）\nvar o = Object.freeze(obj);\n\no === obj; // true\nObject.isFrozen(obj); // === true\n\n// 现在任何改变都会失效\nobj.foo = 'quux'; // 静默地不做任何事\n// 静默地不添加此属性\nobj.quaxxor = 'the friendly duck';\n\n// 在严格模式，如此行为将抛出 TypeErrors\nfunction fail(){\n  'use strict';\n  obj.foo = 'sparky'; // throws a TypeError\n  delete obj.quaxxor; // 返回true，因为quaxxor属性从来未被添加\n  obj.sparky = 'arf'; // throws a TypeError\n}\n\nfail();\n\n// 试图通过 Object.defineProperty 更改属性\n// 下面两个语句都会抛出 TypeError.\nObject.defineProperty(obj, 'ohai', { value: 17 });\nObject.defineProperty(obj, 'foo', { value: 'eit' });\n\n// 也不能更改原型\n// 下面两个语句都会抛出 TypeError.\nObject.setPrototypeOf(obj, { x: 20 })\nobj.__proto__ = { x: 20 }</code></pre><div><h3>冻结数组</h3></div><pre><code>let a = [0];\nObject.freeze(a); // 现在数组不能被修改了.\n\na[0]=1; // fails silently\na.push(2); // fails silently\n\n// In strict mode such attempts will throw TypeErrors\nfunction fail() {\n  \"use strict\"\n  a[0] = 1;\n  a.push(2);\n}\n\nfail();</code></pre><p>被冻结的对象是不可变的。但也不总是这样。下例展示了冻结对象不是常量对象（浅冻结）。<br></p><pre><code>obj1 = {\n  internal: {}\n};\n\nObject.freeze(obj1);\nobj1.internal.a = 'aValue';\n\nobj1.internal.a // 'aValue'</code></pre><p>对于一个常量对象，整个引用图（直接和间接引用其他对象）只能引用不可变的冻结对象。冻结的对象被认为是不可变的，因为整个对象中的整个对象状态（对其他对象的值和引用）是固定的。注意，字符串，数字和布尔总是不可变的，而函数和数组是对象。<br></p><p>\n<br>要使对象不可变，需要递归冻结每个类型为对象的属性（深冻结）。当你知道对象在引用图中不包含任何 环 (循环引用)时，将根据你的设计逐个使用该模式，否则将触发无限循环。对 deepFreeze()  的增强将是具有接收路径（例如Array）参数的内部函数，以便当对象进入不变时，可以递归地调用 deepFreeze() 。你仍然有冻结不应冻结的对象的风险，例如[window]。\n<br>\n</p><pre><code>// 深冻结函数.\nfunction deepFreeze(obj) {\n\n  // 取回定义在obj上的属性名\n  var propNames = Object.getOwnPropertyNames(obj);\n\n  // 在冻结自身之前冻结属性\n  propNames.forEach(function(name) {\n    var prop = obj[name];\n\n    // 如果prop是个对象，冻结它\n    if (typeof prop == 'object' &amp;&amp; prop !== null)\n      deepFreeze(prop);\n  });\n\n  // 冻结自身(no-op if already frozen)\n  return Object.freeze(obj);\n}\n\nobj2 = {\n  internal: {}\n};\n\ndeepFreeze(obj2);\nobj2.internal.a = 'anotherValue';\nobj2.internal.a; // undefined</code></pre><h3>Notes</h3><p>在ES5中，如果这个方法的参数不是一个对象（一个原始值），那么它会导致 TypeError。在ES2015中，非对象参数将被视为要被冻结的普通对象，并被简单地返回。\n<br>\n</p><pre><code>&gt; Object.freeze(1)\nTypeError: 1 is not an object // ES5 code\n\n&gt; Object.freeze(1)\n1                             // ES2015 code</code></pre><h3>对比 Object.seal()</h3><p>用Object.seal()密封的对象可以改变它们现有的属性。使用Object.freeze() 冻结的对象中现有属性是不可变的。</p>"}}