{"sta":1,"data":{"subTitle":"Object.defineProperty","content":"<p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。\n\n备注：应当直接在 Object 构造器对象上调用此方法，而不是在任意一个 Object 类型的实例上调用。</p><pre><code>const object1 = {};\n\nObject.defineProperty(object1, 'property1', {\n  value: 42,\n  writable: false\n});\n\nobject1.property1 = 77;\n// throws an error in strict mode\n\nconsole.log(object1.property1);\n// expected output: 42</code></pre><p><h3>语法\n</h3><blockquote>Object.defineProperty(obj, prop, descriptor)\n</blockquote><h3>参数\n</h3>obj\n<br>要定义属性的对象。\n<br>prop\n<br>要定义或修改的属性的名称或 Symbol 。\n<br>descriptor\n<br>要定义或修改的属性描述符。\n<br><h3>返回值\n</h3>被传递给函数的对象。\n<br>\n<br>在ES6中，由于 Symbol类型的特殊性，用Symbol类型的值来做对象的key与常规的定义或修改不同，而Object.defineProperty 是定义key为Symbol的属性的方法之一。\n<br>\n<br><h3>描述\n</h3>该方法允许精确地添加或修改对象的属性。通过赋值操作添加的普通属性是可枚举的，在枚举对象属性时会被枚举到（for...in 或 Object.keys 方法），可以改变这些属性的值，也可以删除这些属性。这个方法允许修改默认的额外选项（或配置）。默认情况下，使用 Object.defineProperty() 添加的属性值是不可修改（immutable）的。\n<br>\n<br>对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个具有值的属性，该值可以是可写的，也可以是不可写的。存取描述符是由 getter 函数和 setter 函数所描述的属性。一个描述符只能是这两者其中之一；不能同时是两者。\n<br>\n<br>这两种描述符都是对象。它们共享以下可选键值（默认值是指在使用 Object.defineProperty() 定义属性时的默认值）：\n<br>\n<br><h4>configurable\n</h4>当且仅当该属性的 configurable 键值为 true 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。\n<br>默认为 false。\n<br><h4>enumerable\n</h4>当且仅当该属性的 enumerable 键值为 true 时，该属性才会出现在对象的枚举属性中。\n<br>默认为 false。\n<br>数据描述符还具有以下可选键值：<br><h4>value\n</h4>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。\n<br>默认为 undefined。\n<br><h4>writable\n</h4>当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value，才能被赋值运算符改变。\n<br>默认为 false。\n<br>存取描述符还具有以下可选键值：<br><h4>get\n</h4>属性的 getter 函数，如果没有 getter，则为 undefined。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。\n<br>默认为 undefined。\n<br><h4>set\n</h4>属性的 setter 函数，如果没有 setter，则为 undefined。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。\n<br>默认为 undefined。\n<br><h3>描述符默认值汇总\n</h3>拥有布尔值的键 configurable、enumerable 和 writable 的默认值都是 false。\n<br>属性值和函数的键 value、get 和 set 字段的默认值为 undefined。\n<br><h3>描述符可拥有的键值</h3></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;configurable&nbsp; &nbsp; &nbsp;enumerable&nbsp; &nbsp; &nbsp;value&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;writable&nbsp; &nbsp; &nbsp;get&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set\n<br>数据描述符\t可以&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 可以&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;可以&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 可以&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 不可以&nbsp; &nbsp; &nbsp; &nbsp; 不可以\n<br>存取描述符\t可以&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 可以&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 不可以&nbsp; &nbsp; &nbsp; &nbsp;不可以&nbsp; &nbsp; &nbsp; &nbsp;可以&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 可以</p><p>&nbsp;\n<br>如果一个描述符不具有 value、writable、get 和 set 中的任意一个键，那么它将被认为是一个数据描述符。如果一个描述符同时拥有 value 或 writable 和 get 或 set 键，则会产生一个异常。\n<br>\n<br>记住，这些选项不一定是自身属性，也要考虑继承来的属性。为了确认保留这些默认值，在设置之前，可能要冻结 Object.prototype，明确指定所有的选项，或者通过 Object.create(null) 将 __proto__ 属性指向 null。</p><pre><code>// 使用 __proto__\nvar obj = {};\nvar descriptor = Object.create(null); // 没有继承的属性\n// 默认没有 enumerable，没有 configurable，没有 writable\ndescriptor.value = 'static';\nObject.defineProperty(obj, 'key', descriptor);\n\n// 显式\nObject.defineProperty(obj, \"key\", {\n  enumerable: false,\n  configurable: false,\n  writable: false,\n  value: \"static\"\n});\n\n// 循环使用同一对象\nfunction withValue(value) {\n  var d = withValue.d || (\n    withValue.d = {\n      enumerable: false,\n      writable: false,\n      configurable: false,\n      value: null\n    }\n  );\n  d.value = value;\n  return d;\n}\n// ... 并且 ...\nObject.defineProperty(obj, \"key\", withValue(\"static\"));\n\n// 如果 freeze 可用, 防止后续代码添加或删除对象原型的属性\n// （value, get, set, enumerable, writable, configurable）\n(Object.freeze||Object)(Object.prototype);</code></pre><p><h3>创建属性\n</h3>如果对象中不存在指定的属性，Object.defineProperty() 会创建这个属性。当描述符中省略某些字段时，这些字段将使用它们的默认值。\n<br>\n</p><pre><code>var o = {}; // 创建一个新对象\n\n// 在对象中添加一个属性与数据描述符的示例\nObject.defineProperty(o, \"a\", {\n  value : 37,\n  writable : true,\n  enumerable : true,\n  configurable : true\n});\n\n// 对象 o 拥有了属性 a，值为 37\n\n// 在对象中添加一个设置了存取描述符属性的示例\nvar bValue = 38;\nObject.defineProperty(o, \"b\", {\n  // 使用了方法名称缩写（ES2015 特性）\n  // 下面两个缩写等价于：\n  // get : function() { return bValue; },\n  // set : function(newValue) { bValue = newValue; },\n  get() { return bValue; },\n  set(newValue) { bValue = newValue; },\n  enumerable : true,\n  configurable : true\n});\n\no.b; // 38\n// 对象 o 拥有了属性 b，值为 38\n// 现在，除非重新定义 o.b，o.b 的值总是与 bValue 相同\n\n// 数据描述符和存取描述符不能混合使用\nObject.defineProperty(o, \"conflict\", {\n  value: 0x9f91102,\n  get() { return 0xdeadbeef; }\n});\n// 抛出错误 TypeError: value appears only in data descriptors, get appears only in accessor descriptors</code></pre><h3>修改属性</h3><p>如果属性已经存在，Object.defineProperty()将尝试根据描述符中的值以及对象当前的配置来修改这个属性。如果旧描述符将其configurable 属性设置为false，则该属性被认为是“不可配置的”，并且没有属性可以被改变（除了单向改变 writable 为 false）。当属性不可配置时，不能在数据和访问器属性类型之间切换。\n<br>\n<br>当试图改变不可配置属性（除了 value 和 writable 属性之外）的值时，会抛出TypeError，除非当前值和新值相同。<br><h3>Writable 属性\n</h3>当 writable 属性设置为 false 时，该属性被称为“不可写的”。它不能被重新赋值。\n<br>\n</p><pre><code>var o = {}; // 创建一个新对象\n\nObject.defineProperty(o, 'a', {\n  value: 37,\n  writable: false\n});\n\nconsole.log(o.a); // logs 37\no.a = 25; // No error thrown\n// (it would throw in strict mode,\n// even if the value had been the same)\nconsole.log(o.a); // logs 37. The assignment didn't work.\n\n// strict mode\n(function() {\n  'use strict';\n  var o = {};\n  Object.defineProperty(o, 'b', {\n    value: 2,\n    writable: false\n  });\n  o.b = 3; // throws TypeError: \"b\" is read-only\n  return o.b; // returns 2 without the line above\n}());</code></pre><p>如示例所示，试图写入非可写属性不会改变它，也不会引发错误。<br></p><p><h3>Enumerable 属性\n</h3>enumerable 定义了对象的属性是否可以在 for...in 循环和 Object.keys() 中被枚举。\n<br>\n</p><pre><code>var o = {};\nObject.defineProperty(o, \"a\", { value : 1, enumerable: true });\nObject.defineProperty(o, \"b\", { value : 2, enumerable: false });\nObject.defineProperty(o, \"c\", { value : 3 }); // enumerable 默认为 false\no.d = 4; // 如果使用直接赋值的方式创建对象的属性，则 enumerable 为 true\nObject.defineProperty(o, Symbol.for('e'), {\n  value: 5,\n  enumerable: true\n});\nObject.defineProperty(o, Symbol.for('f'), {\n  value: 6,\n  enumerable: false\n});\n\nfor (var i in o) {\n  console.log(i);\n}\n// logs 'a' and 'd' (in undefined order)\n\nObject.keys(o); // ['a', 'd']\n\no.propertyIsEnumerable('a'); // true\no.propertyIsEnumerable('b'); // false\no.propertyIsEnumerable('c'); // false\no.propertyIsEnumerable('d'); // true\no.propertyIsEnumerable(Symbol.for('e')); // true\no.propertyIsEnumerable(Symbol.for('f')); // false\n\nvar p = { ...o }\np.a // 1\np.b // undefined\np.c // undefined\np.d // 4\np[Symbol.for('e')] // 5\np[Symbol.for('f')] // undefined</code></pre><h3>Configurable 属性</h3><p>configurable 特性表示对象的属性是否可以被删除，以及除 value 和 writable 特性外的其他特性是否可以被修改。</p><pre><code>var o = {};\nObject.defineProperty(o, 'a', {\n  get() { return 1; },\n  configurable: false\n});\n\nObject.defineProperty(o, 'a', {\n  configurable: true\n}); // throws a TypeError\nObject.defineProperty(o, 'a', {\n  enumerable: true\n}); // throws a TypeError\nObject.defineProperty(o, 'a', {\n  set() {}\n}); // throws a TypeError (set was undefined previously)\nObject.defineProperty(o, 'a', {\n  get() { return 1; }\n}); // throws a TypeError\n// (even though the new get does exactly the same thing)\nObject.defineProperty(o, 'a', {\n  value: 12\n}); // throws a TypeError // ('value' can be changed when 'configurable' is false but not in this case due to 'get' accessor)\n\nconsole.log(o.a); // logs 1\ndelete o.a; // Nothing happens\nconsole.log(o.a); // logs 1</code></pre><p>如果 o.a 的 configurable 属性为 true，则不会抛出任何错误，并且，最后，该属性会被删除。<br></p><p><h3>添加多个属性和默认值\n</h3>考虑特性被赋予的默认特性值非常重要，通常，使用点运算符和 Object.defineProperty() 为对象的属性赋值时，数据描述符中的属性默认值是不同的，如下例所示。</p><pre><code>var o = {};\n\no.a = 1;\n// 等同于：\nObject.defineProperty(o, \"a\", {\n  value: 1,\n  writable: true,\n  configurable: true,\n  enumerable: true\n});\n\n\n// 另一方面，\nObject.defineProperty(o, \"a\", { value : 1 });\n// 等同于：\nObject.defineProperty(o, \"a\", {\n  value: 1,\n  writable: false,\n  configurable: false,\n  enumerable: false\n});</code></pre><h3>自定义 Setters 和 Getters</h3><p>下面的例子展示了如何实现一个自存档对象。当设置temperature 属性时，archive 数组会收到日志条目。</p><pre><code>function Archiver() {\n  var temperature = null;\n  var archive = [];\n\n  Object.defineProperty(this, 'temperature', {\n    get: function() {\n      console.log('get!');\n      return temperature;\n    },\n    set: function(value) {\n      temperature = value;\n      archive.push({ val: temperature });\n    }\n  });\n\n  this.getArchive = function() { return archive; };\n}\n\nvar arc = new Archiver();\narc.temperature; // 'get!'\narc.temperature = 11;\narc.temperature = 13;\narc.getArchive(); // [{ val: 11 }, { val: 13 }]</code></pre><p>下面这个例子中，getter 总是会返回一个相同的值。<br></p><pre><code>var pattern = {\n    get: function () {\n        return 'I alway return this string,whatever you have assigned';\n    },\n    set: function () {\n        this.myname = 'this is my name string';\n    }\n};\n\n\nfunction TestDefineSetAndGet() {\n    Object.defineProperty(this, 'myproperty', pattern);\n}\n\n\nvar instance = new TestDefineSetAndGet();\ninstance.myproperty = 'test';\n\n// 'I alway return this string,whatever you have assigned'\nconsole.log(instance.myproperty);\n// 'this is my name string'\nconsole.log(instance.myname);</code></pre><h3>继承属性</h3><p>如果访问者的属性是被继承的，它的 get 和 set 方法会在子对象的属性被访问或者修改时被调用。如果这些方法用一个变量存值，该值会被所有对象共享。</p><pre><code>function myclass() {\n}\n\nvar value;\nObject.defineProperty(myclass.prototype, \"x\", {\n  get() {\n    return value;\n  },\n  set(x) {\n    value = x;\n  }\n});\n\nvar a = new myclass();\nvar b = new myclass();\na.x = 1;\nconsole.log(b.x); // 1</code></pre><p>这可以通过将值存储在另一个属性中解决。在 get 和 set 方法中，this 指向某个被访问和修改属性的对象<br></p><pre><code>function myclass() {\n}\n\nObject.defineProperty(myclass.prototype, \"x\", {\n  get() {\n    return this.stored_x;\n  },\n  set(x) {\n    this.stored_x = x;\n  }\n});\n\nvar a = new myclass();\nvar b = new myclass();\na.x = 1;\nconsole.log(b.x); // undefined</code></pre><p>不像访问者属性，值属性始终在对象自身上设置，而不是一个原型。然而，如果一个不可写的属性被继承，它仍然可以防止修改对象的属性。<br></p><pre><code>function myclass() {\n}\n\nmyclass.prototype.x = 1;\nObject.defineProperty(myclass.prototype, \"y\", {\n  writable: false,\n  value: 1\n});\n\nvar a = new myclass();\na.x = 2;\nconsole.log(a.x); // 2\nconsole.log(myclass.prototype.x); // 1\na.y = 2; // Ignored, throws in strict mode\nconsole.log(a.y); // 1\nconsole.log(myclass.prototype.y); // 1</code></pre><p><br></p>"}}