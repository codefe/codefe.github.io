{"sta":1,"data":{"subTitle":"Object.create","content":"<p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。</p><p><h3>语法\n</h3><blockquote>Object.create(proto，[propertiesObject])\n</blockquote><h3>参数\n</h3>proto\n<br>新创建对象的原型对象。\n<br>propertiesObject\n<br>可选。需要传入一个对象，该对象的属性类型参照Object.defineProperties()的第二个参数。如果该参数被指定且不为 undefined，该传入对象的自有可枚举属性(即其自身定义的属性，而不是其原型链上的枚举属性)将为新创建的对象添加指定的属性值和对应的属性描述符。\n<br><h3>返回值\n</h3>一个新对象，带着指定的原型对象和属性。\n<br>\n<br><h3>例外\n</h3>如果propertiesObject参数是 null 或非原始包装对象，则抛出一个 TypeError 异常。\n<br>\n<br><h3>例子\n</h3>用 Object.create实现类式继承\n<br>下面的例子演示了如何使用Object.create()来实现类式继承。这是一个所有版本JavaScript都支持的单继承。</p><pre><code>// Shape - 父类(superclass)\nfunction Shape() {\n  this.x = 0;\n  this.y = 0;\n}\n\n// 父类的方法\nShape.prototype.move = function(x, y) {\n  this.x += x;\n  this.y += y;\n  console.info('Shape moved.');\n};\n\n// Rectangle - 子类(subclass)\nfunction Rectangle() {\n  Shape.call(this); // call super constructor.\n}\n\n// 子类续承父类\nRectangle.prototype = Object.create(Shape.prototype);\nRectangle.prototype.constructor = Rectangle;\n\nvar rect = new Rectangle();\n\nconsole.log('Is rect an instance of Rectangle?',\n  rect instanceof Rectangle); // true\nconsole.log('Is rect an instance of Shape?',\n  rect instanceof Shape); // true\nrect.move(1, 1); // Outputs, 'Shape moved.'</code></pre><p>如果你希望能继承到多个对象，则可以使用混入的方式。</p><pre><code>function MyClass() {\n     SuperClass.call(this);\n     OtherSuperClass.call(this);\n}\n\n// 继承一个类\nMyClass.prototype = Object.create(SuperClass.prototype);\n// 混合其它\nObject.assign(MyClass.prototype, OtherSuperClass.prototype);\n// 重新指定constructor\nMyClass.prototype.constructor = MyClass;\n\nMyClass.prototype.myMethod = function() {\n     // do a thing\n};</code></pre><p>Object.assign 会把  OtherSuperClass原型上的函数拷贝到 MyClass原型上，使 MyClass 的所有实例都可用 OtherSuperClass 的方法。Object.assign 是在 ES2015 引入的，且可用 polyfilled。要支持旧浏览器的话，可用使用 jQuery.extend() 或者 _.assign()。</p><h3>使用 Object.create 的 propertyObject参数</h3><pre><code>var o;\n\n// 创建一个原型为null的空对象\no = Object.create(null);\n\n\no = {};\n// 以字面量方式创建的空对象就相当于:\no = Object.create(Object.prototype);\n\n\no = Object.create(Object.prototype, {\n  // foo会成为所创建对象的数据属性\n  foo: {\n    writable:true,\n    configurable:true,\n    value: \"hello\"\n  },\n  // bar会成为所创建对象的访问器属性\n  bar: {\n    configurable: false,\n    get: function() { return 10 },\n    set: function(value) {\n      console.log(\"Setting `o.bar` to\", value);\n    }\n  }\n});\n\n\nfunction Constructor(){}\no = new Constructor();\n// 上面的一句就相当于:\no = Object.create(Constructor.prototype);\n// 当然,如果在Constructor函数中有一些初始化代码,Object.create不能执行那些代码\n\n\n// 创建一个以另一个空对象为原型,且拥有一个属性p的对象\no = Object.create({}, { p: { value: 42 } })\n\n// 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:\no.p = 24\no.p\n//42\n\no.q = 12\nfor (var prop in o) {\n   console.log(prop)\n}\n//\"q\"\n\ndelete o.p\n//false\n\n//创建一个可写的,可枚举的,可配置的属性p\no2 = Object.create({}, {\n  p: {\n    value: 42,\n    writable: true,\n    enumerable: true,\n    configurable: true\n  }\n});</code></pre><p><br></p>"}}