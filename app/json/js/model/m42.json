{"sta":1,"data":{"subTitle":"单例模式实际场景-登录浮窗","content":"<h3>登录浮窗</h3><p>当我们单击登录按钮时，页面中会出现一个登录的浮窗，而这个登录浮窗是唯一的，无论单击多少次登录按钮，这个浮窗都只会被创建一次，那么这个登录浮窗就适合用单例模式来创建。</p><p><h4>传统做法\n</h4>传统做法在页面加载完成时，就创建好登录浮窗，当用户点击登录按钮时，显示登录浮窗，实现代码如下：</p><pre>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n    &lt;button id=\"loginBtn\"&gt;登录&lt;/button&gt;\n    &lt;script type=\"text/javascript\" src=\"index.js\"&gt;\n\n    &lt;/script&gt; \n&lt;/body&gt;  \n&lt;/html&gt;</pre><pre>var loginLayer = (() =&gt; {\n    let div = document.createElement('div')\n    div.innerHTML = '我是登录弹窗'\n    div.style.display = 'none'\n\n    document.body.appendChild(div)\n\n    return div\n})()\n\ndocument.getElementById('loginBtn').onclick = () =&gt; {\n    loginLayer.style.display = 'block'\n}</pre><p>上述代码有以下缺点：<br><blockquote>在无需登录的情况下，也会新增登录浮窗的 DOM 节点，浪费性能。\n</blockquote><p><br></p>现在优化一下，将代码改为，在用户点击登录按钮后，才新增登录浮窗的 DOM 节点。\n<br>\n<br>代码如下：</p><pre>var createLoginLayer = () =&gt; {\n    let div = document.createElement('div')\n    div.innerHTML = '我是登录弹窗'\n    div.style.display = 'none'\n\n    document.body.appendChild(div)\n\n    return div\n}\n\ndocument.getElementById('loginBtn').onclick = () =&gt; {\n    const loginLayer = createLoginLayer()\n    loginLayer.style.display = 'block'\n}</pre><p>上述代码也存在缺陷，具体如下：<br>每次点击登录按钮，都会创建一个登录浮窗，频繁的创建 DOM 节点更加浪费性能。\n<br>实际上，我们只需要创建一次登录浮窗。</p><p><h4>单例模式\n</h4>通过单例模式，重构上述代码。</p><pre>const createLoginLayer = () =&gt; {\n    const div = document.createElement('div')\n    div.innerHTML = '我是登录弹窗'\n    div.style.display = 'none'\n    console.log(123)\n\n    document.body.appendChild(div)\n    return div\n}\n\nconst createSingle = (function () {\n    var instance = {}\n    return function (fn) {\n        if (!instance[fn.name]) {\n            instance[fn.name] = fn.apply(this, arguments)\n        }\n        return instance[fn.name]\n    }\n})()\n\nconst createIframe = function () {\n    const iframe = document.createElement('iframe')\n    document.body.appendChild(iframe)\n    iframe.style.display = 'none'\n    return iframe\n}\n\nconst createSingleLoginLayer = createSingle(createLoginLayer)\nconst createSingleIframe = createSingle(createIframe)\n\ndocument.getElementById('loginBtn').onclick = () =&gt; {\n    const loginLayer = createSingleLoginLayer\n    const iframe = createSingleIframe\n    loginLayer.style.display = 'block'\n    iframe.style.display = 'block'\n}</pre><p>经过重构，代码做了以下优化：<br><blockquote>将创建实例对象 createLoginLayer / createIframe 的职责和管理单例对象 createSingle 的职责分离，符合单一职责原则；<br>\n通过闭包存储实例，并进行判断，不管点击登录按钮多少次，只创建一个登录浮窗实例；<br>\n易于扩展，当下次需要创建页面中唯一的 iframe / script 等其他标签时，可以直接复用该逻辑。\n</blockquote><h3>总结\n</h3>单例模式是一种简单但非常实用的模式，特别是惰性单例技术，在合适的时候才创建对象，并且只创建唯一的一个。更奇妙的是，创建对象和管理单例的职责被分布在两个不同的方法中，这两个方法组合起来才具有单例模式的威力。</p>"}}