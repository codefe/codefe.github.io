{"sta":1,"data":{"subTitle":"模拟场景-图片预加载","content":"<p>图片预加载时一种常见的技术，如果直接给img标签节点设置src属性，由于图片过大或网络不佳，图片的位置往往有一段时间时空白。<br></p><p><h3>1 传统做法</h3></p><pre>const myImage = (() =&gt; {\n    const imgNode = document.createElement('img')\n    document.body.appendChild(imgNode)\n\n    return {\n        setSrc: src =&gt; {\n            imgNode.src = src\n        }\n    }\n})()\n\nmyImage.setSrc('https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa98e67c4708449eb6894c7133d93774~tplv-k3u1fbpfcp-watermark.image')</pre><div><p><br></p></div><p>通过开发者工具把网速设置为 5kb/s时，会发现在很长一段时间内，图片位置是空白的。\n<br>\n<br><h3>2 虚拟代理\n</h3>下面用虚拟代理优化该功能，把加载图片的操作交给代理函数完成，在图片加载时，先用一张loading图占位，当图片加载成功后，再把它填充进img节点。\n<br>代码如下：\n<br>\n</p><pre>const myImage = (() =&gt; {\n    const imgNode = document.createElement('img')\n    document.body.appendChild(imgNode)\n\n    return {\n        setSrc: src =&gt; {\n            imgNode.src = src\n        }\n    }\n})()\n\nconst loadingSrc = '../../../../img/loading.gif'\nconst imgSrc = 'https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa98e67c4708449eb6894c7133d93774~tplv-k3u1fbpfcp-watermark.image'\n\nconst proxyImage = (function () {\n    const img = new Image()\n    img.onload = () =&gt; {\n        myImage.setSrc(img.src)\n    }\n\n    return {\n        setSrc: src =&gt; {\n            myImage.setSrc(loadingSrc)\n            img.src = src\n        }\n    }\n})()\n\nproxyImage.setSrc(imgSrc)</pre><p><br></p><p>上述代码有以下优点：\n<br>\n<br>1. 通过 proxyImage 控制了对 MyImage 的访问，在 MyImage 未加载成功之前，使用 loading 图占位；<br>2. 践行单一职责原则，给 img 节点设置 src 的函数 MyImage，预加载图片的函数 proxyImage，都只有一个职责；<br>3. 践行开放-封闭原则，给 img 节点设置 src 和预加载图片的功能，被隔离在两个对象里，它们可以各自变化不影响对方。&nbsp;<br></p><p><br></p><p><br></p>"}}