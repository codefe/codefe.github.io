{"sta":1,"data":{"subTitle":"策略模式实际场景","content":"<p>当我们计划国庆出去游玩时，在交通方式上，我们可以选择贵而快的飞机/价格中等但稍慢的动车/便宜但超级慢的火车，根据不同的人，选择对应的交通方式，且可以随意更换交通方式，这就是策略模式。</p><p><h3>实际场景1: 计算年终奖\n</h3><p>有一个计算员工年终奖的需求，假设，绩效为 S 的员工年终奖是 4 倍工资，绩效为 A 的员工年终奖是 3 倍工资，绩效为 B 的员工年终奖是 2 倍工资，下面我们来计算员工的年终奖。</p><h4>传统做法</h4></p><pre>var calculateBonus = function(performanceLevel, salary) {\n    if (performanceLevel === 'S') {\n        return salary * 4;\n    }\n    if (performanceLevel === 'A') {\n        return salary * 3;\n    }\n    if (performanceLevel === 'B') {\n        return salary * 2; \n    }\n};  \n\ncalculateBonus('B', 20000); // 输出：40000 \ncalculateBonus( 'S', 6000 ); // 输出：24000</pre><p>上述代码有以下缺点：<br><blockquote>使用 if-else 语句描述逻辑，代码庞大；<br>\n缺乏弹性，如果需要修改绩效 S 的奖金系数，必须修改 calculateBonus 函数，违反了开放-封闭原则；<br>\n无法再次复用，当其他地方需要用到这套逻辑，只能再复制一份。\n</blockquote><h4><br></h4><h4>策略模式做法\n</h4>使用策略模式改良后</p><pre>const strategies = {\n    S: salary =&gt; {\n        return salary * 4\n    },\n    A: salary =&gt; {\n        return salary * 3\n    },\n    B: salary =&gt; {\n        return salary * 2\n    }\n}\n\nconst calculateBonus = (level, salary) =&gt; {\n    return strtegies[level](salary)\n}\n\nconsole.log(calculateBonus('s', 20000))\nconsole.log(calculateBonus('a', 10000))</pre><p>可以看到上述代码做了以下改动：<br><blockquote>策略类 strategies 封装了具体的算法和计算过程（每种绩效的计算规则）；<br>\n环境类 calculateBonus 接受请求，把请求委托给策略类 strategies（员工的绩效和工资；<br>\n将算法的使用和算法的实现分离，代码清晰，职责分明；<br>\n消除大量的 if-else 语句。\n</blockquote><h4>小结\n</h4>策略模式使代码可读性更高，易于拓展更多的策略算法。当绩效系数改变，或者绩效等级增加，我们只需要为 strategies 调整或新增算法，符合开放-封闭原则。</p><p><br></p><h3>实际场景2: 表单校验</h3><p>当网页上的表单需要校验输入框/复选框等等规则时，如何去实现呢？\n<br>\n<br>现在有一个注册用户的表单需求，在提交表单之前，需要验证以下规则：<br><blockquote>用户名不能为空<br>\n密码长度不能少于6位<br>\n手机号码必须符合格式\n</blockquote><h4>传统做法\n</h4>使用 if-else 语句判断表单输入是否符合对应规则，如不符合，提示错误原因。</p><p>\n</p><pre>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;form id='registerForm' action=\"xxx\" method=\"post\"&gt;\n        用户名：&lt;input type=\"text\" name=\"userName\"&gt;\n        密码：&lt;input type=\"text\" name=\"password\"&gt;\n        手机号：&lt;input type=\"text\" name=\"phone\"&gt;\n        &lt;button&gt;提交&lt;/button&gt;\n    &lt;/form&gt;\n    &lt;script type=\"text/javascript\"&gt;\n        let registerForm = document.getElementById('registerForm')\n\n        registerForm.onsubmit = () =&gt; {\n                if (registerForm.userName.value) {\n                        alert('用户名不能为空')\n                        return false\n                }\n\n                if (registerForm.password.value.length &lt; 6) {\n                        alert('密码长度不能少于6')\n                        return false\n                }\n\n                if (!/(^1[3|5|8][0-9]$)/.test(registerForm.phone.value)) {\n                        alert('手机号码格式不正确')\n                        return false\n                }\n        }\n        &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre><p>\n</p><p>上述代码有以下缺点：<br><blockquote>onsubmit 函数庞大，包含大量 if-else 语句；<br>\nonsubmit 缺乏弹性，当有规则需要调整，或者需要新增规则时，需要改动 onsubmit 函数内部，违反开放-封闭原则；<br>\n算法复用性差，只能通过复制，复用到其他表单。\n</blockquote><h4>策略模式做法\n</h4>使用策略模式重构上述代码。</p><pre>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n \n    &lt;form action=\"http://xxx.com/register\" id=\"registerForm\" method=\"post\"&gt;\n  请输入用户名：\n        &lt;input type=\"text\" name=\"userName\" /&gt;\n  请输入密码：\n        &lt;input type=\"text\" name=\"password\" /&gt;\n  请输入手机号码：\n        &lt;input type=\"text\" name=\"phoneNumber\" /&gt;\n        &lt;button&gt;\n            提交\n        &lt;/button&gt;\n    &lt;/form&gt;\n    &lt;script type=\"text/javascript\" src=\"index.js\"&gt;\n\n    &lt;/script&gt; \n&lt;/body&gt;  \n&lt;/html&gt;</pre><pre>// 表单dom\nconst registerForm = document.getElementById('registerForm')\n\n// 表单规则\nconst rules = {\n    userName: [\n        {\n            strategy: 'isNonEmpty',\n            errorMsg: '用户名不能为空'\n        },\n        {\n            strategy: 'minLength:10',\n            errorMsg: '用户名长度不能小于10位'\n        }    \n    ],\n    password: [\n        {\n            strategy: 'minLength:6',\n            errorMsg: '密码长度不能小于6位'\n        }\n    ],\n    phoneNumber: [\n        {\n            strategy: 'isMobile',\n            errorMsg: '手机号码格式不正确'\n        }\n    ]\n}\n\n// 策略类\nvar strategies = { \n    isNonEmpty: function(value, errorMsg) { \n        if (value === '') { \n            return errorMsg; \n        } \n    },\n     minLength: function(value, errorMsg, length) { \n        console.log(length)\n        if (value.length &lt; length) { \n            return errorMsg; \n        } \n    },\n     isMobile: function(value, errorMsg) { \n        if (!/(^1[3|5|8][0-9]{9}$)/.test(value)) { \n            return errorMsg; \n        } \n    } \n};  \n\n// 验证类\nconst Validator = function () {\n    this.cache = []\n}\n\n// 添加验证方法\nValidator.prototype.add = function ({ dom, rules}) {\n    rules.forEach(rule =&gt; {\n        const { strategy, errorMsg } = rule\n        console.log(rule)\n        const [ strategyName, strategyCondition ] = strategy.split(':')\n        console.log(strategyName)\n        const { value } = dom\n        this.cache.push(strategies[strategyName].bind(dom, value, errorMsg, strategyCondition))\n    })\n}\n\n// 开始验证\nValidator.prototype.start = function () {\n    let errorMsg\n    this.cache.some(cacheItem =&gt; {\n            const _errorMsg = cacheItem()\n            if (_errorMsg) {\n                    errorMsg = _errorMsg\n                    return true\n            } else {\n                    return false\n            }\n    })\n\n    return errorMsg\n}\n\n// 验证函数\nconst validatorFn = () =&gt; {\n    const validator = new Validator()\n    console.log(validator.add)\n\n    Object.keys(rules).forEach(key =&gt; {\n        console.log(2222222, rules[key])\n        validator.add({\n            dom: registerForm[key],\n            rules: rules[key]\n        })\n    })\n\n    const errorMsg = validator.start()\n    return errorMsg\n}\n\n\n// 表单提交\nregisterForm.onsubmit = () =&gt; {\n    const errorMsg = validatorFn()\n    if (errorMsg) {\n        alert(errorMsg)\n        return false\n    }\n    return false\n}</pre><p>上述代码通过 strategies 定义规则算法，通过 Validator 定义验证算法，将规则和算法分离，我们仅仅通过配置的方式就可以完成表单的校验，这些校验规则也可以复用在程序的任何地方，还能作为插件的形式，方便的被移植到其他项目中。\n<br>\n<br><h3>总结\n</h3>策略模式是一种常用且有效的设计模式，通过上述例子，可以总结出策略模式的一些优点：\n<br>\n<br>策略模式利用组合/委托和多态等技术和思想，可以有效的避免多重条件选择语句；\n<br>策略模式提供了对开放-封闭原则的完美支持，将算法封装中独立的策略类中，使得它们易于切换/理解/扩展；\n<br>在策略模式中利用组合和委托来让 Context 拥有执行算法的能力，这也是继承的一种更轻便的代替方案。</p>"}}