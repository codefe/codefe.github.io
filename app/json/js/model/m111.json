{"sta":1,"data":{"subTitle":"实际场景-动态的为鸭子添加功能","content":"<p>有一个鸭子对象，它会发声 makeVoice， 会睡觉 sleep，但是因为它还太小，不会走路，代码如下：<br></p><pre>const duck =  {\n    makeVoice: () =&gt; {\n        console.log('我会嘎嘎嘎啦')\n    },\n    sleep: () =&gt; {\n        console.log('谁又不会睡觉呢')\n    },\n    init: function () {\n        this.makeVoice()\n        this.sleep()\n    }\n}\n\nduck.init()</pre><p><br></p><p>\n当它 3 个月大的时候，突然学会走路 walk 了，这个时候，怎么在代码中，为鸭子 duck 添加走路 walk 功能呢？大多数情况下，我们会选择直接修改鸭子 duck 方法，代码如下：\n<br>\n</p><pre>const duck =  {\n    makeVoice: () =&gt; {\n        console.log('我会嘎嘎嘎啦')\n    },\n    sleep: () =&gt; {\n        console.log('谁又不会睡觉呢')\n    },\n    walk: () =&gt; {\n        console.log('哈哈哈，我会走路啦')\n    },\n    init: function () {\n        this.makeVoice()\n        this.sleep()\n        this.walk()\n    }\n}\n\nduck.init()</pre><p><br></p><p>快乐的时光总是短暂的，鸭子越长越大，功能也越来越多。有一天，你请假出去玩，拜托朋友帮你照顾这只鸭子，不巧，鸭子要下蛋了，朋友需要帮鸭子添加一个下蛋的功能，这就有点麻烦了因为这是他第一次照顾这只鸭子，他担心如果直接在鸭子内部添加方法会影响到什么。\n<br>\n<br>于是他想到了一个好方法，不直接修改鸭子内部，而是通过一个外部函数，引用这个鸭子，并为外部函数添加下蛋的功能。\n<br>\n<br>代码如下：\n<br>\n</p><pre>const before = function (fn, beforeFn) {\n    return function () {\n        beforeFn.apply(this, arguments)\n        return fn.apply(this, arguments)\n    }\n}\n\nconst after = function (fn, afterFn) {\n    return function () {\n        const __ = fn.apply(this, arguments)\n        afterFn.apply(this, arguments)\n        return __\n    }\n}\n\nconst duck =  {\n    makeVoice: function () {\n        console.log('我会嘎嘎嘎啦')\n    },\n    sleep: function () {\n        console.log('谁又不会睡觉呢')\n    },\n    walk: function () {\n        console.log('哈哈哈，我会走路啦')\n    },\n    init: function () {\n        this.makeVoice()\n        this.sleep()\n        this.walk()\n    }\n}\n\nafter(duck.init, function egg () {\n    console.log('生蛋快乐～')\n}).apply(duck)</pre><p><br></p><p>这就是装饰器模式，动态的为鸭子添加功能，而不直接修改鸭子本身。</p><p><br></p>"}}