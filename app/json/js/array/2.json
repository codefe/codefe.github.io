{"sta":1,"data":{"subTitle":"Array.from","content":"<p>Array.from() 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</p><p><h3>语法\n</h3><blockquote>Array.from(arrayLike[, mapFn[, thisArg]])\n</blockquote><h3>参数\n</h3>arrayLike\n<br>想要转换成数组的伪数组对象或可迭代对象。\n<br>mapFn 可选\n<br>如果指定了该参数，新数组中的每个元素会执行该回调函数。\n<br>thisArg 可选\n<br>可选参数，执行回调函数 mapFn 时 this 对象。\n<br><h3>返回值\n</h3>一个新的数组实例。\n<br>\n<br><h3>描述\n</h3>Array.from() 可以通过以下方式来创建数组对象：\n<br>\n<br>伪数组对象（拥有一个 length 属性和若干索引属性的任意对象）\n<br>可迭代对象（可以获取对象中的元素,如 Map和 Set 等）</p><p>&nbsp;\n<br>Array.from() 方法有一个可选参数 mapFn，让你可以在最后生成的数组上再执行一次 map 方法后再返回。也就是说 Array.from(obj, mapFn, thisArg) 就相当于 Array.from(obj).map(mapFn, thisArg), 除非创建的不是可用的中间数组。 这对一些数组的子类,如 typed arrays 来说很重要, 因为中间数组的值在调用 map() 时需要是适当的类型。\n<br>\n<br>from() 的 length 属性为 1 ，即 Array.from.length === 1。\n<br>\n<br>在 ES2015 中， Class 语法允许我们为内置类型（比如 Array）和自定义类新建子类（比如叫 SubArray）。这些子类也会继承父类的静态方法，比如 SubArray.from()，调用该方法后会返回子类 SubArray 的一个实例，而不是 Array 的实例。</p><h3>从 String 生成数组</h3><pre><code><p><span style=\"background-color: rgb(241, 241, 241); white-space: pre-wrap;\">Array.from('foo');</span></p>// [ \"f\", \"o\", \"o\" ]</code></pre><h3>从 Set 生成数组</h3><pre><code>const set = new Set(['foo', 'bar', 'baz', 'foo']);\nArray.from(set);\n// [ \"foo\", \"bar\", \"baz\" ]</code></pre><h3>从 Map 生成数组</h3><p>&nbsp;<span style=\"background-color: rgb(241, 241, 241); white-space: pre-wrap;\">const map = new Map([[1, 2], [2, 4], [4, 8]]);</span></p><pre><code>Array.from(map);\n// [[1, 2], [2, 4], [4, 8]]\n\nconst mapper = new Map([['1', 'a'], ['2', 'b']]);\nArray.from(mapper.values());\n// ['a', 'b'];\n\nArray.from(mapper.keys());\n// ['1', '2'];</code></pre><h3>从类数组对象（arguments）生成数组</h3><pre><code>function f() {\n  return Array.from(arguments);\n}\n\nf(1, 2, 3);\n\n// [ 1, 2, 3 ]</code></pre><h3>在 Array.from 中使用箭头函数</h3><pre><code>// Using an arrow function as the map function to\n// manipulate the elements\nArray.from([1, 2, 3], x =&gt; x + x);\n// [2, 4, 6]\n\n\n// Generate a sequence of numbers\n// Since the array is initialized with `undefined` on each position,\n// the value of `v` below will be `undefined`\nArray.from({length: 5}, (v, i) =&gt; i);\n// [0, 1, 2, 3, 4]</code></pre><h3>序列生成器(指定范围)</h3><pre><code>// Sequence generator function (commonly referred to as \"range\", e.g. Clojure, PHP etc)\nconst range = (start, stop, step) =&gt; Array.from({ length: (stop - start) / step + 1}, (_, i) =&gt; start + (i * step));\n\n// Generate numbers range 0..4\nrange(0, 4, 1);\n// [0, 1, 2, 3, 4]\n\n// Generate numbers range 1..10 with step of 2\nrange(1, 10, 2);\n// [1, 3, 5, 7, 9]\n\n// Generate the alphabet using Array.from making use of it being ordered as a sequence\nrange('A'.charCodeAt(0), 'Z'.charCodeAt(0), 1).map(x =&gt; String.fromCharCode(x));\n// [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"]</code></pre><h3>数组去重合并</h3><pre><code>function combine(){\n    let arr = [].concat.apply([], arguments);  //没有去重复的新数组\n    return Array.from(new Set(arr));\n}\n\nvar m = [1, 2, 2], n = [2,3,3];\nconsole.log(combine(m,n));                     // [1, 2, 3]</code></pre><p><br></p><p><br></p>"}}