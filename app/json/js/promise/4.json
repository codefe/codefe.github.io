{"sta":1,"data":{"subTitle":"Promise.prototype.then","content":"<p>then() 方法返回一个 Promise。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。</p><pre><code>const promise1 = new Promise((resolve, reject) =&gt; {\n  resolve('Success!');\n});\n\npromise1.then((value) =&gt; {\n  console.log(value);\n  // expected output: \"Success!\"\n});</code></pre><p>注意：如果忽略针对某个状态的回调函数参数，或者提供非函数 (nonfunction) 参数，那么 then 方法将会丢失关于该状态的回调函数信息，但是并不会产生错误。如果调用 then 的 Promise 的状态（fulfillment 或 rejection）发生改变，但是 then 中并没有关于这种状态的回调函数，那么 then 将创建一个没有经过回调函数处理的新 Promise 对象，这个新 Promise 只是简单地接受调用这个 then 的原 Promise 的终态作为它的终态。\n<br>\n<br><h3>语法</h3></p><pre><code>p.then(onFulfilled[, onRejected]);\n\np.then(value =&gt; {\n  // fulfillment\n}, reason =&gt; {\n  // rejection\n});</code></pre><div><p><h3>参数\n</h3><h4>onFulfilled 可选\n</h4>当 Promise 变成接受状态（fulfilled）时调用的函数。该函数有一个参数，即接受的最终结果（the fulfillment  value）。如果该参数不是函数，则会在内部被替换为 (x) =&gt; x，即原样返回 promise 最终结果的函数\n<br><h4>onRejected 可选\n</h4>当 Promise 变成拒绝状态（rejected）时调用的函数。该函数有一个参数，即拒绝的原因（rejection reason）。  如果该参数不是函数，则会在内部被替换为一个 \"Thrower\" 函数 (it throws an error it received as argument)。\n<br><h3>返回值\n</h3>当一个 Promise 完成（fulfilled）或者失败（rejected）时，返回函数将被异步调用（由当前的线程循环来调度完成）。具体的返回值依据以下规则返回。如果 then 中的回调函数：\n<br>\n<br>返回了一个值，那么 then 返回的 Promise 将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。\n<br>没有返回任何值，那么 then 返回的 Promise 将会成为接受状态，并且该接受状态的回调函数的参数值为 undefined。\n<br>抛出一个错误，那么 then 返回的 Promise 将会成为拒绝状态，并且将抛出的错误作为拒绝状态的回调函数的参数值。\n<br>返回一个已经是接受状态的 Promise，那么 then 返回的 Promise 也会成为接受状态，并且将那个 Promise 的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。\n<br>返回一个已经是拒绝状态的 Promise，那么 then 返回的 Promise 也会成为拒绝状态，并且将那个 Promise 的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。\n<br>返回一个未定状态（pending）的 Promise，那么 then 返回 Promise 的状态也是未定的，并且它的终态与那个 Promise 的终态相同；同时，它变为终态时调用的回调函数参数与那个 Promise 变为终态时的回调函数的参数是相同的。\n<br>下面是一个演示 then 方法的同步性的例子。</p><pre><code>// using a resolved promise, the 'then' block will be triggered instantly,\n// but its handlers will be triggered asynchronously as demonstrated by the console.logs\nconst resolvedProm = Promise.resolve(33);\n\nlet thenProm = resolvedProm.then(value =&gt; {\n    console.log(\"this gets called after the end of the main stack. the value received and returned is: \" + value);\n    return value;\n});\n// instantly logging the value of thenProm\nconsole.log(thenProm);\n\n// using setTimeout we can postpone the execution of a function to the moment the stack is empty\nsetTimeout(() =&gt; {\n    console.log(thenProm);\n});\n\n\n// 上面的代码会依次返回：\n// Promise {[[PromiseStatus]]: \"pending\", [[PromiseValue]]: undefined}\n// \"this gets called after the end of the main stack. the value received and returned is: 33\"\n// Promise {[[PromiseStatus]]: \"resolved\", [[PromiseValue]]: 33}</code></pre><p><h3>描述\n</h3>由于 then 和 Promise.prototype.catch() 方法都会返回 promise，它们可以被链式调用——这同时也是一种被称为复合（ composition） 的操作。\n<br>\n<br><h3>使用 then 方法</h3></p><pre><code>var p1 = new Promise((resolve, reject) =&gt; {\n  resolve('成功！');\n  // or\n  // reject(new Error(\"出错了！\"));\n});\n\np1.then(value =&gt; {\n  console.log(value); // 成功！\n}, reason =&gt; {\n  console.error(reason); // 出错了！\n});</code></pre><p><h3>链式调用\n</h3>then 方法返回一个 Promise 对象，其允许方法链。\n<br>\n<br>你可以传递一个匿名函数给 then，并且，如果它返回一个 Promise，一个等价的 Promise 将暴露给后续的方法链。下面的代码片段使用 setTimout 函数来模拟异步代码操作。</p><pre><code>Promise.resolve(\"foo\")\n  // 1. 接收 \"foo\" 并与 \"bar\" 拼接，并将其结果做为下一个 resolve 返回。\n  .then(function(string) {\n    return new Promise(function(resolve, reject) {\n      setTimeout(function() {\n        string += 'bar';\n        resolve(string);\n      }, 1);\n    });\n  })\n  // 2. 接收 \"foobar\", 放入一个异步函数中处理该字符串\n  // 并将其打印到控制台中, 但是不将处理后的字符串返回到下一个。\n  .then(function(string) {\n    setTimeout(function() {\n      string += 'baz';\n      console.log(string);\n    }, 1)\n    return string;\n  })\n  // 3. 打印本节中代码将如何运行的帮助消息，\n  // 字符串实际上是由上一个回调函数之前的那块异步代码处理的。\n  .then(function(string) {\n    console.log(\"Last Then:  oops... didn't bother to instantiate and return \" +\n                \"a promise in the prior then so the sequence may be a bit \" +\n                \"surprising\");\n\n    // 注意 `string` 这时不会存在 'baz'。\n    // 因为这是发生在我们通过setTimeout模拟的异步函数中。\n    console.log(string);\n  });\n\n// logs, in order:\n// Last Then: oops... didn't bother to instantiate and return a promise in the prior then so the sequence may be a bit surprising\n// foobar\n// foobarbaz</code></pre><p>当一个值只是从一个 then 内部返回时，它将等价地返回 Promise.resolve(&lt;由被调用的处理程序返回的值&gt;)。</p><pre><code>var p2 = new Promise(function(resolve, reject) {\n  resolve(1);\n});\n\np2.then(function(value) {\n  console.log(value); // 1\n  return value + 1;\n}).then(function(value) {\n  console.log(value + ' - A synchronous value works');\n});\n\np2.then(function(value) {\n  console.log(value); // 1\n});</code></pre><p>如果函数抛出错误或返回一个拒绝的Promise，则 then 将返回一个拒绝的Promise。</p><pre><code>Promise.resolve()\n  .then(() =&gt; {\n    // 使 .then() 返回一个 rejected promise\n    throw new Error('Oh no!');\n  })\n  .then(() =&gt; {\n    console.log('Not called.');\n  }, error =&gt; {\n    console.error('onRejected function called: ' + error.message);\n  });</code></pre><p>在其他情况下，一个 resolving Promise 会被返回。在下面的例子里，第一个 then() 会返回一个用 resolving Promise 包装的 42，即使之前的 Promise 是 rejected 的。</p><pre><code>Promise.reject()\n  .then(() =&gt; 99, () =&gt; 42) // onRejected returns 42 which is wrapped in a resolving Promise\n  .then(solution =&gt; console.log('Resolved with ' + solution)); // Resolved with 42</code></pre><p>实际上，捕获 rejected promise 的需求经常大于使用 then 的两种情况语法，比如下面这样的：</p><pre><code>Promise.resolve()\n  .then(() =&gt; {\n    // 使 .then() 返回一个 rejected promise\n    throw new Error('Oh no!');\n  })\n  .catch(error =&gt; {\n    console.error('onRejected function called: ' + error.message);\n  })\n  .then(() =&gt; {\n    console.log(\"I am always called even if the prior then's promise rejects\");\n  });</code></pre><p>你也可以在另一个顶层函数上使用链式去实现基于 Promise API 的函数。</p><pre><code>function fetch_current_data() {\n  // fetch() API 返回了一个 Promise.\n  // 这个函数提供了类似的API，\n  // 这个函数除了实现 Promise，它还能够完成更多的工作。\n  return fetch('current-data.json').then(response =&gt; {\n    if (response.headers.get('content-type') != 'application/json') {\n      throw new TypeError();\n    }\n    var j = response.json();\n    // maybe do something with j\n    return j; // fulfillment value given to user of\n              // fetch_current_data().then()\n  });\n}</code></pre><p>如果 onFulfilled 返回了一个 promise，then 的返回值就会被 Promise resolved 或者 rejected。</p><pre><code>function resolveLater(resolve, reject) {\n  setTimeout(function() {\n    resolve(10);\n  }, 1000);\n}\nfunction rejectLater(resolve, reject) {\n  setTimeout(function() {\n    reject(new Error('Error'));\n  }, 1000);\n}\n\nvar p1 = Promise.resolve('foo');\nvar p2 = p1.then(function() {\n  // Return promise here, that will be resolved to 10 after 1 second\n  return new Promise(resolveLater);\n});\np2.then(function(v) {\n  console.log('resolved', v);  // \"resolved\", 10\n}, function(e) {\n  // not called\n  console.error('rejected', e);\n});\n\nvar p3 = p1.then(function() {\n  // Return promise here, that will be rejected with 'Error' after 1 second\n  return new Promise(rejectLater);\n});\np3.then(function(v) {\n  // not called\n  console.log('resolved', v);\n}, function(e) {\n  console.error('rejected', e); // \"rejected\", 'Error'\n});</code></pre><p><h3>基于 promise 的 window.setImmediate polyfill\n</h3>Using a Function.prototype.bind() Reflect.apply (Reflect.apply()) method to create a (non-cancellable) setImmediate-style function.</p><pre><code>const nextTick = (() =&gt; {\n  const noop = () =&gt; {}; // literally\n  const nextTickPromise = () =&gt; Promise.resolve().then(noop);\n\n  const rfab = Reflect.apply.bind; // (thisArg, fn, thisArg, [...args])\n  const nextTick = (fn, ...args) =&gt; (\n    fn !== undefined\n    ? Promise.resolve(args).then(rfab(null, fn, null))\n    : nextTickPromise(),\n    undefined\n  );\n  nextTick.ntp = nextTickPromise;\n\n  return nextTick;\n})();</code></pre><p><br></p></div>"}}