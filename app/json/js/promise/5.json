{"sta":1,"data":{"subTitle":" Promise.prototype.catch","content":"<p>catch() 方法返回一个Promise，并且处理拒绝的情况。它的行为与调用Promise.prototype.then(undefined, onRejected) 相同。 (事实上, calling obj.catch(onRejected) 内部calls obj.then(undefined, onRejected)).</p><p><h3>语法\n</h3><blockquote>p.catch(onRejected);\n<br>p.catch(function(reason) {<br>\n   // 拒绝<br>\n});\n</blockquote>\n<h3>参数\n</h3>onRejected\n<br>当Promise 被rejected时,被调用的一个Function。 该函数拥有一个参数：\n<br>reason    rejection 的原因。\n<br> 如果 onRejected 抛出一个错误或返回一个本身失败的 Promise ，  通过 catch() 返回的Promise 被rejected；否则，它将显示为成功（resolved）。 \n<br>\n<br><h3>返回值\n</h3>一个Promise.\n<br>\n<br><h3>描述\n</h3>catch 方法可以用于您的promise组合中的错误处理。\n<br>\n<br>Internally calls Promise.prototype.then on the object upon which is called, passing the parameters undefined and the onRejected handler received; then returns the value of that call (which is a Promise).\n<br>\n<br>使用链式语句的 catch方法</p><pre><code>var p1 = new Promise(function(resolve, reject) {\n  resolve('Success');\n});\n\np1.then(function(value) {\n  console.log(value); // \"Success!\"\n  throw 'oh, no!';\n}).catch(function(e) {\n  console.log(e); // \"oh, no!\"\n}).then(function(){\n  console.log('after a catch the chain is restored');\n}, function () {\n  console.log('Not fired due to the catch');\n});\n\n// 以下行为与上述相同\np1.then(function(value) {\n  console.log(value); // \"Success!\"\n  return Promise.reject('oh, no!');\n}).catch(function(e) {\n  console.log(e); // \"oh, no!\"\n}).then(function(){\n  console.log('after a catch the chain is restored');\n}, function () {\n  console.log('Not fired due to the catch');\n});</code></pre><h3>捕获抛出的错误</h3><pre><code>// 抛出一个错误，大多数时候将调用catch方法\nvar p1 = new Promise(function(resolve, reject) {\n  throw 'Uh-oh!';\n});\n\np1.catch(function(e) {\n  console.log(e); // \"Uh-oh!\"\n});\n\n// 在异步函数中抛出的错误不会被catch捕获到\nvar p2 = new Promise(function(resolve, reject) {\n  setTimeout(function() {\n    throw 'Uncaught Exception!';\n  }, 1000);\n});\n\np2.catch(function(e) {\n  console.log(e); // 不会执行\n});\n\n// 在resolve()后面抛出的错误会被忽略\nvar p3 = new Promise(function(resolve, reject) {\n  resolve();\n  throw 'Silenced Exception!';\n});\n\np3.catch(function(e) {\n   console.log(e); // 不会执行\n});</code></pre><h3>如果已决议</h3><pre><code>//创建一个新的 Promise ，且已决议\nvar p1 = Promise.resolve(\"calling next\");\n\nvar p2 = p1.catch(function (reason) {\n    //这个方法永远不会调用\n    console.log(\"catch p1!\");\n    console.log(reason);\n});\n\np2.then(function (value) {\n    console.log(\"next promise's onFulfilled\"); /* next promise's onFulfilled */\n    console.log(value); /* calling next */\n}, function (reason) {\n    console.log(\"next promise's onRejected\");\n    console.log(reason);\n});</code></pre><p><br></p>"}}