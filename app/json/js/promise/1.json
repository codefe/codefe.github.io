{"sta":1,"data":{"subTitle":"Promise.all","content":"<p>Promise.all() 方法接收一个promise的iterable类型（注：Array，Map，Set都属于ES6的iterable类型）的输入，并且只返回一个Promise实例， 那个输入的所有promise的resolve回调的结果是一个数组。这个Promise的resolve回调执行是在所有输入的promise的resolve回调都结束，或者输入的iterable里没有promise了的时候。它的reject回调执行是，只要任何一个输入的promise的reject回调执行或者输入不合法的promise就会立即抛出错误，并且reject的是第一个抛出的错误信息。</p><pre><code>const promise1 = Promise.resolve(3);\nconst promise2 = 42;\nconst promise3 = new Promise((resolve, reject) =&gt; {\n  setTimeout(resolve, 100, 'foo');\n});\n\nPromise.all([promise1, promise2, promise3]).then((values) =&gt; {\n  console.log(values);\n});\n// expected output: Array [3, 42, \"foo\"]</code></pre><p><h3>语法\n</h3>Promise.all(iterable);\n<br><h3>参数\n</h3>iterable\n<br>一个可迭代对象，如 Array 或 String。\n<br><h3>返回值\n</h3>如果传入的参数是一个空的可迭代对象，则返回一个已完成（already resolved）状态的 Promise。\n<br>如果传入的参数不包含任何 promise，则返回一个异步完成（asynchronously resolved） Promise。注意：Google Chrome 58 在这种情况下返回一个已完成（already resolved）状态的 Promise。\n<br>其它情况下返回一个处理中（pending）的Promise。这个返回的 promise 之后会在所有的 promise 都完成或有一个 promise 失败时异步地变为完成或失败。 见下方关于“Promise.all 的异步或同步”示例。返回值将会按照参数内的 promise 顺序排列，而不是由调用 promise 的完成顺序决定。\n<br><h3>说明\n</h3>此方法在集合多个 promise 的返回结果时很有用。\n<br>\n<br>完成（Fulfillment）：\n<br>如果传入的可迭代对象为空，Promise.all 会同步地返回一个已完成（resolved）状态的promise。\n<br>如果所有传入的 promise 都变为完成状态，或者传入的可迭代对象内没有 promise，Promise.all 返回的 promise 异步地变为完成。\n<br>在任何情况下，Promise.all 返回的 promise 的完成状态的结果都是一个数组，它包含所有的传入迭代参数对象的值（也包括非 promise 值）。\n<br>\n<br>失败/拒绝（Rejection）：\n<br>如果传入的 promise 中有一个失败（rejected），Promise.all 异步地将失败的那个结果给失败状态的回调函数，而不管其它 promise 是否完成。\n<br><h3>Promise.all 的使用</h3></p><p>Promise.all 等待所有都完成（或第一个失败）。\n<br>\n</p><pre><code>var p1 = Promise.resolve(3);\nvar p2 = 1337;\nvar p3 = new Promise((resolve, reject) =&gt; {\n  setTimeout(resolve, 100, 'foo');\n});\n\nPromise.all([p1, p2, p3]).then(values =&gt; {\n  console.log(values); // [3, 1337, \"foo\"]\n});</code></pre><p>如果参数中包含非 promise 值，这些值将被忽略，但仍然会被放在返回数组中（如果 promise 完成的话）：<br></p><pre><code>// this will be counted as if the iterable passed is empty, so it gets fulfilled\nvar p = Promise.all([1,2,3]);\n// this will be counted as if the iterable passed contains only the resolved promise with value \"444\", so it gets fulfilled\nvar p2 = Promise.all([1,2,3, Promise.resolve(444)]);\n// this will be counted as if the iterable passed contains only the rejected promise with value \"555\", so it gets rejected\nvar p3 = Promise.all([1,2,3, Promise.reject(555)]);\n\n// using setTimeout we can execute code after the stack is empty\nsetTimeout(function(){\n    console.log(p);\n    console.log(p2);\n    console.log(p3);\n});\n\n// logs\n// Promise { &lt;state&gt;: \"fulfilled\", &lt;value&gt;: Array[3] }\n// Promise { &lt;state&gt;: \"fulfilled\", &lt;value&gt;: Array[4] }\n// Promise { &lt;state&gt;: \"rejected\", &lt;reason&gt;: 555 }</code></pre><h3>Promise.all 的异步和同步</h3><p>下面的例子中演示了 Promise.all 的异步性（如果传入的可迭代对象是空的，就是同步）：\n<br>\n</p><pre><code>// we are passing as argument an array of promises that are already resolved,\n// to trigger Promise.all as soon as possible\nvar resolvedPromisesArray = [Promise.resolve(33), Promise.resolve(44)];\n\nvar p = Promise.all(resolvedPromisesArray);\n// immediately logging the value of p\nconsole.log(p);\n\n// using setTimeout we can execute code after the stack is empty\nsetTimeout(function(){\n    console.log('the stack is now empty');\n    console.log(p);\n});\n\n// logs, in order:\n// Promise { &lt;state&gt;: \"pending\" }\n// the stack is now empty\n// Promise { &lt;state&gt;: \"fulfilled\", &lt;value&gt;: Array[2] }</code></pre><p>如果 Promise.all 失败，也是一样的：<br></p><pre><code>var mixedPromisesArray = [Promise.resolve(33), Promise.reject(44)];\nvar p = Promise.all(mixedPromisesArray);\nconsole.log(p);\nsetTimeout(function(){\n    console.log('the stack is now empty');\n    console.log(p);\n});\n\n// logs\n// Promise { &lt;state&gt;: \"pending\" }\n// the stack is now empty\n// Promise { &lt;state&gt;: \"rejected\", &lt;reason&gt;: 44 }</code></pre><p>但是，Promise.all 当且仅当传入的可迭代对象为空时为同步：<br></p><pre><code>var p = Promise.all([]); // will be immediately resolved\nvar p2 = Promise.all([1337, \"hi\"]); // non-promise values will be ignored, but the evaluation will be done asynchronously\nconsole.log(p);\nconsole.log(p2)\nsetTimeout(function(){\n    console.log('the stack is now empty');\n    console.log(p2);\n});\n\n// logs\n// Promise { &lt;state&gt;: \"fulfilled\", &lt;value&gt;: Array[0] }\n// Promise { &lt;state&gt;: \"pending\" }\n// the stack is now empty\n// Promise { &lt;state&gt;: \"fulfilled\", &lt;value&gt;: Array[2] }</code></pre><h3>Promise.all 的快速返回失败行为</h3><p>Promise.all 在任意一个传入的 promise 失败时返回失败。例如，如果你传入的 promise中，有四个 promise 在一定的时间之后调用成功函数，有一个立即调用失败函数，那么 Promise.all 将立即变为失败。&nbsp;<br></p><pre><code>var p1 = new Promise((resolve, reject) =&gt; {\n  setTimeout(resolve, 1000, 'one');\n});\nvar p2 = new Promise((resolve, reject) =&gt; {\n  setTimeout(resolve, 2000, 'two');\n});\nvar p3 = new Promise((resolve, reject) =&gt; {\n  setTimeout(resolve, 3000, 'three');\n});\nvar p4 = new Promise((resolve, reject) =&gt; {\n  setTimeout(resolve, 4000, 'four');\n});\nvar p5 = new Promise((resolve, reject) =&gt; {\n  reject('reject');\n});\n\nPromise.all([p1, p2, p3, p4, p5]).then(values =&gt; {\n  console.log(values);\n}, reason =&gt; {\n  console.log(reason)\n});\n\n//From console:\n//\"reject\"\n\n//You can also use .catch\nPromise.all([p1, p2, p3, p4, p5]).then(values =&gt; {\n  console.log(values);\n}).catch(reason =&gt; {\n  console.log(reason)\n});\n\n//From console:\n//\"reject\"</code></pre><p><br></p>"}}