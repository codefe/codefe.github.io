{"sta":1,"data":{"subTitle":"Promise.race","content":"<p>Promise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。</p><pre><code>const promise1 = new Promise((resolve, reject) =&gt; {\n  setTimeout(resolve, 500, 'one');\n});\n\nconst promise2 = new Promise((resolve, reject) =&gt; {\n  setTimeout(resolve, 100, 'two');\n});\n\nPromise.race([promise1, promise2]).then((value) =&gt; {\n  console.log(value);\n  // Both resolve, but promise2 is faster\n});\n// expected output: \"two\"</code></pre><p><h3>语法\n</h3><blockquote>Promise.race(iterable);\n</blockquote><h3>参数\n</h3>iterable\n<br>可迭代对象，类似Array。详见 iterable。\n<br><h3>返回值\n</h3>一个待定的 Promise 只要给定的迭代中的一个promise解决或拒绝，就采用第一个promise的值作为它的值，从而异步地解析或拒绝（一旦堆栈为空）。\n<br>\n<br><h3>描述\n</h3>race 函数返回一个 Promise，它将与第一个传递的 promise 相同的完成方式被完成。它可以是完成（ resolves），也可以是失败（rejects），这要取决于第一个完成的方式是两个中的哪个。\n<br>\n<br>如果传的迭代是空的，则返回的 promise 将永远等待。\n<br>\n<br>如果迭代包含一个或多个非承诺值和/或已解决/拒绝的承诺，则 Promise.race 将解析为迭代中找到的第一个值。\n<br>\n<br><h3>Promise.race的异步性\n</h3>\n</p><pre><code>// we are passing as argument an array of promises that are already resolved,\n// to trigger Promise.race as soon as possible\nvar resolvedPromisesArray = [Promise.resolve(33), Promise.resolve(44)];\n\nvar p = Promise.race(resolvedPromisesArray);\n// immediately logging the value of p\nconsole.log(p);\n\n// using setTimeout we can execute code after the stack is empty\nsetTimeout(function(){\n    console.log('the stack is now empty');\n    console.log(p);\n});\n\n// logs, in order:\n// Promise { &lt;state&gt;: \"pending\" }\n// the stack is now empty\n// Promise { &lt;state&gt;: \"fulfilled\", &lt;value&gt;: 33 }</code></pre><h3>使用 Promise.race –  setTimeout 的示例</h3><pre><code>var p1 = new Promise(function(resolve, reject) {\n    setTimeout(resolve, 500, \"one\");\n});\nvar p2 = new Promise(function(resolve, reject) {\n    setTimeout(resolve, 100, \"two\");\n});\n\nPromise.race([p1, p2]).then(function(value) {\n  console.log(value); // \"two\"\n  // 两个都完成，但 p2 更快\n});\n\nvar p3 = new Promise(function(resolve, reject) {\n    setTimeout(resolve, 100, \"three\");\n});\nvar p4 = new Promise(function(resolve, reject) {\n    setTimeout(reject, 500, \"four\");\n});\n\nPromise.race([p3, p4]).then(function(value) {\n  console.log(value); // \"three\"\n  // p3 更快，所以它完成了\n}, function(reason) {\n  // 未被调用\n});\n\nvar p5 = new Promise(function(resolve, reject) {\n    setTimeout(resolve, 500, \"five\");\n});\nvar p6 = new Promise(function(resolve, reject) {\n    setTimeout(reject, 100, \"six\");\n});\n\nPromise.race([p5, p6]).then(function(value) {\n  // 未被调用\n}, function(reason) {\n  console.log(reason); // \"six\"\n  // p6 更快，所以它失败了\n});</code></pre><p><br></p>"}}