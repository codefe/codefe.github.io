{"sta":1,"data":{"subTitle":"Promise.any","content":"<p>Promise.any() 接收一个Promise可迭代对象，只要其中的一个 promise 成功，就返回那个已经成功的 promise 。如果可迭代对象中没有一个 promise 成功（即所有的 promises 都失败/拒绝），就返回一个失败的 promise 和AggregateError类型的实例，它是 Error 的一个子类，用于把单一的错误集合在一起。本质上，这个方法和Promise.all()是相反的。</p><h3>&nbsp;注意！ Promise.any() 方法依然是实验性的，尚未被所有的浏览器完全支持。它当前处于 TC39 第四阶段草案（Stage 4）</h3><p>\n<br><h3>语法\n</h3><blockquote>Promise.any(iterable);\n</blockquote><h3>参数\n</h3>iterable\n<br>一个可迭代的对象, 例如 Array。\n<br><h3>返回值\n</h3>如果传入的参数是一个空的可迭代对象，则返回一个 已失败（already rejected） 状态的 Promise。\n<br>如果传入的参数不包含任何 promise，则返回一个 异步完成 （asynchronously resolved）的 Promise。\n<br>其他情况下都会返回一个处理中（pending） 的 Promise。 只要传入的迭代对象中的任何一个 promise 变成成功（resolve）状态，或者其中的所有的 promises 都失败，那么返回的 promise 就会 异步地（当调用栈为空时） 变成成功/失败（resolved/reject）状态。\n<br><h3>说明\n</h3>这个方法用于返回第一个成功的 promise 。只要有一个 promise 成功此方法就会终止，它不会等待其他的 promise 全部完成。\n<br>\n<br>不像 Promise.all() 会返回一组完成值那样（resolved values），我们只能得到一个成功值（假设至少有一个 promise 完成）。当我们只需要一个 promise 成功，而不关心是哪一个成功时此方法很有用的。\n<br>\n<br>同时, 也不像 Promise.race() 总是返回第一个结果值（resolved/reject）那样，这个方法返回的是第一个 成功的 值。这个方法将会忽略掉所有被拒绝的 promise，直到第一个 promise 成功。\n<br>\n<br><h3>成功（Fulfillment）：\n</h3>当任何一个被传入的 promise 成功的时候, 无论其他的 promises 成功还是失败，此函数会将那个成功的 promise 作为返回值 。\n<br>\n<br>如果传入的参数是一个空的可迭代对象, 这个方法将会同步返回一个已经完成的 promise。\n<br>如果传入的任何一个 promise 已成功, 或者传入的参数不包括任何 promise, 那么 Promise.any 返回一个异步成功的 promise。\n<br><h3>失败/拒绝（Rejection）：\n</h3>如果所有传入的 promises 都失败, Promise.any 将返回异步失败，和一个 AggregateError 对象，它继承自 Error，有一个 error 属性，属性值是由所有失败值填充的数组。\n<br>\n<br><h3>示例<br>\nFirst to fulfil\n</h3>即使第一个返回的 promise 是失败的，Promise.any() 依然使用第一个成功状态的 promise 来返回。这与使用首个（无论 rejected 还是 fullfiled）promise 来返回的 Promise.race() 相反。</p><pre><code>const pErr = new Promise((resolve, reject) =&gt; {\n  reject(\"总是失败\");\n});\n\nconst pSlow = new Promise((resolve, reject) =&gt; {\n  setTimeout(resolve, 500, \"最终完成\");\n});\n\nconst pFast = new Promise((resolve, reject) =&gt; {\n  setTimeout(resolve, 100, \"很快完成\");\n});\n\nPromise.any([pErr, pSlow, pFast]).then((value) =&gt; {\n  console.log(value);\n  // pFast fulfils first\n})\n// 期望输出: \"很快完成\"</code></pre><p><h3>Rejections with AggregateError\n</h3>如果没有 fulfilled (成功的) promise，Promise.any() 返回 AggregateError 错误。\n<br>\n</p><pre><code>const pErr = new Promise((resolve, reject) =&gt; {\n  reject('总是失败');\n});\n\nPromise.any([pErr]).catch((err) =&gt; {\n  console.log(err);\n})\n// 期望输出: \"AggregateError: No Promise in Promise.any was resolved\"</code></pre><p><h3>显示第一张已加载的图片\n</h3>在这个例子，我们有一个获取图片并返回 blob 的函数，我们使用 Promise.any() 来获取一些图片并显示第一张有效的图片（即最先 resolved 的那个 promise）。&nbsp;<br></p><pre><code>function fetchAndDecode(url) {\n  return fetch(url).then(response =&gt; {\n    if(!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    } else {\n      return response.blob();\n    }\n  })\n}\n\nlet coffee = fetchAndDecode('coffee.jpg');\nlet tea = fetchAndDecode('tea.jpg');\n\nPromise.any([coffee, tea]).then(value =&gt; {\n  let objectURL = URL.createObjectURL(value);\n  let image = document.createElement('img');\n  image.src = objectURL;\n  document.body.appendChild(image);\n})\n.catch(e =&gt; {\n  console.log(e.message);\n});</code></pre><p><br></p>"}}