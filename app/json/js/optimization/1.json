{"sta":1,"data":{"subTitle":"高效js注意事项","content":"<h3>1. 避免全局变量</h3><p>    a. 避免使用var,它是挂载在window全局上的,改用let, const\n<br>    b. 在函数中 var a=b=c=10;只有a是在函数作用域中，b,c还是挂载到了window上，所有要分开定义\n<br>\n<br><h3>2. 避免全局查找\n</h3>    目标变量不存在于当前作用域内，通过作用域链向上查找\n<br>    a. 减少不必要的全局变量定义，把它放在当前作用域内\n<br>    b. 全局变理数据局部化\n<br>        function fn(){\n<br>\tconst w = window.innerWidth\n<br>\tconsole.log(w)\n<br>        }\n<br>\n<br><h3>3. 避免循环引用\n</h3>    a. 避免全局引用指多个对象之间存在互相引用\n<br>        function fn(){\n<br>\tlet obj = document.getElementById('btn');\n<br>\tobj.onclick = function(){\n<br>\t     console.log(`${this}`)\n<br>\t}\n<br>\t//注意下面这句\n<br>\tobj = null;\n<br>        }\n<br>        另一种方式是 onclick 后面的函数定义到外面去\n<br>        function click(){\n<br>\tconsole.log(`${this}`)\n<br>        }\n<br>        function fn(){\n<br>\tlet obj = document.getElementById('btn');\n<br>\tobj.onclick = click\n<br>        }\n<br>\n<br><h3>4. 采用字面量替换New操作\n</h3>    let a1 = [] //推荐这个\n<br>    let a2 = new Array()\n<br>\n<br><h3>5. setTimeout ， setInterval\n</h3>    setTimeout 每次执行都会申请空间，setInterval只申请一次\n<br>\n<br><h3>6. 采用事件委托\n</h3>    document.querySelectorAll('li').forEach(e) =&gt; {\n<br>\te.onclick = function(){\n<br>\t    ......\n<br>\t}\n<br>    }\n<br>\n<br>    采用事件委托\n<br>    document.querySelector('ul').onclick = (event) =&gt; {\n<br>\tlet ev = event || window.event;\n<br>\tlet tar = ev.target || ev.srcElement;\n<br>\tif(tar.nodeName.toLowerCase == 'li'){\n<br>\t    ........\n<br>\t}\n<br>    }\n<br>\n<br><h3>7. 合并循环变量和条件\n</h3>    for(let i=0;i&lt;6;i++){\n<br>\tconsole.log(i)\n<br>    }\n<br>    改为\n<br>    let num = 7;\n<br>    do{\n<br>\tconsole.log(i)\n<br>    } while (num--)\n<br>\n<br><h3>8. 数据循环优化\n</h3>    let len = arr.length\n<br>\n<br><h3>9. 使用文档碎片替代多次append\n</h3>    let frg = document.createDocumentFragment();\n<br>    for(){\n<br>\tfrg.appendChild(el)\n<br>    }\n<br>    document.body.appendChild(frg)\n<br>\n<br><h3>10. 使用clone替代create\n</h3>    let frg = document.createDocumentFragment();\n<br>    let pEl = document.getElementByTagName('p')[0];\n<br>    for(){\n<br>\tlet el = pEl.cloneNode(false)\n<br>\tel.innerHTML = 'fdgfgfg';\n<br>\tfrg.appendChild(el)\n<br>    }\n<br>    document.body.appendChild(frg)\n<br>\n<br><h3>11. 使用innerHTML创建DOM\n</h3>     let arr = []\n<br>     for(let i=0;i&lt;1000;i++){\n<br>\tarr.push(`&lt;p&gt;${i}&lt;/p&gt;`)\n<br>     }\n<br>     document.body.innerHTML = arr.join('');\n<br>\n<br><h3>12. JSBench使用\n</h3>     a. https://jsbench.me/\n<br>\n<br><h3>13. 减少判断层级 \n</h3>     function doSomething(part,chapter){\n<br>\tconst parts = ['es2016','webpack','vue','react','node']\n<br>\tif(part){\n<br>\t    if(parts.includes(part){\n<br>\t        if(chapter &gt; 5){\n<br>\t\tconsole.log('需要vip身份')\n<br>\t        }\n<br>\t    }\n<br>\t}else{\n<br>\t    console.log('part err')\n<br>\t}\n<br>      }\n<br>      减少层级\n<br>     function doSomething(part,chapter){\n<br>\tconst parts = ['es2016','webpack','vue','react','node']\n<br>\tif(!part){\n<br>\t     console.log('part err')\n<br>\t     return\n<br>\t}    \n<br>\tif(!parts.includes(part)){\n<br>\t        console.log('info')\n<br>\t        return\n<br>\t}\n<br>\tif(chapter &gt; 5){\n<br>\t        console.log('需要vip身份')\n<br>\t }\n<br>      }\n<br>\n<br><h3>14. 减少数据读取次数\n</h3>     a. 把要多次使用的属性值提前定义一个变量保存起来\n<br>\n<br><h3>15. 减少循环体中活动\n</h3>\n<br><h3>16. 减少声明及语句数\n</h3>\n<br><h3>17. 惰性函数与性能\n</h3>     //写一个通用添加事件函数\n<br>     function addEvent(obj,type,fn){\n<br>\tif(obj.addEventListener){\n<br>\t\tobj.addEventListener(type,fn,false)\n<br>\t}else if(obj.attachEvent){\n<br>\t\tobj.attachEvent('on'+type,fn)\n<br>\t}else{\n<br>\t\tobj['on'+type] = fn\n<br>\t}\n<br>     }\n<br>     //优化(反而慢了)\n<br>     function addEvent(obj,type,fn){\n<br>\tif(obj.addEventListener){\n<br>\t\taddEvent = obj.addEventListener(type,fn,false)\n<br>\t}else if(obj.attachEvent){\n<br>\t\taddEvent = obj.attachEvent('on'+type,fn)\n<br>\t}else{\n<br>\t\taddEvent = obj['on'+type] = fn\n<br>\t}\n<br>\treturn addEvent\n<br>     }\n<br>\n<br>\n<br></p>"}}