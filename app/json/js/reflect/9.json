{"sta":1,"data":{"subTitle":"Reflect.getOwnPropertyDescriptor","content":"<p>静态方法 Reflect.getOwnPropertyDescriptor() 与 Object.getOwnPropertyDescriptor() 方法相似。如果在对象中存在，则返回给定的属性的属性描述符。否则返回 undefined。&nbsp;</p><h3>语法&nbsp;</h3><blockquote>Reflect.getOwnPropertyDescriptor(target, propertyKey)&nbsp;</blockquote><h3>参数&nbsp;</h3><p>target\n需要寻找属性的目标对象。&nbsp;</p><p>propertyKey\n获取自己的属性描述符的属性的名称。&nbsp;</p><h3>返回值&nbsp;</h3><p>如果属性存在于给定的目标对象中，则返回属性描述符；否则，返回 undefined。&nbsp;</p><h3>异常&nbsp;</h3><p>抛出一个 TypeError，如果目标不是 Object。&nbsp;</p><h3>描述&nbsp;</h3><p>Reflect.getOwnPropertyDescriptor方法返回一个属性描述符，如果给定的属性存在于对象中，否则返回 undefined 。 与  Object.getOwnPropertyDescriptor() 的唯一不同在于如何处理非对象目标。</p><p>使用 Reflect.getOwnPropertyDescriptor()</p><pre><code>Reflect.getOwnPropertyDescriptor({x: \"hello\"}, \"x\");\n// {value: \"hello\", writable: true, enumerable: true, configurable: true}\n\nReflect.getOwnPropertyDescriptor({x: \"hello\"}, \"y\");\n// undefined\n\nReflect.getOwnPropertyDescriptor([], \"length\");\n// {value: 0, writable: true, enumerable: false, configurable: false}</code></pre><p><br></p><p><h3>与 Object.getOwnPropertyDescriptor() 的不同点\n</h3>如果该方法的第一个参数不是一个对象（一个原始值），那么将造成 TypeError 错误。而对于 Object.getOwnPropertyDescriptor，非对象的第一个参数将被强制转换为一个对象处理。</p><pre><code>Reflect.getOwnPropertyDescriptor(\"foo\", 0);\n// TypeError: \"foo\" is not non-null object\n\nObject.getOwnPropertyDescriptor(\"foo\", 0);\n// { value: \"f\", writable: false, enumerable: true, configurable: false }</code></pre><p><br></p><p><br></p><p><br></p>"}}