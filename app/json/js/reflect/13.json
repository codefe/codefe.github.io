{"sta":1,"data":{"subTitle":"Reflect.setPrototypeOf","content":"<p>除了返回类型以外，静态方法 Reflect.setPrototypeOf() 与 Object.setPrototypeOf() 方法是一样的。它可设置对象的原型（即内部的 [[Prototype]] 属性）为另一个对象或 null，如果操作成功返回 true，否则返回 false。</p><p>Reflect.setPrototypeOf 方法改变指定对象的原型（即，内部的 [[Prototype]] 属性值）。</p><pre><code>const object1 = {};\n\nconsole.log(Reflect.setPrototypeOf(object1, Object.prototype));\n// expected output: true\n\nconsole.log(Reflect.setPrototypeOf(object1, null));\n// expected output: true\n\nconst object2 = {};\n\nconsole.log(Reflect.setPrototypeOf(Object.freeze(object2), null));\n// expected output: false</code></pre><p><h3>语法\n</h3>Reflect.setPrototypeOf(target, prototype)\n<br><h3>参数\n</h3>target\n<br>设置原型的目标对象。\n<br>prototype\n<br>对象的新原型（一个对象或 null）。\n<br><h3>返回值\n</h3>返回一个 Boolean 值表明是否原型已经成功设置。\n<br>\n<br><h3>异常\n</h3>如果 target 不是 Object ，或 prototype 既不是对象也不是 null，抛出一个 TypeError 异常。</p><h3>使用 Reflect.setPrototypeOf()</h3><pre><code>Reflect.setPrototypeOf({}, Object.prototype); // true\n\n// It can change an object's [[Prototype]] to null.\nReflect.setPrototypeOf({}, null); // true\n\n// Returns false if target is not extensible.\nReflect.setPrototypeOf(Object.freeze({}), null); // false\n\n// Returns false if it cause a prototype chain cycle.\nvar target = {};\nvar proto = Object.create(target);\nReflect.setPrototypeOf(target, proto); // false</code></pre><p><br></p><p><br></p><p><br></p>"}}