{"sta":1,"data":{"subTitle":"平方和的平方根 Math.hypot","content":"<p>Math.hypot() 函数返回所有参数的平方和的平方根</p><p><h3>语法\n</h3><blockquote>Math.hypot([value1[,value2, ...]]) \n</blockquote><h3>参数\n</h3>value1, value2, ...\n<br>任意个数字。\n<br><h3>返回值\n</h3>将所提供的参数求平方和后开平方根。如果有参数不能转换为数字，则返回 NaN。\n<br>\n<br><h3>描述\n</h3>计算直角三角形的斜边，或复数的幅值时可以使用函数 Math.sqrt(v1*v1 + v2*v2) ，其中 v1 和 v2 是三角形的两个直角边或复数的实部和虚部。如果想计算更多维度，那么只需要在后面添加更多的数的平方就可以了，比如 Math.sqrt(v1*v1 + v2*v2 + v3*v3 + v4*v4)。\n<br>\n<br>本函数比 Math.sqrt() 更简单也更快，你只需要调用 Math.hypot(v1, v2) 或 Math.hypot(v1, v2, v3, v4, ...)。\n<br>\n<br>它还避免了幅值过大的问题。 JS 中最大的双精度浮点数是 Number.MAX_VALUE = 1.797...e+308。如果你的数字比约 1e154 大，计算其平方值会返回 Infinity，使你的结果出现问题。比如，Math.sqrt(1e200*1e200 + 1e200*1e200) = Infinity。如果你改用 hypot() 函数，你可以得到正确的答案：Math.hypot(1e200, 1e200) = 1.4142...e+200。在数字非常小的时候同样如此，比如 Math.sqrt(1e-200*1e-200 + 1e-200*1e-200) = 0，但 Math.hypot(1e-200, 1e-200) =1.4142...e-200 则是正确的结果。\n<br>\n<br>由于 hypot 是 Math 的静态方法，所以应该以 Math.hypot()的方式使用，而不是作为你创建的 Math 对象的属性（Math 不是一个构造函数）。\n<br>\n<br>如果不传入任何参数, 则返回 +0 .\n<br>\n<br>如果参数列表中有至少一个参数不能被转换为数字，则返回  NaN。\n<br>\n<br>如果只传入一个参数,  Math.hypot(x) 等同于 Math.abs(x).\n<br>\n<br><h3>示例</h3></p><pre><code>console.log(Math.hypot(3, 4));\n// expected output: 5\n\nconsole.log(Math.hypot(5, 12));\n// expected output: 13\n\nconsole.log(Math.hypot(3, 4, 5));\n// expected output: 7.0710678118654755\n\nconsole.log(Math.hypot(-5));\n// expected output: 5\n\nMath.hypot(3, 4);        // 5\nMath.hypot(3, 4, 5);     // 7.0710678118654755\nMath.hypot();            // 0\nMath.hypot(NaN);         // NaN\nMath.hypot(3, 4, 'foo'); // NaN, +'foo' =&gt; NaN\nMath.hypot(3, 4, '5');   // 7.0710678118654755, +'5' =&gt; 5\nMath.hypot(-3);          // 3, the same as Math.abs(-3)</code></pre><p><br></p>"}}