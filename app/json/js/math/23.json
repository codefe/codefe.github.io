{"sta":1,"data":{"subTitle":"三角函数在动画中的应用","content":"<h3>三角函数</h3><p>三角函数已经是老生常谈了（街舞圈称之为 Old School），它伴随我们从初中到大学，太多的公式定理，光是应付考试就花了不少时间。先简单回顾一下，确保你还记得基础知识。</p><p><strong>勾股定理</strong></p><p></p><p>最开始学三角函数的时候就是从背勾三股四弦五开始，勾股定理描述的是对于直角三角形，直角两条边的平方和等于斜边的平方，</p><p><img src=\"./app/json/js/math/img/1.png\" style=\"max-width:100%;\"></p><p>a^2 + b^2 = h^2\n<br>\n<br>常用三角函数\n<br>\n<br>印象中教科书里面只保留了 sin, cos, tan，其他可以通过变换得到。\n<br>\n<br><blockquote>sinθ = a / h\n<br>cosθ = b / h\n<br>tanθ = a / b\n</blockquote>\n\n\n<br>极坐标系和单位圆\n<br>\n<br>在笛卡尔直角坐标系中，任一点 (x, y) 都可以转化成极坐标表示 (r, θ)，其中\n<br>\n<br><blockquote>r = Math.sqrt(x^2 + y^2)\n<br>θ = Math.atan2(y, x)\n</blockquote>\n\n<br>单位圆的定义是半径为单位长度的圆，圆上任意一点的横坐标就是对应角度的余弦值，任意点的纵坐标就是对应角度的正弦值。\n<br>\n<br>单位圆\n<br>\n<br>简单的图像变换 以正弦曲线为例，对函数进行简单的变换，得到不一样的结果。</p><p><img src=\"./app/json/js/math/img/2.jpeg\" style=\"max-width:100%;\"></p><p>正弦曲线变换\n<br>\n<br>正弦曲线公式： y = A sin(Bx + C) + D\n<br>\n<br>A 控制振幅，A 值越大，波峰和波谷越大，A 值越小，波峰和波谷越小； B 值会影响周期，B 值越大，那么周期越短，B 值越小，周期越长。 C 值会影响图像左右移动，C 值为正数，图像右移，C 值为负数，图像左移。 D 值控制上下移动。\n<br>\n<br>这个公式非常有用，如果下文的代码让你不解，记得回来查看注解。\n<br>\n<br>简单得回顾一下之后，确保你还记得这些基础知识，那么这些曾经被得滚瓜烂熟的内容，和前端代码结合会变成什么样？\n<br>\n<br>常见的应用场景\n<br>图像应用\n<br>最直观的应用是使用三角函数来绘制 Wave 曲线\n<br>\n<br><blockquote>for (let x = 0; x &lt; width; x++) {\n<br>&nbsp; &nbsp; &nbsp; const y = Math.sin(x * a) * amplitude\n<br>}</blockquote>\n\n</p><p><img src=\"./app/json/js/math/img/3.jpeg\" style=\"max-width:100%;\"></p><p>简单曲线\n<br>\n<br>再结合三角函数偏移让左右成为波谷，中间成为波峰，就能得到曼妙的波纹。</p><pre><code>for (let x = 0; x &lt; width; x++) {\n  const radians = x / width * Math.PI * 2\n  const scale = (Math.sin(radians - Math.PI * 0.5) + 1) * 0.5\n  const y = Math.sin(x * 0.02 + xSpeed) * amplitude * scale\n}</code></pre><p></p><p><img src=\"./app/json/js/math/img/4.gif\" style=\"max-width:100%;\" class=\"\"></p><p>图像上的应用\n<br>\n<br>之前掘金上很火的一篇文章，也是同样的道理，使用两层正弦函数绘制曲线，fill 之后加上 stagger 动画，就能得到非常酷炫的?效果。</p><p><img src=\"./app/json/js/math/img/5.gif\" style=\"max-width:100%;\"></p><p>wave\n<br>\n<br>如果再结合鼠标位置 + lerp 动画，就能实现坚果首页同款的动画。</p><p><img src=\"./app/json/js/math/img/6.gif\" style=\"max-width:100%;\" class=\"\"></p><p>smartisan\n<br>\n<br>这篇文章大部分代码都可以在我的 Codepen 主页看到。\n<br>\n<br>SlowInSlowOut\n<br>正余弦曲线有很自然地缓入缓出的特性，并且在一个周期里面从 -1 到 1 再回到 -1，非常适合用来模拟一些物理效果。因为真实世界里面，汽车都是缓慢启动，加速，减速，再缓慢减速直到速度变为 0 的，突变会让人很难受。左边的摆球是线性匀速摆动，右边是用了三角函数优化的结果。显然左边的效果设计师会打人。</p><p><img src=\"./app/json/js/math/img/7.gif\" style=\"max-width:100%;\" class=\"\"></p><p>swing-ball\n<br>\n<br>只需使用 sin 或 cos 乘以最大角度，就可以得到在摆动最大角度之间的 SlowInSlowOut。</p><blockquote>ctx.rotate(Math.cos(t / 180 * Math.PI) * Math.PI * 0.25)</blockquote><p>角度控制\n<br>在开发过程中，我们常常需要跟角度打交道，比如在头像左上角（45deg）显示 Notification 红点，用鼠标控制 rotation 等等。\n<br>\n<br>前端 JS 里面 Math.atan2(y, x) 可以用来计算 (x, y) 和 x 轴正方向的夹角弧度值。</p><pre><code>function getCurrentDegree () {\n  const deltaX = mouse.x - window.innerWidth * 0.5\n  const deltaY = mouse.y - window.innerHeight * 0.5\n  return Math.atan2(deltaY, deltaX) * 180 / Math.PI\n}</code></pre><p><img src=\"./app/json/js/math/img/8.gif\" style=\"max-width:100%;\"></p><p><br></p><p>war-star\n<br>\n<br>插一句，三角函数相关的动画并不一定需要用 js 来写，比如下面的 DEMO，使用 compass 依赖，同样可以做到灵活控制在特定角度的动画（千万不要手写各个点的坐标！！！后期没办法维护）</p><pre><code>@import \"compass\";\n.checkbox:checked {\n  ~ button {\n    $per: 180 / 4;\n    @for $i from 1 through 6 {\n      &amp;:nth-of-type(#{$i}) {\n        $angle: $per * ($i - 1) * 1deg + 180deg;\n        $x: cos($angle) * $d;\n        $y: sin($angle) * $d;\n        transform: translate($x, $y) rotate(0deg) ;\n      }\n    }\n  }\n}</code></pre><p><img src=\"./app/json/js/math/img/9.gif\" style=\"max-width:100%;\"></p><p>千万不要手写各个点的坐标！！！</p><p><h3>Case Study\n</h3>经常用到的场景大概就这些吧，再以一个案例分析来复习一下。\n<br>\n<br>前两天在 Codepen 首页看到热门推荐，作者用存 css 动画来实现一个行走的动画，挺新颖的，然而仔细一看，脚步的动画真心觉得别扭，于是想用三角函数优化一下。</p><p><img src=\"./app/json/js/math/img/10.gif\" style=\"max-width:100%;\" class=\"\"></p><p>sad man\n<br>\n<br>绘制头部：</p><pre><code>drawHead (t) {\n  ctx.save()\n  ctx.beginPath()\n  ctx.translate(0, Math.sin(t) * 4)\n  ctx.arc(80, -35, 35, 0, 2 * Math.PI)\n  ctx.fill()\n  ctx.closePath()\n  ctx.restore()\n}</code></pre><p>我会给每个方法传入周期参数 t， t 从 0 到 2 PI , 这样能保证所有的周期运动时间同步。</p><p><img src=\"./app/json/js/math/img/11.gif\" style=\"max-width:100%;\" class=\"\"></p><p>head\n<br>\n<br>身体和阴影的绘制都差不多，直接跳过看脚步动画。\n<br>\n<br>脚有两只，按道理应该是抬脚到落脚的动作完成时，其他部位都完成了一个完整的周期，所以在绘制脚的时候，t 需要除以 2。然后第一只脚和第二只脚相差半个脚自身的周期，可以直接将 t 替换成 t + Math.PI 就是第二脚的动画。</p><pre><code>drawFeet (t) {\nt = t / 2\n  ctx.translate(Math.cos(t) * -50, 0)\n  // 另一只脚\n  ctx.translate(Math.cos(t + Math.PI) * -50, 0)\n}</code></pre><p><img src=\"./app/json/js/math/img/12.gif\" style=\"max-width:100%;\" class=\"\"></p><p>feet\n<br>\n<br>脚步动画自身周期的一半是在地面上的，可以通过判断一下 sin 值，小于 0 则不做 y 纵轴方向上的变化。<br><blockquote>ctx.translate(Math.cos(t) * -50, Math.sin(t) &gt; 0 ? Math.sin(t) * -35 : 0)</blockquote></p><p><img src=\"./app/json/js/math/img/13.gif\" style=\"max-width:100%;\" class=\"\"></p><p>feet2\n<br>\n<br>还没完，为了让脚更加逼真，同样在前半个周期做一下 rotate 。</p><pre><code>if (t &lt; Math.PI) {\n  ctx.rotate(Math.sin(t) * Math.PI / 180 * -5)\n}</code></pre><p><img src=\"./app/json/js/math/img/14.gif\" style=\"max-width:100%;\" class=\"\"></p><p>feet3\n<br>\n<br>最终得到的效果是这样的：</p><p><img src=\"./app/json/js/math/img/15.gif\" style=\"max-width:100%;\"></p><p>sad man in sine\n<br>\n<br>源码(<a href=\"https://codepen.io/HelKyle/pen/Mqgpvb\" target=\"_blank\">https://codepen.io/HelKyle/pen/Mqgpvb</a>)</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>"}}