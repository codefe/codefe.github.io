{"sta":1,"data":{"subTitle":"栈的应用,逆波兰表达式计算","content":"<p><strong>逆波兰表达式计算</strong></p><p><strong>要求：</strong> 逆波兰表达式，也叫后缀表达式，它将复杂表达式转换为可以依靠简单的操作得到计算结果的表达式，例如 (a+b)*(c+d)转换为 a b+c d+*</p><p><strong><em>[\"4\", \"13\", \"5\", \"/\", \"+\"] ==&gt; (4+(13 / 5)) = 6</em></strong></p><p><em><strong>[\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"]</strong></em></p><p><em><strong>==&gt; ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</strong></em></p><p></p><p><strong>分析：</strong> 以符号为触发节点，一旦遇到符号，就将符号前两个元素按照该符号运算，并将新的结果入栈，直到栈内仅一个元素</p><pre><code>function isOperator(str) {\n\n  return ['+', '-', '*', '/'].includes(str);\n\n}\n\n// 逆波兰表达式计算\n\nfunction clacExp(exp) {\n\n  const stack = new Stack();\n\n  for (let i = 0; i &lt; exp.length; i++) {\n\n    const one = exp[i];\n\n    if (isOperator(one)) {\n\n      const operatNum1 = stack.pop();\n\n      const operatNum2 = stack.pop();\n\n      const expStr = `${operatNum2}${one}${operatNum1}`;\n\n      const res = eval(expStr);\n\n      stack.push(res);\n\n    } else {\n\n      stack.push(one);\n\n    }\n\n  }\n\n  return stack.peek();\n\n}\n\nconsole.log(clacExp([\"4\", \"13\", \"5\", \"/\", \"+\"])); // 6.6</code></pre><p><br></p><p><br></p>"}}