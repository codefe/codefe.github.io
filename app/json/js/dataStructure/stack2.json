{"sta":1,"data":{"subTitle":"栈的实现","content":"<p>普通的栈常用的有以下几个方法：</p><p><code>1、push</code>&nbsp;添加一个（或几个）新元素到栈顶</p><p><code>2、pop</code>&nbsp;溢出栈顶元素，同时返回被移除的元素</p><p><code>3、peek</code>&nbsp;返回栈顶元素，不对栈做修改</p><p><code>4、isEmpty</code>&nbsp;栈内无元素返回&nbsp;<code>true</code>，否则返回&nbsp;<code>false</code></p><p><code>5、size</code>&nbsp;返回栈内元素个数</p><p></p><p><code>6、clear</code>&nbsp;清空栈</p><pre><code>class Stack {\n\n  constructor() {\n\n    this._items = []; // 储存数据\n\n  }\n\n  // 向栈内压入一个元素\n\n  push(item) {\n\n    this._items.push(item);\n\n  }\n\n  // 把栈顶元素弹出\n\n  pop() {\n\n    return this._items.pop();\n\n  }\n\n  // 返回栈顶元素\n\n  peek() {\n\n    return this._items[this._items.length - 1];\n\n  }\n\n  // 判断栈是否为空\n\n  isEmpty() {\n\n    return !this._items.length;\n\n  }\n\n  // 栈元素个数\n\n  size() {\n\n    return this._items.length;\n\n  }\n\n  // 清空栈\n\n  clear() {\n\n    this._items = [];\n\n  }\n\n}</code></pre><p>现在再回头想想数据结构里面的栈是什么。\n<br>\n<br>突然发现并没有那么神奇，仅仅只是对原有数据进行了一次封装而已。而封装的结果是：并不去关心其内部的元素是什么，只是去操作栈顶元素，这样的话，在编码中会更可控一些。</p><p><br></p>"}}