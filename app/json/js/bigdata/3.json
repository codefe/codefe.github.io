{"sta":1,"data":{"subTitle":"JavaScript操作文件和二进制数据","content":"<p>在很长的一段时间内 JavaScript 是不能操作二进制数据的。同样的为了安全性，直接操作文件也是不被支持的。但是随着 ECMAScript 5 的出现，引入了Blob对象，允许直接操作二进制数据。</p><p>当然在 ECMAScript 5 之前也可以操作二进制数据，但是速度慢还容易出错。charCodeAt()方法，支持一个个字节地从文字编码转成二进制数据，还有一种办法是将二进制数据转成Base64编码，再进行处理。今天我们要介绍的是使用 Blob对象，直接操作二进制数据。\n<br>\n<br>Blob对象是一个代表二进制数据的基本对象，在它的基础上，又衍生出一系列相关的API，用来操作文件。\n<br>\n<br><blockquote>File对象：负责处理那些以文件形式存在的二进制数据，也就是操作本地文件；<br>\nFileList对象：File对象的网页表单接口；<br>\nFileReader对象：负责将二进制数据读入内存内容；<br>\nURL对象：用于对二进制数据生成URL。</blockquote></p><p>&nbsp;\n<br><h3>Blob对象\n</h3>Blob（Binary Large Object）对象代表了一段二进制数据，提供了一系列操作接口。其他操作二进制数据的API（比如File对象），都是建立在Blob对象基础上的，继承了它的属性和方法。\n<br>\n<br>生成Blob对象有两种方法：<br><blockquote>一种是使用Blob构造函数<br>\n另一种是对现有的Blob对象使用slice方法切出一部分。</blockquote></p><p>&nbsp;\n<br>Blob构造函数，接受两个参数。第一个参数是一个包含实际数据的数组，第二个参数是数据的类型，这两个参数都不是必需的。</p><pre><code>var htmlParts = [\"hey!\"];\nvar myBlob = new Blob(htmlParts, { \"type\" : \"text\\/xml\" });</code></pre><p>下面是一个利用Blob对象，生成可下载文件的例子。</p><pre><code>var blob = new Blob([\"Hello World\"]);\nvar a = document.createElement(\"a\");\na.href = window.URL.createObjectURL(blob);\na.download = \"hello-world.txt\";\na.textContent = \"Download Hello World!\";\nbody.appendChild(a);</code></pre><p>上面的代码生成了一个超级链接，点击后提示下载文本文件hello-world.txt，文件内容为“Hello World”。<br>Blob对象的slice方法，将二进制数据按照字节分块，返回一个新的Blob对象。</p><pre><code>var newBlob = oldBlob.slice(startingByte, endindByte);</code></pre><p>下面是一个使用XMLHttpRequest对象，将大文件分割上传的例子。</p><pre><code>function upload(blobOrFile) {\n  var xhr = new XMLHttpRequest();\n  xhr.open('POST', '/server', true);\n  xhr.onload = function(e) { ... };\n  xhr.send(blobOrFile);\n}\ndocument.querySelector('input[type=\"file\"]').addEventListener('change', function(e) {\n  var blob = this.files[0];\n\n  const BYTES_PER_CHUNK = 1024 * 1024; // 1MB chunk sizes.\n  const SIZE = blob.size;\n\n  var start = 0;\n  var end = BYTES_PER_CHUNK;\n\n  while(start &lt; SIZE) {\n    upload(blob.slice(start, end));\n\n    start = end;\n    end = start + BYTES_PER_CHUNK;\n  }\n}, false)();</code></pre><p>Blob对象有两个只读属性：<br><blockquote>size：二进制数据的大小，单位为字节。<br>\ntype：二进制数据的MIME类型，全部为小写，如果类型未知，则该值为空字符串。\n</blockquote>在Ajax操作中，如果xhr.responseType设为blob，接收的就是二进制数据。\n<br>\n<br><h3>FileList对象\n</h3>FileList对象针对表单的file控件。当用户通过file控件选取文件后，这个控件的files属性值就是FileList对象。它在结构上类似于数组，包含用户选取的多个文件。</p><pre><code>&lt;input type=\"file\" id=\"input\" onchange=\"console.log(this.files.length)\" multiple /&gt;</code></pre><p>当用户选取文件后，就可以读取该文件。</p><pre><code>var selected_file = document.getElementById('input').files[0];</code></pre><p>采用拖放方式，也可以得到FileList对象。</p><pre><code>var dropZone = document.getElementById('drop_zone');\ndropZone.addEventListener('drop', handleFileSelect, false);\nfunction handleFileSelect(evt) {\n    evt.stopPropagation();\n    evt.preventDefault();\n    var files = evt.dataTransfer.files; // FileList object.\n    // ...\n}</code></pre><p>上面代码的 handleFileSelect 是拖放事件的回调函数，它的参数evt是一个事件对象，该参数的dataTransfer.files属性就是一个FileList对象，里面包含了拖放的文件。\n<br>\n<br><h3>File API\n</h3>File API提供File对象，它是FileList对象的成员，包含了文件的一些元信息，比如文件名、上次改动时间、文件大小和文件类型。</p><pre><code>var selected_file = document.getElementById('input').files[0];\nvar fileName = selected_file.name;\nvar fileSize = selected_file.size;\nvar fileType = selected_file.type;</code></pre><p>File对象的属性值如下：\n<br>\n<br><blockquote>name：文件名，该属性只读。<br>\nsize：文件大小，单位为字节，该属性只读。<br>\ntype：文件的MIME类型，如果分辨不出类型，则为空字符串，该属性只读。<br>\nlastModified：文件的上次修改时间，格式为时间戳。<br>\nlastModifiedDate：文件的上次修改时间，格式为Date对象实例。&nbsp;</blockquote></p><pre><code>$('#upload-file').files[0]\n// {\n//   lastModified: 1449370355682,\n//   lastModifiedDate: Sun Dec 06 2015 10:52:35 GMT+0800 (CST),\n//   name: \"HTTP 2 is here Goodbye SPDY Not quite yet.png\",\n//   size: 17044,\n//   type: \"image/png\"\n// }</code></pre><p><h3>FileReader API\n</h3>FileReader API用于读取文件，即把文件内容读入内存。它的参数是File对象或Blob对象。<br>对于不同类型的文件，FileReader提供不同的方法读取文件。<br><blockquote>readAsBinaryString(Blob|File)：返回二进制字符串，该字符串每个字节包含一个0到255之间的整数。<br>\nreadAsText(Blob|File, opt_encoding)：返回文本字符串。默认情况下，文本编码格式是’UTF-8’，可以通过可选的格式参数，指定其他编码格式的文本。<br>\nreadAsDataURL(Blob|File)：返回一个基于Base64编码的data-uri对象。<br>\nreadAsArrayBuffer(Blob|File)：返回一个ArrayBuffer对象。</blockquote></p><p>&nbsp;\n<br>readAsText方法用于读取文本文件，它的第一个参数是File或Blob对象，第二个参数是前一个参数的编码方法，如果省略就默认为UTF-8编码。该方法是异步方法，一般监听onload件，用来确定文件是否加载结束，方法是判断FileReader实例的result属性是否有值。其他三种读取方法，用法与readAsText方法类似。</p><pre><code>var reader = new FileReader();\nreader.onload = function(e) {\n  var text = reader.result;\n}\nreader.readAsText(file, encoding);</code></pre><p>readAsDataURL方法返回一个data URL，它的作用基本上是将文件数据进行Base64编码。你可以将返回值设为图像的src属性。</p><pre><code>var file = document.getElementById('destination').files[0];\nif(file.type.indexOf('image') !== -1) {\n  var reader = new FileReader();\n  reader.onload = function (e) {\n    var dataURL = reader.result;\n  }\n  reader.readAsDataURL(file);\n}</code></pre><p>readAsBinaryString方法可以读取任意类型的文件，而不仅仅是文本文件，返回文件的原始的二进制内容。这个方法与XMLHttpRequest.sendAsBinary方法结合使用，就可以使用JavaScript上传任意文件到服务器。</p><pre><code>var reader = new FileReader();\nreader.onload = function(e) {\n  var rawData = reader.result;\n}\nreader.readAsBinaryString(file);</code></pre><p>readAsArrayBuffer方法读取文件，返回一个类型化数组（ArrayBuffer），即固定长度的二进制缓存数据。在文件操作时（比如将JPEG图像转为PNG图像），这个方法非常方便。</p><pre><code>var reader = new FileReader();\nreader.onload = function(e) {\n  var arrayBuffer = reader.result;\n}\nreader.readAsArrayBuffer(file);</code></pre><p>除了以上四种不同的读取文件方法，FileReader API还有一个abort方法，用于中止文件上传。</p><pre><code>var reader = new FileReader();\nreader.abort();</code></pre><p>FileReader对象采用异步方式读取文件，可以为一系列事件指定回调函数。<br><blockquote>onabort方法：读取中断或调用reader.abort()方法时触发。<br>\nonerror方法：读取出错时触发。<br>\nonload方法：读取成功后触发。<br>\nonloadend方法：读取完成后触发，不管是否成功。触发顺序排在 onload 或 onerror 后面。<br>\nonloadstart方法：读取将要开始时触发。<br>\nonprogress方法：读取过程中周期性触发。</blockquote></p><p>&nbsp;\n<br>下面的代码是如何展示文本文件的内容。</p><pre><code>var reader = new FileReader();\nreader.onload = function(e) {\n  console.log(e.target.result);\n}\nreader.readAsText(blob);</code></pre><p>onload事件的回调函数接受一个事件对象，该对象的target.result就是文件的内容。\n<br>\n<br>下面是一个使用readAsDataURL方法，为img元素添加src属性的例子。</p><pre><code>var reader = new FileReader();\nreader.onload = function(e) {\n  document.createElement('img').src = e.target.result;\n};\nreader.readAsDataURL(f);</code></pre><p>下面是一个onerror事件回调函数的例子。</p><pre><code>var reader = new FileReader();\nreader.onerror = errorHandler;\nfunction errorHandler(evt) {\n  switch(evt.target.error.code) {\n    case evt.target.error.NOT_FOUND_ERR:\n      alert('File Not Found!');\n      break;\n    case evt.target.error.NOT_READABLE_ERR:\n      alert('File is not readable');\n      break;\n    case evt.target.error.ABORT_ERR:\n      break;\n    default:\n      alert('An error occurred reading this file.');\n  };\n}</code></pre><p>下面是一个onprogress事件回调函数的例子，主要用来显示读取进度。</p><pre><code>var reader = new FileReader();\nreader.onprogress = updateProgress;\nfunction updateProgress(evt) {\n  if (evt.lengthComputable) {\n    var percentLoaded = Math.round((evt.loaded / evt.totalEric Bidelman) * 100);\n    var progress = document.querySelector('.percent');\n    if (percentLoaded &lt; 100) {\n      progress.style.width = percentLoaded + '%';\n      progress.textContent = percentLoaded + '%';\n    }\n  }\n}</code></pre><p>读取大文件的时候，可以利用Blob对象的slice方法，将大文件分成小段，逐一读取，这样可以加快处理速度。</p><p><br></p>"}}