{"sta":1,"data":{"subTitle":"函数的调用模式","content":"<p>先介绍一下函数的调用模式有哪四种：</p><ol><li>　函数调用模式，</li><li>　方法调用模式，</li><li>　构造函数调用模式，</li><li>　上下文调用模式；</li></ol><p></p><p>在这里对于函数的调用模式，主要介绍每种调用模式的this的指向和返回值。</p><h3>1. 函数调用模式</h3><p>下面的调用模式就是大家最熟悉的函数调用模式，而函数调用模式的this指向和返回值是什么呢？</p><pre><code>function fn1 () {\n console.log(this); \n};\nfn1(); // 在调用函数fn1时，输出的this的结果是Window</code></pre><p>在上述代码中，fn1也就是函数调用模式中的this是指向Window的，而返回值是由return决定。\n<br>可以得出以下结论(函数调用模式中)：\n<br><blockquote>a, this是指向Window的　<br>\nb, 返回值是由return语句决定的，如果没有return则表示没有返回值</blockquote></p><h3>2. 方法调用模式</h3><pre><code>var name = \"james\";\nvar obj = {\n　 name : \"wade\",\n fn1 : function () {\n  console.log(this.name);\n }  \n};\nobj.fn1(); // 在调用obj中的fn1方法函数时，输出的是wade</code></pre><p>通过上面的代码结果分析，会得到以下结论（方法调用模式中）：<br><blockquote>  a, this 是指向调用该方法的对象<br>  b, 返回值还是由return语句决定，如果没有return表示没有返回值</blockquote></p><h3>3. 构造函数调用模式</h3><pre><code>function Fn () {\n this.name = \"james\",\n this.age = 32,\n console.log(this)   \n};\nvar fn1 = new Fn();　　// 在调用这段代码的时候，输出的是Fn {name: \"james\", age: 32}</code></pre><p>通过上面的代码结果分析，会得到以下结论（构造函数调用模式中）：<br><blockquote>  a, this是指向构造函数的实例<br>  b, 如果没有添加返回值的话，默认的返回值是this</blockquote>但是如果手动添加返回值之后呢</p><pre><code>function Fn1 () {\n this.name = \"james\";\n return \"wade\"\n};\nvar fn1 = new Fn1();\nconsole.log(fn1.name); // 这段代码输出的是 james;\nfunction Fn2 () {\n this.name = \"james\";\n return [1,2,3]; \n};\nvar fn2 = new Fn2();\nconsole.log(fn2.name); // 而这段代码输出的是undefined</code></pre><p>而通过上面的代码结果分析，优化上面的结论：<br><blockquote>  a, this是指向构造函数的实例<br>  b, 如果没有添加返回值的话，默认的返回值是this<br>  c, 如果有返回值，且返回值是简单数据类型（Number,String,Boolean··）的话，最后仍回返回this<br>  d, 如果有返回值，且返回值是复杂数据类型（对象）的话，最终返回该对象，所以上面的fn2是指向数组，所以fn2.name为undefined</blockquote></p><h3>4. 上下文调用模式</h3><p><strong>上下文就是环境, 就是自定义this的含义</strong><br><mark>语法:</mark><br>1、函数名.apply( 对象, [参数]);<br>这个参数可以是数组, 也可以是伪数组<br>2、函数名.call( 对象, 参数);<br>多个参数可以通过,进行隔离<br>特点：<br>1、函数名表示的是函数本身, 使用函数进行调用的时候,默认this指的是全局变量<br>2、函数名也可以是方法提供, 使用方法调用的时候, this指的是当前对象<br>3、使用 apply 或者 call 进行调用后, 无论是函数, 还是方法的 this 指向全部无效了, this 的指向由 apply 或者 call 的第一个参数决定<br><mark>注意：</mark><br>1、如果函数或方法中没有this的操作, 那么无论是哪一种函数调用模式, 其实都一样<br>2、如果是函数调用 foo(), 其实和 foo.apply(window) 类似<br>3、如果是方法调用 o.method(), 其实和 o.method.apply(o)<br><strong><mark>无论是 call 还是 apply 在没有后面参数的情况下(函数无参数, 方法无参数), 两者一致</mark></strong><br></p><pre><code>function f1(){\n console.log(this);\n}\nf1.call(null); // Window\nf1.call(undefined); // Window\nf1.call(123); // Number的实例\nf1.call(\"abc\"); // String的实例\nf1.call(true); // Boolean的实例\nf1.call([1,2,3]); // Array的实例</code></pre><p>通过上面的代码结果分析，得出以下结论（上下文调用模式中）：<br><blockquote>  a, 传递的参数不同，this的指向不同，this会指向传入参数的数据类型<br>  b, 返回值是由return决定，如果没有return表示没有返回值。</blockquote></p><p>apply 和 call 第一个参数的使用规则\n<br>1、如果传入的是一个对象, 就相当于设置该函数中的this为参数\n<br>2、如果不传参数, 或者传入 null, undefined 等,那么this就默认是 window</p><pre><code>foo();\n    foo.apply();\n    foo.apply(null);\n    foo.apply(undefined);\n    foo.call();\n    foo.call(null);\n    foo.call(undefined);\n    // 上面都this都指向window</code></pre><p>如果传入的是基本类型, 那么this指向的就是基本类型的包装类型的引用\n<br><blockquote>number =&gt; Number<br>\nboolean =&gt; Boolean<br>\nstring =&gt; String</blockquote></p><p><br></p>"}}