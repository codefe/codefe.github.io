{"sta":1,"data":{"subTitle":"深拷贝","content":"<pre>function extendDeeply(p, c){\n  var c = c || {};\n  for (var prop in p){\n    if(typeof p[prop] === \"object\"){\n      c[prop] = (p[prop].constructor === Array)?[]:{};\n      extendDeeply(p[prop], c[prop]);\n    }else{\n      c[prop] = p[prop];\n    }\n  }\n}</pre><p>或</p><pre>function cloneObj(obj) {\n    var o = obj.constructor == Object ? new obj.constructor() : new obj.constructor(obj.valueOf());\n    for(var key in obj){\n        if(o[key] != obj[key] ){\n            if(typeof(obj[key]) == 'object' ){\n                o[key] = mods.cloneObj(obj[key]);\n            }else{\n                o[key] = obj[key];\n            }\n        }\n    }\n    return o;\n    }</pre><p><br></p><p>利用递归进行深拷贝，这样子对象的修改就不会影响到父对象。&nbsp;</p><pre>extendDeeply(Person, programer);\nprogramer.address.home = 'allin';\nPerson.address.home; // home\n利用call和apply继承\nfunction Parent(){\n  this.name = \"abc\";\n  this.address = {home: \"home\"};\n}\nfunction Child(){\n  Parent.call(this);\n  this.language = \"js\"; \n}\nES5中的Object.create()\nvar p = { name : 'allin'};\nvar obj = Object.create(o);\nobj.name; // allin</pre><p>Object.create()作为new操作符的替代方案是ES5之后才出来的。我们也可以自己模拟该方法：&nbsp;<br></p><pre>//模拟Object.create()方法\nfunction myCreate(o){\n  function F(){};\n  F.prototype = o;\n  o = new F();\n  return o;\n}\nvar p = { name : 'allin'};\nvar obj = myCreate(o);\nobj.name; // allin</pre><p>目前，各大浏览器的最新版本（包括IE9）都部署了这个方法。如果遇到老式浏览器，可以用下面的代码自行部署。</p><pre>if (!Object.create) {\n　　Object.create = function (o) {\n　　　　 function F() {}\n　　　　F.prototype = o;\n　　　　return new F();\n　　};\n}</pre><p><br></p>"}}